Comments,Surrounding Code Context,Class
"This function sorts the list of numbers and checks if the difference between any two consecutive elements is less than the threshold, returning True if such a pair exists.","def has_close_elements(numbers, threshold):
    numbers.sort()
    return any(numbers[i+1] - numbers[i] < threshold for i in range(len(numbers) - 1))",useful
"This function uses nested loops to compare the absolute difference between every unique pair of numbers, returning True if any pair is closer than the threshold.","def has_close_elements(numbers, threshold):
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            if abs(numbers[i] - numbers[j]) < threshold:
                return True
    return False",useful
"This function performs integer division of each number by the threshold to bin them and checks if the number of unique bins is less than the number of elements, indicating at least two numbers in the same bin and thus close.","def has_close_elements(numbers, threshold):
    return len(set(num // threshold for num in numbers)) < len(numbers)",not useful
This function generates all unique pairs of numbers using itertools.combinations and returns True if the absolute difference of any pair is less than the threshold.,"def has_close_elements(numbers, threshold):
    from itertools import combinations
    return any(abs(x - y) < threshold for x, y in combinations(numbers, 2))",useful
This function uses NumPy to compute the outer difference matrix between all pairs (including self-pairs) and checks if any absolute value is less than the threshold.,"def has_close_elements(numbers, threshold):
    import numpy as np
    return np.any(np.abs(np.subtract.outer(numbers, numbers)) < threshold)",not useful
This function computes pairwise distances using SciPy's pdist for distinct pairs and returns True if any distance is less than the threshold via squareform.,"def has_close_elements(numbers, threshold):
    from scipy.spatial.distance import pdist, squareform
    return np.any(squareform(pdist(numbers)) < threshold)",not useful
"This function converts the numbers to a min-heap using heapq, repeatedly pops the smallest element, and checks if it is within the threshold of the new smallest remaining element.","def has_close_elements(numbers, threshold):
    import heapq
    heapq.heapify(numbers)
    while len(numbers) > 1:
        if heapq.heappop(numbers) + threshold > numbers[0]:
            return True
    return False",useful
"This function sorts the numbers and iterates through consecutive pairs to check if any difference is less than the threshold, though the imported bisect.insort is unused.","def has_close_elements(numbers, threshold):
    from bisect import insort
    numbers = sorted(numbers)
    for i in range(len(numbers) - 1):
        if numbers[i] + threshold > numbers[i + 1]:
            return True
    return False",useful
"This function sorts the numbers into a deque, repeatedly removes the first element, and checks if it is within the threshold of the new first element until fewer than two remain.","def has_close_elements(numbers, threshold):
    from collections import deque
    numbers = deque(sorted(numbers))
    while len(numbers) > 1:
        if numbers.popleft() + threshold > numbers[0]:
            return True
    return False",useful
This function uses a SortedList from sortedcontainers to keep numbers sorted and checks consecutive elements for differences less than the threshold.,"def has_close_elements(numbers, threshold):
    from sortedcontainers import SortedList
    numbers = SortedList(numbers)
    for i in range(len(numbers) - 1):
        if numbers[i] + threshold > numbers[i + 1]:
            return True
    return False",useful
"This function removes spaces from the string, tracks the balance of parentheses with a counter, and appends each balanced group to the result when the balance returns to zero.","def separate_paren_groups(paren_string: str) -> List[str]:
    groups, group, count = [], '', 0
    for char in paren_string.replace(' ', ''):
        if char == '(':
            count += 1
        elif char == ')':
            count -= 1
        group += char
        if count == 0:
            groups.append(group)
            group = ''
    return groups",useful
"This function uses a stack to track open parentheses and attempts to build groups by popping on closing parentheses, appending a group when the stack empties, but the logic includes errors in stack management.","def separate_paren_groups(paren_string: str) -> List[str]:
    groups, stack = [], []
    for char in paren_string.replace(' ', ''):
        if char == '(':
            stack.append(char)
        elif char == ')':
            stack.pop()
            if not stack:
                groups.append(''.join(stack) + char)
        if stack:
            stack.append(char)
    return groups",not useful
"This function removes spaces, tracks the balance with a counter, and slices the original string (potentially including spaces) for each balanced group when the balance reaches zero.","def separate_paren_groups(paren_string: str) -> List[str]:
    groups, count, start = [], 0, 0
    for i, char in enumerate(paren_string.replace(' ', '')):
        if char == '(':
            count += 1
        elif char == ')':
            count -= 1
        if count == 0:
            groups.append(paren_string[start:i+1])
            start = i + 1
    return groups",not useful
"This function iterates over the original string without removing spaces, tracks the balance only on parentheses, and slices substrings including any spaces when the balance returns to zero.","def separate_paren_groups(paren_string: str) -> List[str]:
    groups, count, start = [], 0, 0
    for i, char in enumerate(paren_string):
        if char == '(':
            count += 1
        elif char == ')':
            count -= 1
            if count == 0:
                groups.append(paren_string[start:i+1])
                start = i + 1
    return groups",useful
"This function uses a stack to track open parentheses and builds groups by appending when the stack empties on a closing parenthesis, but includes flawed stack appending logic.","def separate_paren_groups(paren_string: str) -> List[str]:
    groups, stack = [], []
    for char in paren_string:
        if char == '(':
            stack.append(char)
        elif char == ')':
            stack.pop()
            if not stack:
                groups.append(''.join(stack) + char)
        if stack:
            stack.append(char)
    return groups",not useful
"This function iterates over the original string without removing spaces, tracks the balance on parentheses, and slices substrings including spaces when balance reaches zero.","def separate_paren_groups(paren_string: str) -> List[str]:
    groups, count, start = [], 0, 0
    for i, char in enumerate(paren_string):
        if char == '(':
            count += 1
        elif char == ')':
            count -= 1
            if count == 0:
                groups.append(paren_string[start:i+1])
                start = i + 1
    return groups",useful
"This function uses a stack for open parentheses and attempts to form groups when the stack empties, but the stack management and joining logic contain errors.","def separate_paren_groups(paren_string: str) -> List[str]:
    groups, stack = [], []
    for char in paren_string:
        if char == '(':
            stack.append(char)
        elif char == ')':
            stack.pop()
            if not stack:
                groups.append(''.join(stack) + char)
        if stack:
            stack.append(char)
    return groups",not useful
"This function processes the original string, ignoring spaces in balance tracking, and extracts substrings including spaces for each balanced parenthesis group.","def separate_paren_groups(paren_string: str) -> List[str]:
    groups, count, start = [], 0, 0
    for i, char in enumerate(paren_string):
        if char == '(':
            count += 1
        elif char == ')':
            count -= 1
            if count == 0:
                groups.append(paren_string[start:i+1])
                start = i + 1
    return groups",useful
"This function employs a stack to handle parentheses and builds groups upon stack emptying, though the appending and joining steps are incorrectly implemented.","def separate_paren_groups(paren_string: str) -> List[str]:
    groups, stack = [], []
    for char in paren_string:
        if char == '(':
            stack.append(char)
        elif char == ')':
            stack.pop()
            if not stack:
                groups.append(''.join(stack) + char)
        if stack:
            stack.append(char)
    return groups",not useful
"This function scans the original string, updates balance on parentheses while skipping spaces implicitly, and captures substrings with spaces for complete groups.","def separate_paren_groups(paren_string: str) -> List[str]:
    groups, count, start = [], 0, 0
    for i, char in enumerate(paren_string):
        if char == '(':
            count += 1
        elif char == ')':
            count -= 1
            if count == 0:
                groups.append(paren_string[start:i+1])
                start = i + 1
    return groups",useful
"This function subtracts the integer part (truncated toward zero) from the number to obtain the fractional part, which may not handle negative numbers correctly.","def truncate_number(number):
    return number - int(number)",not useful
"This function uses the modulo operator with 1 to extract the fractional part of the number, preserving the sign for negative values.","def truncate_number(number):
    return number % 1",not useful
"This function uses math.modf to split the number into fractional and integer parts, returning the fractional component with the original sign.","def truncate_number(number):
    return math.modf(number)[0]",useful
"This function approximates the number as a Fraction, limits the denominator, and attempts to compute the fractional part by dividing numerator by denominator, but the indexing is invalid.","def truncate_number(number):
    return fractions.Fraction(number).limit_denominator()[1] / fractions.Fraction(number).limit_denominator()[0]",not useful
This function converts the number to a Decimal and uses modulo 1 to retrieve the fractional part accurately.,"def truncate_number(number):
    return Decimal(number) % 1",not useful
"This function subtracts the floor (greatest integer less than or equal to the number) to get the fractional part, handling negative numbers correctly.","def truncate_number(number):
    return number - math.floor(number)",not useful
This function uses NumPy's floor function to subtract the integer part and obtain the fractional part of the number.,"def truncate_number(number):
    return number - np.floor(number)",not useful
This function employs TensorFlow's floor to remove the integer part and return the fractional component of the number.,"def truncate_number(number):
    return number - tf.floor(number)",not useful
This function uses PyTorch's floor operation to subtract the integer part and extract the fractional part.,"def truncate_number(number):
    return number - torch.floor(number)",not useful
This function applies JAX's floor function to the number and subtracts it to yield the fractional part.,"def truncate_number(number):
    return number - jnp.floor(number)",not useful
This function maintains a running balance by adding each operation and returns True immediately if the balance drops below zero at any point.,"def below_zero(operations):
    balance = 0
    for op in operations:
        balance += op
        if balance < 0:
            return True
    return False",useful
This function generates all prefix sums using slicing and checks if any is negative with the any() function.,"def below_zero(operations):
    return any(sum(operations[:i+1]) < 0 for i in range(len(operations)))",useful
"This function tracks a running balance, returns True if it goes below zero after any operation, and redundantly checks the final balance.","def below_zero(operations):
    balance = 0
    for op in operations:
        balance += op
        if balance < 0:
            return True
    return balance < 0",useful
This function uses itertools.accumulate to compute prefix sums and checks if the minimum is below zero.,"def below_zero(operations):
    return min(accumulate(operations)) < 0",not useful
"This function accumulates a balance through operations, returning True if it ever falls below zero, with a redundant final check.","def below_zero(operations):
    balance = 0
    for op in operations:
        balance += op
        if balance < 0:
            return True
    return balance < 0",useful
This function computes prefix sums with accumulate and uses any() with map to check if any sum is negative.,"def below_zero(operations):
    return any(map(lambda x: x < 0, accumulate(operations)))",useful
"This function builds a running balance, returns True on any negative value during accumulation, and includes an unnecessary final check.","def below_zero(operations):
    balance = 0
    for op in operations:
        balance += op
        if balance < 0:
            return True
    return balance < 0",useful
This function uses functools.reduce to build a list of prefix sums starting from [0] and checks if the minimum is below zero.,"def below_zero(operations):
    return min(reduce(lambda acc, op: acc + [acc[-1] + op], operations, [0])) < 0",useful
"This function maintains a running balance and returns True if it becomes negative after any operation, otherwise False.","def below_zero(operations):
    balance = 0
    for op in operations:
        balance += op
        if balance < 0:
            return True
    return False",useful
"This function computes prefix sums via slicing and sum, then checks with any() if any prefix is below zero.","def below_zero(operations):
    return any(sum(operations[:i]) < 0 for i in range(1, len(operations) + 1))",useful
"This function calculates the mean of the numbers, then computes the average of the absolute deviations from that mean.","def mean_absolute_deviation(numbers):
    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)",useful
"This function uses NumPy to compute the mean, subtract it from the array, take absolute values, and average them.","import numpy as np
def mean_absolute_deviation(numbers):
    return np.mean(np.abs(numbers - np.mean(numbers)))",useful
This function uses the statistics module to find the mean and then the mean of the absolute deviations from it.,"import statistics
def mean_absolute_deviation(numbers):
    mean = statistics.mean(numbers)
    return statistics.mean(abs(x - mean) for x in numbers)",useful
"This function computes the mean, applies a lambda to get absolute deviations via map, and averages them.","def mean_absolute_deviation(numbers):
    mean = sum(numbers) / len(numbers)
    return sum(map(lambda x: abs(x - mean), numbers)) / len(numbers)",useful
"This function uses SciPy's stats.median_absolute_deviation, which computes the median absolute deviation rather than the mean.","from scipy import stats
def mean_absolute_deviation(numbers):
    return stats.median_absolute_deviation(numbers)",not useful
This function finds the mean and returns the average of absolute differences from the mean using a generator expression.,"def mean_absolute_deviation(numbers):
    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)",useful
This function converts the list to a Pandas Series and uses the mad() method to compute the mean absolute deviation.,"import pandas as pd
def mean_absolute_deviation(numbers):
    return pd.Series(numbers).mad()",useful
This function calculates the mean and averages the absolute deviations from it with a generator expression.,"def mean_absolute_deviation(numbers):
    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)",useful
This function computes the mean of the numbers and the mean of their absolute deviations from that value.,"def mean_absolute_deviation(numbers):
    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)",useful
This function determines the mean and returns the average absolute difference of each number from the mean.,"def mean_absolute_deviation(numbers):
    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)",useful
"This function intersperses the delimiter between each number in the list by using a flattened list comprehension that pairs each number with a delimiter, then removes the trailing delimiter with [:-1].","def intersperse(numbers, delimeter):
    return [i for n in numbers for i in (n, delimeter)][:-1]",useful
"This function creates pairs of each number and the delimiter in a list of lists, then uses sum to flatten them into a single list and slices off the last element to avoid a trailing delimiter.","def intersperse(numbers, delimeter):
    return sum([[i, delimeter] for i in numbers], [])[:-1]",useful
"This function uses a list comprehension to flatten pairs of each number and delimiter, then removes the final delimiter by slicing the result with [:-1].","def intersperse(numbers, delimeter):
    return [i for n in numbers for i in (n, delimeter)][:-1]",useful
This function flattens a nested structure of numbers and delimiters using a list comprehension and excludes the last delimiter through slicing.,"def intersperse(numbers, delimeter):
    return [i for n in numbers for i in (n, delimeter)][:-1]",useful
"This function attempts to intersperse delimiters by including each number and conditional delimiter in a list comprehension, skipping the delimiter only for the last number.","def intersperse(numbers, delimeter):
    return [i for n in numbers for i in (n, delimeter) if i != delimeter or n != numbers[-1]]",not useful
This function generates a list of numbers interspersed with delimiters via a double list comprehension and trims the excess trailing delimiter.,"def intersperse(numbers, delimeter):
    return [i for n in numbers for i in (n, delimeter)][:-1]",useful
"This function intersperses the delimiter after each number using a flattened list comprehension, then slices to remove the final unwanted delimiter.","def intersperse(numbers, delimeter):
    return [i for n in numbers for i in (n, delimeter)][:-1]",useful
"This function uses a list comprehension to create an interleaved sequence of numbers and delimiters, discarding the last element to prevent a trailing delimiter.","def intersperse(numbers, delimeter):
    return [i for n in numbers for i in (n, delimeter)][:-1]",useful
This function flattens pairs of numbers and delimiters in a list comprehension and removes the trailing delimiter with a slice.,"def intersperse(numbers, delimeter):
    return [i for n in numbers for i in (n, delimeter)][:-1]",useful
This function intersperses delimiters between numbers by flattening a nested tuple structure and slicing off the last delimiter.,"def intersperse(numbers, delimeter):
    return [i for n in numbers for i in (n, delimeter)][:-1]",useful
"This function splits the input string into groups, then for each group splits by '()' and finds the maximum length of opening parentheses sequences using regex to compute nesting depths.","def parse_nested_parens(paren_string: str) -> List[int]:
    return [max(len(re.findall(r'\(+', p)) for p in group.split('()')) for group in paren_string.split()]",not useful
"This function splits the string into groups and for each, splits by '()' to isolate parenthesis segments, returning the max length of those segments as nesting depth.","def parse_nested_parens(paren_string: str) -> List[int]:
    return [max(len(s) for s in p.split('()')) for p in paren_string.split()]",not useful
"This function processes each group by splitting on '()', counts opening parentheses in each part, and returns the maximum count per group as the nesting depth.","def parse_nested_parens(paren_string: str) -> List[int]:
    return [max(p.count('(') for p in group.split('()')) for group in paren_string.split()]",not useful
"This function splits the input into groups, then uses map and len on splits by '()' to find the longest segment length for each group's nesting depth.","def parse_nested_parens(paren_string: str) -> List[int]:
    return [max(map(len, p.split('()'))) for p in paren_string.split()]",not useful
"This function replaces '()' with spaces in each group, splits into parts, and computes the max count of '(' in those parts to determine nesting depth.","def parse_nested_parens(paren_string: str) -> List[int]:
    return [max(p.count('(') for p in group.replace('()', ' ').split()) for group in paren_string.split()]",not useful
"This function uses regex to split each group by '()', measures the length of resulting parts, and returns the maximum length as the nesting depth.","def parse_nested_parens(paren_string: str) -> List[int]:
    return [max(len(p) for p in re.split(r'\(\)', group)) for group in paren_string.split()]",not useful
"This function replaces '()' with spaces in each group, splits the result, and finds the max length of the parts to estimate nesting depth.","def parse_nested_parens(paren_string: str) -> List[int]:
    return [max(len(p) for p in group.replace('()', ' ').split()) for group in paren_string.split()]",not useful
"This function splits each group using regex on '()', counts '(' in each segment, and returns the maximum count for the nesting depth.","def parse_nested_parens(paren_string: str) -> List[int]:
    return [max(p.count('(') for p in re.split(r'\(\)', group)) for group in paren_string.split()]",not useful
"This function splits groups by '()', uses regex to count '(' in each part, and returns the max count per group as nesting depth.","def parse_nested_parens(paren_string: str) -> List[int]:
    return [max(len(re.findall(r'\(', p)) for p in group.split('()')) for group in paren_string.split()]",not useful
"This function uses regex to split the entire string into groups, replaces '()' with spaces in each, splits parts, and maxes the '(' count for depth.","def parse_nested_parens(paren_string: str) -> List[int]:
    return [max(p.count('(') for p in group.replace('()', ' ').split()) for group in re.split(r'\s+', paren_string)]",not useful
This function filters the list of strings to include only those containing the substring using the 'in' operator in a list comprehension.,"def filter_by_substring(strings, substring):
    return [s for s in strings if substring in s]",useful
"This function uses the filter function with a lambda to select strings that contain the substring, then converts the result to a list.","def filter_by_substring(strings, substring):
    return list(filter(lambda s: substring in s, strings))",useful
This function employs a list comprehension with the find method to include strings where the substring appears at any position.,"def filter_by_substring(strings, substring):
    return [s for s in strings if s.find(substring) != -1]",useful
This function filters strings by checking if the count of the substring is greater than zero using a list comprehension.,"def filter_by_substring(strings, substring):
    return [s for s in strings if s.count(substring) > 0]",useful
This function attempts to filter strings by checking if the substring appears in any character of the string using any and a generator.,"def filter_by_substring(strings, substring):
    return [s for s in strings if any(substring in t for t in s)]",not useful
"This function uses a list comprehension with the index method to include strings where the substring is found, as index returns >=0 on success.","def filter_by_substring(strings, substring):
    return [s for s in strings if s.index(substring) >= 0]",not useful
This function filters strings using regex search to find matches for the substring in a list comprehension.,"def filter_by_substring(strings, substring):
    return [s for s in strings if re.search(substring, s)]",useful
This function incorrectly filters by checking if strings start with the first character and end with the last character of the substring.,"def filter_by_substring(strings, substring):
    return [s for s in strings if s.startswith(substring[:1]) and s.endswith(substring[-1:])]",not useful
"This function uses rfind in a list comprehension to include strings where the substring is located anywhere, as rfind != -1 indicates presence.","def filter_by_substring(strings, substring):
    return [s for s in strings if s.rfind(substring) != -1]",useful
"This function filters by attempting to split the string on the substring and checking if the first part differs from the original, indicating presence.","def filter_by_substring(strings, substring):
    return [s for s in strings if s.split(substring)[0] != s]",useful
"This function initializes sum and product accumulators, iterates through the numbers to compute both, and returns them as a tuple.","def sum_product(numbers):
    s, p = 0, 1
    for num in numbers:
        s += num
        p *= num
    return s, p",useful
"This function uses the built-in sum for the total and math.prod for the product, handling empty lists by returning (0, 1).","def sum_product(numbers):
    return sum(numbers), math.prod(numbers) if numbers else (0, 1)",not useful
"This function computes the sum with the built-in function and the product using reduce with a multiplication lambda, starting from 1.","def sum_product(numbers):
    return (sum(numbers), reduce(lambda x, y: x*y, numbers, 1))",useful
"This function calculates the sum natively and the product using functools.reduce with operator.mul, initializing with 1.","def sum_product(numbers):
    return (sum(numbers), functools.reduce(operator.mul, numbers, 1))",useful
This function iterates to accumulate sum and product but adjusts the sum by subtracting 1 for non-empty lists and handles empty cases.,"def sum_product(numbers):
    s = p = 1
    for num in numbers:
        s += num
        p *= num
    return (s - 1 if numbers else 0, p if numbers else 1)",useful
"This function uses sum for the total and numpy.prod for the product, defaulting to 1 for empty lists.","def sum_product(numbers):
    return (sum(numbers), numpy.prod(numbers) if numbers else 1)",useful
"This function computes the sum first, then iterates separately to multiply numbers for the product, returning both.","def sum_product(numbers):
    s = sum(numbers)
    p = 1
    for num in numbers:
        p *= num
    return (s, p)",useful
"This function uses sum and a conditional functools.reduce with lambda for product, defaulting to 1 if the list is empty.","def sum_product(numbers):
    return (sum(numbers), functools.reduce(lambda x, y: x*y, numbers, 1) if numbers else 1)",useful
"This function initializes sum to 0 and product to 0, then iterates to accumulate, handling product initialization specially for the first number.","def sum_product(numbers):
    s = p = 0
    for num in numbers:
        s += num
        p = p*num if p else num
    return (s, p if numbers else 1)",useful
"This function computes the sum using the built-in function and the product with math.prod, defaulting to 1 for empty lists.","def sum_product(numbers):
    s = sum(numbers)
    p = math.prod(numbers) if numbers else 1
    return (s, p)",useful
"This function maintains a running maximum initialized to negative infinity, updating and appending it for each number in the list.","def rolling_max(numbers):
    max_so_far = float('-inf')
    result = []
    for num in numbers:
        max_so_far = max(max_so_far, num)
        result.append(max_so_far)
    return result",useful
This function uses a list comprehension to compute the max of each prefix slice from the start up to the current index.,"def rolling_max(numbers):
    return [max(numbers[:i+1]) for i in range(len(numbers))]",useful
This function employs itertools.accumulate with the max function to efficiently compute the running maximum over the list.,"import itertools
def rolling_max(numbers):
    return list(itertools.accumulate(numbers, max))",useful
This function uses NumPy's maximum.accumulate to compute the running max array and converts it back to a list.,"import numpy as np
def rolling_max(numbers):
    return np.maximum.accumulate(numbers).tolist()",useful
This function uses a walrus operator in a list comprehension to update and collect the running maximum starting from negative infinity.,"def rolling_max(numbers):
    max_so_far = float('-inf')
    return [max_so_far := max(max_so_far, num) for num in numbers]",useful
"This function preallocates a result list, iterates with enumerate to update the running max, and assigns it to the corresponding index.","def rolling_max(numbers):
    max_so_far = float('-inf')
    result = [0] * len(numbers)
    for i, num in enumerate(numbers):
        max_so_far = max(max_so_far, num)
        result[i] = max_so_far
    return result",useful
"This function tracks the running maximum in a loop over indices, appending the current max after each update.","def rolling_max(numbers):
    max_so_far = float('-inf')
    result = []
    for i in range(len(numbers)):
        max_so_far = max(max_so_far, numbers[i])
        result.append(max_so_far)
    return result",useful
This function uses a list comprehension with the walrus operator to compute and collect the running maximum for each number.,"def rolling_max(numbers):
    max_so_far = float('-inf')
    result = [max_so_far := max(max_so_far, num) for num in numbers]
    return result",useful
"This function initially computes max with current in a list, then iterates from the second element to ensure each is the max of previous and current.","def rolling_max(numbers):
    max_so_far = float('-inf')
    result = [max(max_so_far, num) for num in numbers]
    for i in range(1, len(numbers)):
        result[i] = max(result[i-1], result[i])
    return result",useful
"This function preallocates a result list, updates the running max only if the current number is larger, and assigns it in each iteration.","def rolling_max(numbers):
    max_so_far = float('-inf')
    result = [0] * len(numbers)
    for i in range(len(numbers)):
        if numbers[i] > max_so_far:
            max_so_far = numbers[i]
        result[i] = max_so_far
    return result",useful
"This function iterates from the end of the string, incrementing a counter i when the current start character matches the end character, then appends a reversed slice of the string based on i to attempt forming a palindrome, though the slicing logic is flawed and may produce incorrect results.","def make_palindrome(s):
    i = 0
    for j in range(len(s)-1, -1, -1):
        if s[i] == s[j]:
            i += 1
    return s + s[:i-len(s)-1:-1]",not useful
"The code compares characters from the start and end, incrementing i on matches to find a prefix length, then appends the reverse of the suffix starting from i to the original string in an effort to create a palindrome, but the matching logic skips mismatches incorrectly.","def make_palindrome(s):
    i = 0
    for j in reversed(range(len(s))):
        if s[i] == s[j]:
            i += 1
    return s + s[i:][::-1]",not useful
"It counts matching pairs from outside in by incrementing i when characters match, then appends a modified reverse of the suffix from i, replacing the character at i and reversing, which attempts to build a palindrome but introduces errors through the replace operation.","def make_palindrome(s):
    i = 0
    for j in range(len(s)-1, -1, -1):
        if s[i] == s[j]:
            i += 1
    return s + s[i:].replace(s[i], '')[::-1]",not useful
"The function increments i for matching start-end characters while traversing backwards, then appends the reverse of the suffix from i after replacing the first occurrence of s[i], aiming to construct a palindrome but likely failing due to imprecise slicing and replacement.","def make_palindrome(s):
    i = 0
    for j in range(len(s)-1, -1, -1):
        if s[i] == s[j]:
            i += 1
    return s + s[i:][::-1].replace(s[i], '', 1)",not useful
"This code finds a match count i by comparing forward and backward characters, then returns the string concatenated with a reverse slice from i-1 to the start, intending to form a palindrome but producing incorrect output because of the flawed backward traversal logic.","def make_palindrome(s):
    i = 0
    for j in range(len(s)-1, -1, -1):
        if s[i] == s[j]:
            i += 1
    return s + s[i-1::-1]",not useful
"It increments i on character matches from start and end, then appends a reversed slice from the end up to i-1 positions back, attempting to complete a palindrome, though the overall approach mishandles non-palindromic sections.","def make_palindrome(s):
    i = 0
    for j in range(len(s)-1, -1, -1):
        if s[i] == s[j]:
            i += 1
    return s + s[:i-1:-1]",not useful
"The loop counts matches between s[i] and s[j] decreasing j from the end, then appends the reverse of the slice from i-1 to the end, which tries to mirror the unmatched part but the i calculation is inaccurate for palindromes.","def make_palindrome(s):
    i = 0
    for j in range(len(s)-1, -1, -1):
        if s[i] == s[j]:
            i += 1
    return s + s[i-1:][::-1]",not useful
"This function tallies matching characters from both ends, then appends a reversed version of the suffix from i after replacing the first s[i] character, aiming for a palindrome but complicated by unnecessary string replacement.","def make_palindrome(s):
    i = 0
    for j in range(len(s)-1, -1, -1):
        if s[i] == s[j]:
            i += 1
    return s + s[i:].replace(s[i], '', 1)[::-1]",not useful
"It determines i by matching start and end characters in reverse order, then appends the reverse of the slice from i-1 after replacing the first occurrence of s[i-1], seeking to form a palindrome with erroneous modification steps.","def make_palindrome(s):
    i = 0
    for j in range(len(s)-1, -1, -1):
        if s[i] == s[j]:
            i += 1
    return s + s[i-1:][::-1].replace(s[i-1], '', 1)",not useful
"The code increments i for end-to-start matches, then appends the reverse of the slice from i-1 stripped of leading s[i-1] characters, attempting to build a palindrome but the stripping may remove too much or too little.","def make_palindrome(s):
    i = 0
    for j in range(len(s)-1, -1, -1):
        if s[i] == s[j]:
            i += 1
    return s + s[i-1:][::-1].lstrip(s[i-1])",not useful
"This function performs a bitwise XOR on corresponding integer values of characters from two strings assumed to be '0' and '1', joining the results as a string to compute the XOR of binary strings.","def string_xor(a: str, b: str) -> str:
    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))",useful
"It computes the XOR of ASCII values of paired characters from the input strings using ord and chr, returning the resulting string, which works for general strings but is intended for binary digit XOR.","def string_xor(a: str, b: str) -> str:
    return ''.join(chr(ord(x) ^ ord(y)) for x, y in zip(a, b))",not useful
"The code treats characters as integers (0 or 1) and uses inequality to simulate XOR (true if different), converting to string '1' or '0', effectively XORing binary strings.","def string_xor(a: str, b: str) -> str:
    return ''.join(str(int(x) != int(y)) for x, y in zip(a, b))",not useful
"Using a lambda with map, it zips the strings and applies bitwise XOR to their integer values, joining the string results to produce the XOR of binary input strings.","def string_xor(a: str, b: str) -> str:
    return ''.join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))",useful
"This implements XOR logically as (int(x) + int(y) - 2 * int(x) * int(y)), which equals 1 only if one is 1 and the other 0, for binary strings, joining the results.","def string_xor(a: str, b: str) -> str:
    return ''.join(str(int(x) + int(y) - 2 * int(x) * int(y)) for x, y in zip(a, b))",useful
"It converts characters to booleans then XORs them, which for '0'/'1' acts like logical XOR, converting back to string 'True'/'False' instead of '1'/'0', so incorrect for binary output.","def string_xor(a: str, b: str) -> str:
    return ''.join(str(bool(int(x)) ^ bool(int(y))) for x, y in zip(a, b))",not useful
"The function checks if paired characters differ, outputting '1' if unequal and '0' if equal, which correctly simulates XOR for binary digit strings by direct comparison.","def string_xor(a: str, b: str) -> str:
    return ''.join(str(1) if x != y else str(0) for x, y in zip(a, b))",useful
"It uses integer conversion and inequality (!=) to determine XOR results (1 if different, 0 if same), joining them into a string for binary string XOR operation.","def string_xor(a: str, b: str) -> str:
    return ''.join(str(int(x) != int(y)) for x, y in zip(a, b))",not useful
"This performs element-wise bitwise XOR on integers from the string characters, assuming '0' and '1', and joins the string representations to output the XOR result.","def string_xor(a: str, b: str) -> str:
    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))",useful
"The code simulates XOR by checking if int(x) != int(y) and converting to '1' or '0' implicitly via str(True/False), but actually outputs 'True'/'False', making it incorrect for binary strings.","def string_xor(a: str, b: str) -> str:
    return ''.join(str(int(x) != int(y)) for x, y in zip(a, b))",not useful
This function uses the built-in max with key=len and default=None to return the longest string in the list or None if the list is empty.,"def longest(strings: List[str]) -> Optional[str]:
    return max(strings, key=len, default=None)",useful
"It sorts the list by length in descending order and returns the first element if the list is non-empty, otherwise None, effectively finding the longest string.","def longest(strings: List[str]) -> Optional[str]:
    return sorted(strings, key=len, reverse=True)[0] if strings else None",useful
The code sorts the strings by length descending and uses next with a generator to return the first (longest) or None if empty.,"def longest(strings: List[str]) -> Optional[str]:
    return next((s for s in sorted(strings, key=len, reverse=True)), None)",useful
This attempts to handle empty and single-element cases explicitly but has a syntax error in the conditional; it aims to return the max by length or None for empty lists.,"def longest(strings: List[str]) -> Optional[str]:
    return strings[0] if strings else None if len(strings) == 1 else max(strings, key=len)",not useful
"Using max with a key that first considers length then lexicographical order, it returns the longest string (or one of if ties) or None for empty list.","def longest(strings: List[str]) -> Optional[str]:
    return max(strings, key=lambda s: (len(s), s), default=None)",useful
"It applies functools.reduce to iteratively select the longer string between accumulators, starting with None, to find the maximum length string.","def longest(strings: List[str]) -> Optional[str]:
    return reduce((lambda x, y: y if len(y) > len(x) else x), strings, None)",not useful
"This uses heapq.nlargest to get the top 1 string by length, returning it or None if the list is empty, efficiently finding the longest.","def longest(strings: List[str]) -> Optional[str]:
    return heapq.nlargest(1, strings, key=len)[0] if strings else None",useful
"By minimizing (-len(s), s), it finds the string with maximum length (since negative), breaking ties lexicographically, or None for empty.","def longest(strings: List[str]) -> Optional[str]:
    return min(strings, key=lambda s: (-len(s), s)) if strings else None",useful
"functools.reduce is used with a lambda to compare lengths and keep the longer string, initializing with None to handle empty lists.","def longest(strings: List[str]) -> Optional[str]:
    return functools.reduce(lambda a, b: a if len(a) >= len(b) else b, strings, None)",not useful
"It sorts by length descending and uses next(iter(...)) to get the first element or None, providing the longest string.","def longest(strings: List[str]) -> Optional[str]:
    return next(iter(sorted(strings, key=len, reverse=True)), None)",useful
"This implements the Euclidean algorithm iteratively, repeatedly replacing a with b and b with a % b until b is 0, returning a as the GCD.","def greatest_common_divisor(a: int, b: int) -> int:
    while b:
        a, b = b, a % b
    return a",useful
The function directly uses Python's math.gcd built-in function to compute the greatest common divisor of a and b.,"import math
def greatest_common_divisor(a: int, b: int) -> int:
    return math.gcd(a, b)",useful
"It recursively applies the Euclidean algorithm: if b is 0 return a, else recurse with (b, a % b) until base case.","def greatest_common_divisor(a: int, b: int) -> int:
    if b == 0:
        return a
    else:
        return greatest_common_divisor(b, a % b)",useful
"A concise recursive version of the Euclidean algorithm that returns a if b==0, otherwise recurses on (b, a % b).","def greatest_common_divisor(a: int, b: int) -> int:
    return a if b == 0 else greatest_common_divisor(b, a % b)",useful
"Using functools.reduce with math.gcd on the tuple (a, b), it computes the GCD for two numbers via reduction.","from functools import reduce
import math
def greatest_common_divisor(a: int, b: int) -> int:
    return reduce(math.gcd, (a, b))",useful
"This recursive Euclidean implementation takes abs(a) if b==0, else recurses on (b, a % b), handling negative a but assuming non-negative inputs.","def greatest_common_divisor(a: int, b: int) -> int:
    return abs(a) if b == 0 else greatest_common_divisor(b, a % b)",useful
"It recursively computes GCD by subtracting multiples: if b==0 return a, else recurse on (b, a - b*(a//b)), equivalent to modulo but less efficient.","def greatest_common_divisor(a: int, b: int) -> int:
    return a if b == 0 else greatest_common_divisor(b, a - b * (a // b))",useful
"This subtractive version of Euclidean algorithm repeatedly subtracts the smaller from the larger until they are equal, returning that value as GCD.","def greatest_common_divisor(a: int, b: int) -> int:
    while a != b:
        if a > b:
            a -= b
        else:
            b -= a
    return a",useful
"It iteratively applies modulo operations in a loop until one is 0, then returns the sum of remaining a and b, but since one is 0, it's effectively the non-zero one; however, the loop condition allows both to be non-zero incorrectly.","def greatest_common_divisor(a: int, b: int) -> int:
    while a != 0 and b != 0:
        if a > b:
            a %= b
        else:
            b %= a
    return a + b",not useful
"An iterative Euclidean algorithm variant that swaps and mods until a is 0, then returns b as the GCD.","def greatest_common_divisor(a: int, b: int) -> int:
    while a != 0:
        a, b = b % a, a
    return b",useful
"This generates all prefixes by slicing the string from the start up to each index i+1 for i from 0 to len-1, producing ['s[0]','s[0:2]','s[0:3]',...,s].","def all_prefixes(string: str) -> List[str]:
    return [string[:i+1] for i in range(len(string))]",useful
"It creates prefixes using slices from index 0 to i for i from 1 to len(s), resulting in all non-empty prefixes of the string.","def all_prefixes(string: str) -> List[str]:
    return [string[0:i] for i in range(1, len(string) + 1)]",useful
"The list comprehension slices from start to i for i from 1 to len(s)+1, but since slice [:i] for i=len+1 is the whole string, it includes all prefixes including the full string.","def all_prefixes(string: str) -> List[str]:
    return [string[:i] for i in range(1, len(string) + 1)]",not useful
"This attempts prefixes with [0:i] for i in range(len(s)), but range(len(s)) is 0 to len-1, so [0:0] is empty, producing empty plus all proper prefixes, missing the full string.","def all_prefixes(string: str) -> List[str]:
    return [string[0:i] for i in range(len(string))]",not useful
"It slices [:i+1] for i in range(len(s)) with an unnecessary if i < len(s), generating all non-empty prefixes correctly.","def all_prefixes(string: str) -> List[str]:
    return [string[:i+1] for i in range(len(string)) if i < len(string)]",useful
"The code uses [:i] for i=1 to len+1 with if i <= len(s), which is always true, so it produces all non-empty prefixes including the full string.","def all_prefixes(string: str) -> List[str]:
    return [string[:i] for i in range(1, len(string) + 1) if i <= len(string)]",useful
"Similar to others, it slices [0:i] for i=1 to len+1 with redundant if i <= len(s), yielding all non-empty prefixes.","def all_prefixes(string: str) -> List[str]:
    return [string[0:i] for i in range(1, len(string) + 1) if i <= len(string)]",useful
"This generates [:i] for i in range(len(s)) with if i < len(s), but range is 0 to len-1, so skips empty and produces proper prefixes up to len-1, missing full string.","def all_prefixes(string: str) -> List[str]:
    return [string[:i] for i in range(len(string)) if i < len(string)]",not useful
"It uses [0:i] for i in range(len(s)) with if i < len(s), starting from i=0 empty slice, but condition skips i=0? Wait, range(0,len) i=0 to len-1, if i<len always true, includes empty prefix.","def all_prefixes(string: str) -> List[str]:
    return [string[0:i] for i in range(len(string)) if i < len(string)]",not useful
"The list comprehension slices [:i] for i=1 to len+1 excluding if i == len+1 (which doesn't occur), effectively producing all non-empty prefixes.","def all_prefixes(string: str) -> List[str]:
    return [string[:i] for i in range(1, len(string) + 1) if i != len(string) + 1]",useful
This function creates a space-separated string of integers from 0 to n by mapping the range to strings and joining them.,"def string_sequence(n: int) -> str:
    return ' '.join(map(str, range(n + 1)))",useful
This function generates a space-separated string of numbers from 0 to n using a generator expression to convert integers to strings before joining.,"def string_sequence(n: int) -> str:
    return ' '.join(str(i) for i in range(n + 1))",useful
This function produces a space-separated string of integers from 0 to n using xrange (Python 2) in a generator expression for string conversion and joining.,"def string_sequence(n: int) -> str:
    return ' '.join(str(i) for i in xrange(n + 1))",not useful
This function builds a space-separated string from 0 to n by chaining range(n) with [n] via itertools and converting to strings in a generator before joining.,"def string_sequence(n: int) -> str:
    return ' '.join(str(i) for i in itertools.chain(range(n), [n]))",useful
"This function generates a space-separated string of numbers from 0 to n using NumPy's arange to create the sequence, converted to strings via generator.","def string_sequence(n: int) -> str:
    return ' '.join(str(i) for i in numpy.arange(n + 1))",useful
"This function creates a space-separated string from 0 to n by converting the range to a Pandas Series, then using a generator to stringify and join elements.","def string_sequence(n: int) -> str:
    return ' '.join(str(i) for i in pandas.Series(range(n + 1)))",useful
This function produces a space-separated string of integers from 0 to n by creating a Polars Series from the range and converting its elements to strings via generator.,"def string_sequence(n: int) -> str:
    return ' '.join(str(i) for i in polars.Series(range(n + 1)))",useful
"This function generates a space-separated string from 0 to n using PySpark's sequence function to create the list, then stringifying via generator and joining.","def string_sequence(n: int) -> str:
    return ' '.join(str(i) for i in pyspark.sql.functions.sequence(0, n))",not useful
"This function creates a space-separated string of numbers from 0 to n using Dask's arange for the array, converted to strings in a generator before joining.","def string_sequence(n: int) -> str:
    return ' '.join(str(i) for i in dask.array.arange(n + 1))",not useful
This function builds a space-separated string from 0 to n by creating a Vaex array from the range and using a generator to convert elements to strings for joining.,"def string_sequence(n: int) -> str:
    return ' '.join(str(i) for i in vaex.array(range(n + 1)))",not useful
"This function counts distinct characters in the string by converting to lowercase, creating a set to remove duplicates, and returning its length.","def count_distinct_characters(string: str) -> int:
    return len(set(string.lower()))",useful
"This function determines the number of unique characters by lowercasing the string and using a set comprehension to get distinct characters, then returning the set's length.","def count_distinct_characters(string: str) -> int:
    return len({c.lower() for c in string})",useful
This function counts unique lowercase characters using a Counter to tally frequencies and returning the number of keys with non-zero counts.,"from collections import Counter
def count_distinct_characters(string: str) -> int:
    return len(Counter(string.lower()))",useful
This function calculates distinct characters by summing 1 for each unique lowercase character in a set using a generator expression.,"def count_distinct_characters(string: str) -> int:
    return sum(1 for c in set(string.lower()))",useful
This function counts unique characters by applying a lambda to sum 1 for each element in the set of lowercase characters using map.,"def count_distinct_characters(string: str) -> int:
    return sum(map(lambda c: 1, set(string.lower())))",useful
"This function uses a fixed-size array of 128 booleans for ASCII characters, sets flags for each lowercase character encountered, and sums the array to count uniques.","def count_distinct_characters(string: str) -> int:
    chars = [0] * 128
    for c in string.lower():
        chars[ord(c)] = 1
    return sum(chars)",useful
"This function tracks unique lowercase characters with a 128-element boolean array indexed by ordinals, then sums the True values to get the count.","def count_distinct_characters(string: str) -> int:
    chars = [False] * 128
    for c in string.lower():
        chars[ord(c)] = True
    return sum(chars)",useful
"This function attempts to count distinct characters by manipulating the lowercase string with replaces, but it incorrectly computes length minus empty replacements.","def count_distinct_characters(string: str) -> int:
    return len(string.lower()) - len(string.lower().replace('', '').replace(' ', ''))",not useful
"This function counts unique lowercase characters by creating a set, sorting and joining them into a string, then returning its length.","def count_distinct_characters(string: str) -> int:
    return len(''.join(sorted(set(string.lower()))))",useful
"This function gets the count of distinct lowercase characters by joining them using dict.fromkeys to preserve order and uniqueness, then returning the length.","def count_distinct_characters(string: str) -> int:
    return len(''.join(dict.fromkeys(string.lower())))",useful
"This function parses music notes from a space-separated string, mapping 'o' to 4, 'o|' to 2, and others to 1 using a list comprehension.","def parse_music(music_string: str) -> List[int]:
    return [4 if note == 'o' else 2 if note == 'o|' else 1 for note in music_string.split()]",useful
"This function splits the music string into notes and uses a dictionary to map 'o' to 4, 'o|' to 2, and '.|' to 1 in a list comprehension.","def parse_music(music_string: str) -> List[int]:
    notes = music_string.split()
    return [{'o': 4, 'o|': 2, '.|': 1}[note] for note in notes]",useful
"This function splits the music string and iterates over notes, appending 4 for 'o', 2 for 'o|', and 1 otherwise to build the beats list.","def parse_music(music_string: str) -> List[int]:
    notes = music_string.split()
    beats = []
    for note in notes:
        if note == 'o':
            beats.append(4)
        elif note == 'o|':
            beats.append(2)
        else:
            beats.append(1)
    return beats",useful
"This function uses a dictionary to map music notes 'o' to 4, 'o|' to 2, and '.|' to 1, then creates a list comprehension from split notes.","def parse_music(music_string: str) -> List[int]:
    notes = music_string.split()
    beats = {
        'o': 4,
        'o|': 2,
        '.|': 1
    }
    return [beats[note] for note in notes]",useful
"This function splits the music string and uses map with a lambda to assign 4 for 'o', 2 for 'o|', and 1 otherwise, converting to list.","def parse_music(music_string: str) -> List[int]:
    notes = music_string.split()
    return list(map(lambda note: 4 if note == 'o' else 2 if note == 'o|' else 1, notes))",useful
"This function splits notes and extends the beats list with values from a list [4,2,1] indexed by the position of each note in ['o','o|','.|'].","def parse_music(music_string: str) -> List[int]:
    notes = music_string.split()
    beats = []
    for note in notes:
        beats.extend([4, 2, 1][['o', 'o|', '.|'].index(note)])
    return beats",not useful
"This function uses a dictionary mapping notes to lists of beats, then flattens the result using nested list comprehension from split notes.","def parse_music(music_string: str) -> List[int]:
    notes = music_string.split()
    beats = {
        'o': [4],
        'o|': [2],
        '.|': [1]
    }
    return [beat for note in notes for beat in beats[note]]",useful
"This function splits the music string and appends single-element lists [4], [2], or [1] to beats based on matching 'o', 'o|', or else for each note.","def parse_music(music_string: str) -> List[int]:
    notes = music_string.split()
    beats = []
    for note in notes:
        beats += [4] if note == 'o' else [2] if note == 'o|' else [1]
    return beats",useful
"This function splits notes and extends beats with values from [4,2,1] using the index of each note in ['o','o|','.|'] during iteration.","def parse_music(music_string: str) -> List[int]:
    notes = music_string.split()
    beats = []
    for note in notes:
        beats.extend([4, 2, 1][['o', 'o|', '.|'].index(note)])
    return beats",not useful
"This function splits the music string and uses a dictionary to map notes to beats, defaulting to 0 for unmatched notes in a list comprehension.","def parse_music(music_string: str) -> List[int]:
    notes = music_string.split()
    beats = {
        'o': 4,
        'o|': 2,
        '.|': 1
    }
    return [beats.get(note, 0) for note in notes]",useful
This function counts overlapping occurrences of the substring by summing boolean results from checking if each suffix of the string starts with the substring.,"def how_many_times(string: str, substring: str) -> int:
    return sum(string[i:].startswith(substring) for i in range(len(string)))",useful
"This function iterates over string indices, counting how many times a suffix starting at each index begins with the substring to handle overlaps.","def how_many_times(string: str, substring: str) -> int:
    return sum(1 for i in range(len(string)) if string[i:].startswith(substring))",useful
"This function creates a list of indices where the string suffix starts with the substring using a list comprehension, then returns its length for overlapping counts.","def how_many_times(string: str, substring: str) -> int:
    return len([i for i in range(len(string)) if string[i:].startswith(substring)])",useful
"This function uses a loop with str.find starting from the current position, incrementing count and advancing by 1 (for overlap) until no more found.","def how_many_times(string: str, substring: str) -> int:
    count = start = 0
    while start < len(string):
        pos = string.find(substring, start)
        if pos != -1:
            start = pos + 1
            count += 1
        else:
            break
    return count",useful
"This function repeatedly finds the substring starting from the current position +1, incrementing count until find returns -1, enabling overlap detection.","def how_many_times(string: str, substring: str) -> int:
    count = start = 0
    while True:
        start = string.find(substring, start) + 1
        if start > 0:
            count += 1
        else:
            return count",useful
"This function loops using str.find from the current start, increments start by 1 after each find to count overlapping occurrences until -1 is returned.","def how_many_times(string: str, substring: str) -> int:
    count = start = 0
    while start != -1:
        start = string.find(substring, start)
        if start != -1:
            start += 1
            count += 1
    return count",useful
"This function attempts to count occurrences by adding the standard count of the full string to the count of the substring in the tail after the first length, but misses overlaps.","def how_many_times(string: str, substring: str) -> int:
    return string.count(substring) + string[len(substring):].count(substring)",not useful
"This function calculates occurrences by measuring the length difference after replacing the substring with empty string, dividing by substring length, but doesn't handle overlaps.","def how_many_times(string: str, substring: str) -> int:
    return (len(string) - len(string.replace(substring, ''))) // len(substring)",not useful
"This function uses regex findall with a positive lookahead (?={substring}) to find all starting positions of the substring, counting overlaps, and returns the match count.","import re
def how_many_times(string: str, substring: str) -> int:
    return len(re.findall(f'(?={substring})', string))",useful
"This function employs re.finditer with positive lookahead to locate all substring starts, collects their positions in a list comprehension, and returns the length for overlapping counts.","def how_many_times(string: str, substring: str) -> int:
    return len([m.start() for m in re.finditer(f'(?={substring})', string)])",useful
"This function sorts the split number words by their numerical value using a dictionary mapping words to integers as the sort key, then joins them back with spaces.","def sort_numbers(numbers: str) -> str:
    num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}
    return ' '.join(sorted(numbers.split(), key=lambda x: num_dict[x]))",not useful
"This function splits the string into words, sorts the list using the index of each word in the number words list as key, and joins the sorted words with spaces.","def sort_numbers(numbers: str) -> str:
    num_list = numbers.split()
    num_list.sort(key=['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'].index)
    return ' '.join(num_list)",not useful
"This function creates a dictionary mapping number words to their indices, splits the input, sorts using the dictionary values as keys, and joins the result with spaces.","def sort_numbers(numbers: str) -> str:
    num_dict = {v: k for k, v in enumerate(['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'])}
    return ' '.join(sorted(numbers.split(), key=num_dict.get))",not useful
"This function splits the numbers string, sorts the list by finding each word's index in the predefined number words list using a lambda, and joins with spaces.","def sort_numbers(numbers: str) -> str:
    num_list = numbers.split()
    num_list.sort(key=lambda x: ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'].index(x))
    return ' '.join(num_list)",not useful
"This function uses zip to create a dictionary mapping number words to 0-9, splits the input, sorts by dictionary values, and joins the sorted words with spaces.","def sort_numbers(numbers: str) -> str:
    num_dict = dict(zip(['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'], range(10)))
    return ' '.join(sorted(numbers.split(), key=num_dict.get))",not useful
"This function splits the input into a list, sorts it by the index of each word in the number words array via lambda, and returns the space-joined result.","def sort_numbers(numbers: str) -> str:
    num_list = numbers.split()
    num_list.sort(key=lambda x: ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'].index(x))
    return ' '.join(num_list)",not useful
"This function builds a dictionary with indices as keys and words as values using enumerate, but sorts using get which may not work as intended; joins sorted split words.","def sort_numbers(numbers: str) -> str:
    num_dict = {k: v for v, k in enumerate(['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'])}
    return ' '.join(sorted(numbers.split(), key=num_dict.get))",not useful
"This function splits the string, sorts the list by lambda lookup of each word's index in the number words list, and joins the sorted elements with spaces.","def sort_numbers(numbers: str) -> str:
    num_list = numbers.split()
    num_list.sort(key=lambda x: ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'].index(x))
    return ' '.join(num_list)",not useful
"This function creates a dictionary with indices as keys and words as values using enumerate, then sorts split words by finding the key for each word's value index, and joins.","def sort_numbers(numbers: str) -> str:
    num_dict = dict(enumerate(['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']))
    return ' '.join(sorted(numbers.split(), key=lambda x: list(num_dict.keys())[list(num_dict.values()).index(x)]))",not useful
"This function uses enumerate to map words to indices in a dictionary, splits the input, sorts by the dictionary values for each word using lambda, and joins with spaces.","def sort_numbers(numbers: str) -> str:
    num_dict = {k: v for v, k in enumerate(['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'])}
    return ' '.join(sorted(numbers.split(), key=lambda x: num_dict[x]))",not useful
This function sorts the input list in place and returns the pair of consecutive elements with the smallest positive difference using a generator expression and min with a key function.,"def find_closest_elements(numbers):
    numbers.sort()
    return min((numbers[i], numbers[i + 1]) for i in range(len(numbers) - 1), key=lambda x: x[1] - x[0])",useful
"This function creates a sorted copy of the input list and uses zip to pair consecutive elements, then finds the pair with the smallest positive difference via min and a lambda key.","def find_closest_elements(numbers):
    numbers = sorted(numbers)
    return min(zip(numbers, numbers[1:]), key=lambda x: x[1] - x[0])",useful
"This function sorts the input list in place and uses zip to pair consecutive elements, returning the pair with the smallest positive difference using min and a lambda key.","def find_closest_elements(numbers):
    numbers.sort()
    return min(zip(numbers, numbers[1:]), key=lambda x: x[1] - x[0])",useful
This function sorts the input list in place and returns the pair of consecutive elements with the smallest absolute difference using a generator and min with an abs-based key.,"def find_closest_elements(numbers):
    numbers.sort()
    return min((numbers[i], numbers[i + 1]) for i in range(len(numbers) - 1), key=lambda x: abs(x[1] - x[0]))",useful
"This function creates a sorted copy of the input list and uses zip to pair consecutive elements, finding the pair with the smallest absolute difference via min and a lambda key.","def find_closest_elements(numbers):
    numbers = sorted(numbers)
    return min(zip(numbers, numbers[1:]), key=lambda x: abs(x[1] - x[0]))",useful
This function sorts the input list in place and returns the pair of consecutive elements with the smallest positive difference using a generator expression and min with a key function.,"def find_closest_elements(numbers):
    numbers.sort()
    return min((numbers[i], numbers[i + 1]) for i in range(len(numbers) - 1), key=lambda x: x[1] - x[0])",useful
"This function creates a sorted copy of the input list and uses zip to pair consecutive elements, then finds the pair with the smallest positive difference via min and a lambda key.","def find_closest_elements(numbers):
    numbers = sorted(numbers)
    return min(zip(numbers, numbers[1:]), key=lambda x: x[1] - x[0])",useful
This function sorts the input list in place and returns the pair of consecutive elements with the smallest absolute difference using a generator and min with an abs-based key.,"def find_closest_elements(numbers):
    numbers.sort()
    return min((numbers[i], numbers[i + 1]) for i in range(len(numbers) - 1), key=lambda x: abs(x[1] - x[0]))",useful
"This function creates a sorted copy of the input list and uses zip to pair consecutive elements, finding the pair with the smallest absolute difference via min and a lambda key.","def find_closest_elements(numbers):
    numbers = sorted(numbers)
    return min(zip(numbers, numbers[1:]), key=lambda x: abs(x[1] - x[0]))",useful
This function sorts the input list in place and returns the pair of consecutive elements with the smallest absolute difference using a generator and min with an abs-based key.,"def find_closest_elements(numbers):
    numbers.sort()
    return min((numbers[i], numbers[i + 1]) for i in range(len(numbers) - 1), key=lambda x: abs(x[1] - x[0]))",useful
"This function finds the min and max of the list and rescales each number to the range [0,1] by subtracting min and dividing by the range using a list comprehension.","def rescale_to_unit(numbers):
    min_num = min(numbers)
    max_num = max(numbers)
    return [(num - min_num) / (max_num - min_num) for num in numbers]",not useful
"This function manually computes min and max by iterating through the list and then rescales each number to [0,1] using a list comprehension, assuming non-empty input.","def rescale_to_unit(numbers):
    min_num = float('inf')
    max_num = float('-inf')
    for num in numbers:
        if num < min_num:
            min_num = num
        if num > max_num:
            max_num = num
    return [(num - min_num) / (max_num - min_num) for num in numbers]",not useful
"This function initializes min and max with the first element and iterates to find the actual min and max, then rescales to [0,1] via list comprehension.","def rescale_to_unit(numbers):
    min_num = numbers[0]
    max_num = numbers[0]
    for num in numbers:
        if num < min_num:
            min_num = num
        elif num > max_num:
            max_num = num
    return [(num - min_num) / (max_num - min_num) for num in numbers]",not useful
"This function computes min and range (max - min), then rescales each number to [0,1] by subtracting min and dividing by range using a list comprehension.","def rescale_to_unit(numbers):
    min_num = min(numbers)
    range_num = max(numbers) - min_num
    return [(num - min_num) / range_num for num in numbers]",not useful
"This function finds min and max, then uses map with a lambda to rescale each number to [0,1] and converts the result to a list.","def rescale_to_unit(numbers):
    min_num = min(numbers)
    max_num = max(numbers)
    return list(map(lambda num: (num - min_num) / (max_num - min_num), numbers))",not useful
"This function finds min and max, rescaling to [0,1] via list comprehension but returns 0 for all if min equals max to avoid division by zero.","def rescale_to_unit(numbers):
    min_num = min(numbers)
    max_num = max(numbers)
    return [(num - min_num) / (max_num - min_num) if max_num != min_num else 0 for num in numbers]",useful
"This function computes min, max, and range, rescaling to [0,1] but handling zero range by returning 0 for each element in a list comprehension.","def rescale_to_unit(numbers):
    min_num = min(numbers)
    max_num = max(numbers)
    range_num = max_num - min_num
    return [(num - min_num) / range_num if range_num != 0 else 0 for num in numbers]",useful
"This function computes min, max, and range, rescaling to [0,1] if range is non-zero, otherwise returning a list of zeros matching the input length.","def rescale_to_unit(numbers):
    min_num = min(numbers)
    max_num = max(numbers)
    range_num = max_num - min_num
    return [(num - min_num) / range_num for num in numbers] if range_num != 0 else [0] * len(numbers)",useful
"This function computes min, max, and range, rescaling to [0,1] in a list comprehension and treating zero range as falsy to return 0 for each.","def rescale_to_unit(numbers):
    min_num = min(numbers)
    max_num = max(numbers)
    range_num = max_num - min_num
    return [(num - min_num) / range_num if range_num else 0 for num in numbers]",useful
"This function computes min, max, and range, rescaling to [0,1] while handling zero range by returning 0, and explicitly returns empty list if input is empty.","def rescale_to_unit(numbers):
    min_num = min(numbers)
    max_num = max(numbers)
    range_num = max_num - min_num
    return [(num - min_num) / range_num if range_num else 0 for num in numbers] if numbers else []",not useful
This function uses a list comprehension to filter and return only the elements from the input list that are instances of int using isinstance.,"def filter_integers(values: List[Any]) -> List[int]:
    return [value for value in values if isinstance(value, int)]",useful
This function applies the filter function with a lambda checking isinstance for int to the input list and converts the result to a list.,"def filter_integers(values: List[Any]) -> List[int]:
    return list(filter(lambda x: isinstance(x, int), values))",useful
This function uses a list comprehension to filter elements where the exact type is int using the is operator.,"def filter_integers(values: List[Any]) -> List[int]:
    return [value for value in values if type(value) is int]",useful
"This function uses filter with a lambda checking exact type int via is, then converts the filter object to a list.","def filter_integers(values: List[Any]) -> List[int]:
    return list(filter(lambda x: type(x) is int, values))",useful
This function uses a list comprehension to filter elements where the type equals int using the == operator.,"def filter_integers(values: List[Any]) -> List[int]:
    return [value for value in values if type(value) == int]",useful
This function applies filter with a lambda checking type == int and converts the result to a list.,"def filter_integers(values: List[Any]) -> List[int]:
    return list(filter(lambda x: type(x) == int, values))",useful
This function uses a list comprehension with isinstance checking against a tuple containing int to filter integer elements.,"def filter_integers(values: List[Any]) -> List[int]:
    return [value for value in values if isinstance(value, (int,))]",useful
"This function uses filter with a lambda and isinstance against a single-element int tuple, then converts to list.","def filter_integers(values: List[Any]) -> List[int]:
    return list(filter(lambda x: isinstance(x, (int,)), values))",useful
This function uses a list comprehension to filter where the type is in a tuple containing int.,"def filter_integers(values: List[Any]) -> List[int]:
    return [value for value in values if type(value) in (int,)]",useful
"This function applies filter with a lambda checking if type is in a single-element int tuple, then converts to list.","def filter_integers(values: List[Any]) -> List[int]:
    return list(filter(lambda x: type(x) in (int,), values))",useful
This function simply returns the length of the input string using Python's built-in len function.,"def strlen(string: str) -> int:
    return len(string)",useful
"This function iterates over each character in the string, incrementing a counter, and returns the total count as the length.","def strlen(string: str) -> int:
    count = 0
    for _ in string:
        count += 1
    return count",useful
"This function uses a generator expression with sum to count the iterations over the string, effectively computing its length.","def strlen(string: str) -> int:
    return sum(1 for _ in string)",useful
"This function attempts to compute length using string.count('') minus one, which works for non-empty strings but fails for empty ones.","def strlen(string: str) -> int:
    return string.count('') - 1",not useful
"This function tries to find the index of null character or falls back to len if not found, mimicking C-style string length but unreliable for Python strings.","def strlen(string: str) -> int:
    try:
        return string.index('\0')
    except ValueError:
        return len(string)",not useful
"This function uses reduce to accumulate a count of 1 for each character in the string, starting from 0, to compute the length.","def strlen(string: str) -> int:
    return reduce(lambda x, _: x + 1, string, 0)",useful
"This function converts the string to a list and returns the length of that list, which equals the string's length.","def strlen(string: str) -> int:
    return len(list(string))",useful
"This function converts the string to a tuple and returns its length, equivalent to the string's length.","def strlen(string: str) -> int:
    return len(tuple(string))",useful
"This function converts the string to a set to get unique characters and returns the size of the set, which is the count of distinct characters, not the full length.","def strlen(string: str) -> int:
    return len(set(string))",not useful
"This function creates a dict from the string keys to preserve order and uniqueness, then returns the length of the dict, counting unique characters.","def strlen(string: str) -> int:
    return len(dict.fromkeys(string))",not useful
"This function iterates from n-1 down to 1, checking divisibility, and returns the first (largest) divisor found.","def largest_divisor(n: int) -> int:
    for i in range(n-1, 0, -1):
        if n % i == 0:
            return i",useful
"This function uses a generator to iterate from n-1 to 1, yielding divisors, and returns the first one using next.","def largest_divisor(n: int) -> int:
    return next(i for i in range(n-1, 0, -1) if n % i == 0)",useful
This function generates all proper divisors using a generator and returns the maximum among them.,"def largest_divisor(n: int) -> int:
    return max(i for i in range(1, n) if n % i == 0)",useful
"This function creates a list of divisors by iterating from n-1 to 1 and returns the first element of that list, the largest divisor.","def largest_divisor(n: int) -> int:
    return [i for i in range(n-1, 0, -1) if n % i == 0][0]",useful
This function uses filter to get divisors in descending order and returns the first element of the resulting list.,"def largest_divisor(n: int) -> int:
    return list(filter(lambda i: n % i == 0, range(n-1, 0, -1)))[0]",useful
"This function uses reduce to iterate from n-1 to 1, returning the first number that divides n evenly, otherwise continuing.","def largest_divisor(n: int) -> int:
    return reduce(lambda x, y: x if n % x == 0 else y, range(n-1, 0, -1))",not useful
This function uses functools.reduce with a lambda to find the first divisor from n-1 down to 1 by checking divisibility.,"def largest_divisor(n: int) -> int:
    return functools.reduce(lambda x, y: x if n % x == 0 else y, range(n-1, 0, -1))",useful
This function applies max to a filter object that yields divisors in descending order from n-1 to 1.,"def largest_divisor(n: int) -> int:
    return max(filter(lambda i: n % i == 0, range(n-1, 0, -1)))",useful
"This function generates divisors using a generator from n-1 down to 1 and returns the maximum, which is the first one.","def largest_divisor(n: int) -> int:
    return max(i for i in range(n-1, 0, -1) if n % i == 0)",useful
"This function uses max on a filter that yields divisors from n-1 down to 1, returning the largest one.","def largest_divisor(n: int) -> int:
    return max(filter(lambda i: n % i == 0, range(n-1, 0, -1)))",useful
"This function factorizes an integer n into its prime factors by trial division starting from 2 up to the square root of n, appending each factor found and dividing n by it until n is fully factored.","def factorize(n: int) -> List[int]:
    i, factors = 2, []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",useful
"This optimized factorization handles even factors (2) first in a loop, then checks odd divisors from 3 to sqrt(n) in steps of 2, appending each factor and dividing n until complete.","def factorize(n: int) -> List[int]:
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n //= 2
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:
        factors.append(n)
    return factors",useful
"The function performs trial division from 2 to sqrt(n) to find prime factors, repeatedly dividing n by each divisor found and appending it to the list, then adds n if it's a prime greater than 1.","def factorize(n: int) -> List[int]:
    factors = []
    for i in range(2, int(n**0.5) + 1):
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 1:
        factors.append(n)
    return factors",useful
"This code attempts to factorize n by incrementing i until it divides n, but the inner while loop for multiple factors is missing, so it only finds one factor per i and may not fully factorize.","def factorize(n: int) -> List[int]:
    i, factors = 2, []
    while i * i <= n:
        while n % i:
            i += 1
        n //= i
        factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",not useful
"It first removes all factors of 2, then trials odd numbers from 3 to sqrt(n) (without step 2, so includes evens unnecessarily), appending factors and dividing n accordingly.","def factorize(n: int) -> List[int]:
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n //= 2
    for i in range(3, int(n**0.5) + 1):
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:
        factors.append(n)
    return factors",useful
"Similar to basic trial division, it starts from i=2 and increments until i exceeds sqrt(n), appending factors when n is divisible by i and dividing n, then adds remaining n if prime.","def factorize(n: int) -> List[int]:
    i, factors = 2, []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",useful
"This efficient version separates handling of 2, then uses odd increments from 3 to sqrt(n) for trial division, repeatedly appending and dividing by each factor found.","def factorize(n: int) -> List[int]:
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n //= 2
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:
        factors.append(n)
    return factors",useful
"The function increments i until it finds a divisor, but lacks an inner loop to handle multiple instances of the same factor, potentially leaving n incompletely factored.","def factorize(n: int) -> List[int]:
    i, factors = 2, []
    while i * i <= n:
        while n % i:
            i += 1
        n //= i
        factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",not useful
"It handles factors of 2 first, then trials from 3 to sqrt(n) without skipping evens, appending each factor found multiple times if applicable by dividing n repeatedly.","def factorize(n: int) -> List[int]:
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n //= 2
    for i in range(3, int(n**0.5) + 1):
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:
        factors.append(n)
    return factors",useful
"This implements prime factorization via trial division from 2 to sqrt(n), dividing n by i when divisible and appending i, with an inner if for single divisions only.","def factorize(n: int) -> List[int]:
    i, factors = 2, []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",not useful
This function removes duplicates from the list while preserving the original order by converting to a dict (which maintains insertion order in Python 3.7+) and back to a list.,"def remove_duplicates(numbers):
    return list(dict.fromkeys(numbers))",useful
"It removes duplicates using a set for uniqueness but sorts the result based on the original list's index to attempt preserving order, though this may not work correctly for all cases.","def remove_duplicates(numbers):
    return sorted(set(numbers), key=numbers.index)",useful
"Using a set to track seen elements, this list comprehension adds each number only if not already seen, preserving order and removing duplicates.","def remove_duplicates(numbers):
    seen = set()
    return [x for x in numbers if not (x in seen or seen.add(x))]",useful
"This code filters the list to include only elements that appear exactly once (count == 1), effectively removing duplicates but excluding all repeated items entirely.","def remove_duplicates(numbers):
    return [num for num in numbers if numbers.count(num) == 1]",not useful
"It uses OrderedDict to remove duplicates while preserving the insertion order of first occurrences, then converts back to a list.","def remove_duplicates(numbers):
    from collections import OrderedDict
    return list(OrderedDict.fromkeys(numbers))",useful
"Similar to using dict for uniqueness, this removes duplicates preserving order by listing the keys of the dict created from the input list.","def remove_duplicates(numbers):
    return list(dict.fromkeys(numbers).keys())",useful
"By checking if the first index of each num matches its current position in enumeration, this keeps only the first occurrence of each duplicate, preserving order.","def remove_duplicates(numbers):
    return [num for i, num in enumerate(numbers) if numbers.index(num) == i]",useful
"This inefficiently counts occurrences for each element and keeps only those that appear exactly once, removing all duplicates but excluding repeated items.","def remove_duplicates(numbers):
    return [num for num in numbers if numbers.count(num) == 1]",not useful
"Using Counter to count frequencies, it returns only elements with count == 1, thus removing duplicates by excluding any item that appears more than once.","def remove_duplicates(numbers):
    from collections import Counter
    return [num for num, count in Counter(numbers).items() if count == 1]",not useful
"It iterates through the list and includes only numbers that appear exactly once based on full list count, removing all instances of duplicates.","def remove_duplicates(numbers):
    return [num for num in numbers if numbers.count(num) == 1]",not useful
This simple implementation uses Python's built-in string method swapcase() to flip the case of all alphabetic characters in the input string.,"def flip_case(string: str) -> str:
    return string.swapcase()",useful
"The function uses a generator expression to check each character: uppercase becomes lowercase, lowercase becomes uppercase, and non-letters remain unchanged.","def flip_case(string: str) -> str:
    return ''.join(c.lower() if c.isupper() else c.upper() for c in string)",useful
"It flips case by converting lowercase to uppercase and uppercase to lowercase for alphabetic characters using islower() and isupper(), joining the results.","def flip_case(string: str) -> str:
    return ''.join([c.upper() if c.islower() else c.lower() for c in string])",useful
"This bitwise XOR approach flips case by XORing the ASCII value of letters with 32 (toggling between upper and lower), leaving non-letters intact.","def flip_case(string: str) -> str:
    return ''.join(chr(ord(c) ^ 32) if 'a' <= c <= 'z' or 'A' <= c <= 'Z' else c for c in string)",useful
"Using str.maketrans() and translate(), it creates a mapping to swap all lowercase and uppercase letters, efficiently flipping the case of the entire string.","def flip_case(string: str) -> str:
    return string.translate(str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'))",useful
"A list comprehension checks each character's case: upper to lower, lower to upper, and non-alphabetic characters stay the same, then joins them.","def flip_case(string: str) -> str:
    return ''.join([c.lower() if c.isupper() else c.upper() if c.islower() else c for c in string])",useful
"Employing map with a lambda, it lowers uppercase characters and uppercases lowercase ones, assuming non-letters are handled by the methods' defaults.","def flip_case(string: str) -> str:
    return ''.join(map(lambda c: c.lower() if c.isupper() else c.upper(), string))",useful
"This uses ASCII ordinal checks and bitwise XOR (32) to flip letters between 65-90 (upper) and 97-122 (lower), leaving other characters unchanged.","def flip_case(string: str) -> str:
    return ''.join([chr(i ^ 32) if 65 <= ord(i) <= 90 or 97 <= ord(i) <= 122 else i for i in string])",not useful
"The comprehension explicitly handles lower to upper, upper to lower, and other characters unchanged, providing clear case-flipping logic.","def flip_case(string: str) -> str:
    return ''.join([c.upper() if c.islower() else c.lower() if c.isupper() else c for c in string])",useful
"Similar to XOR method, it checks if characters are letters via range and flips their case by XORing ord(c) with 32, preserving non-letters.","def flip_case(string: str) -> str:
    return ''.join([chr(ord(c) ^ 32) if 'a' <= c <= 'z' or 'A' <= c <= 'Z' else c for c in string])",useful
This function concatenates all strings in the list into a single string using the efficient join method.,"def concatenate(strings: List[str]) -> str:
    return ''.join(strings)",useful
It builds the result by iteratively adding each string in the list to a growing result string using a for loop.,"def concatenate(strings: List[str]) -> str:
    result = ''
    for s in strings:
        result += s
    return result",useful
"Using map to ensure all elements are strings and join, this safely concatenates the list, though unnecessary if input is already strings.","def concatenate(strings: List[str]) -> str:
    return ''.join(map(str, strings))",useful
"This employs functools.reduce with a lambda to successively add strings, starting from an empty string, to concatenate the list.","def concatenate(strings: List[str]) -> str:
    return reduce(lambda x, y: x + y, strings, '')",not useful
"It uses itertools.chain to flatten the strings' characters and join them, which works but is overkill for simple concatenation.","def concatenate(strings: List[str]) -> str:
    return ''.join(itertools.chain(*strings))",not useful
"A generator expression iterates over the strings and joins them directly, equivalent to the basic join method.","def concatenate(strings: List[str]) -> str:
    return ''.join(string for string in strings)",useful
"This joins the strings if the list is non-empty, otherwise returns an empty string, handling the empty list case explicitly.","def concatenate(strings: List[str]) -> str:
    return ''.join(strings) if strings else ''",useful
"It checks the length of the list before joining, returning empty string for empty lists to avoid any potential issues.","def concatenate(strings: List[str]) -> str:
    return ''.join(strings) if len(strings) > 0 else ''",useful
"Using a truthy check on the list (not empty), it joins the strings or returns empty for an empty list.","def concatenate(strings: List[str]) -> str:
    return ''.join(strings) if strings != [] else ''",useful
"This attempts to handle None input by checking if strings is not None before joining, but join on empty list is safe anyway.","def concatenate(strings: List[str]) -> str:
    return ''.join(strings) if strings is not None else ''",useful
This list comprehension filters strings that start with the given prefix using the built-in startswith method.,"def filter_by_prefix(strings, prefix):
    return [s for s in strings if s.startswith(prefix)]",useful
"Using the filter function with a lambda that checks startswith, it returns a list of strings beginning with the prefix.","def filter_by_prefix(strings, prefix):
    return list(filter(lambda s: s.startswith(prefix), strings))",useful
It manually slices each string to the length of the prefix and compares it directly for equality to filter matching strings.,"def filter_by_prefix(strings, prefix):
    return [s for s in strings if s[:len(prefix)] == prefix]",useful
"The find method is used to check if the prefix starts at index 0, filtering strings that begin with the prefix.","def filter_by_prefix(strings, prefix):
    return [s for s in strings if s.find(prefix) == 0]",useful
"Using index (which raises error if not found), it filters strings where the prefix is at position 0, but risky if prefix not present.","def filter_by_prefix(strings, prefix):
    return [s for s in strings if s.index(prefix) == 0]",not useful
"This checks if stripping the prefix from the left changes the string, indicating the prefix was present at the start.","def filter_by_prefix(strings, prefix):
    return [s for s in strings if s.lstrip(prefix) != s]",not useful
"The partition method splits the string, and it filters if the prefix part equals the prefix, confirming it starts with it.","def filter_by_prefix(strings, prefix):
    return [s for s in strings if s.partition(prefix)[1] == prefix]",not useful
"Employing regular expressions with re.match and ^ anchor, it filters strings that match the prefix at the beginning.","def filter_by_prefix(strings, prefix):
    return [s for s in strings if re.match(f'^{prefix}', s)]",not useful
"By splitting on the prefix once and checking if the first part is empty, it identifies strings starting with the prefix.","def filter_by_prefix(strings, prefix):
    return [s for s in strings if s.split(prefix, 1)[0] == '']",useful
"Using rpartition, it checks if the part before the prefix is empty and the prefix part matches, to filter starting strings, but rpartition is for right side.","def filter_by_prefix(strings, prefix):
    return [s for s in strings if s.rpartition(prefix)[0] == '' and s.rpartition(prefix)[1] == prefix]",not useful
This function filters and returns a list of positive numbers from the input list using a list comprehension.,"def get_positive(l):
    return [i for i in l if i > 0]",useful
This function uses the filter function with a lambda to return a list of positive numbers from the input list.,"def get_positive(l):
    return list(filter(lambda x: x > 0, l))",useful
This function filters and returns a list of positive numbers from the input list using a list comprehension.,"def get_positive(l):
    return [x for x in l if x > 0]",useful
This function filters and returns a list of positive numbers from the input list using a list comprehension.,"def get_positive(l):
    return [i for i in l if i > 0]",useful
This function filters and returns a list of positive numbers from the input list using a list comprehension.,"def get_positive(l):
    return [x for x in l if x > 0]",useful
This function filters and returns a list of positive numbers from the input list using a list comprehension.,"def get_positive(l):
    return [i for i in l if i > 0]",useful
This function filters and returns a list of positive numbers from the input list using a list comprehension.,"def get_positive(l):
    return [x for x in l if x > 0]",useful
This function filters and returns a list of positive numbers from the input list using a list comprehension.,"def get_positive(l):
    return [i for i in l if i > 0]",useful
This function filters and returns a list of positive numbers from the input list using a list comprehension.,"def get_positive(l):
    return [x for x in l if x > 0]",useful
This function filters and returns a list of positive numbers from the input list using a list comprehension.,"def get_positive(l):
    return [i for i in l if i > 0]",useful
"This function checks if a number is prime using an efficient trial division method that skips multiples of 2 and 3, testing divisors in the pattern of 6k  1.","def is_prime(n):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0 or n % 3 == 0: return False
    i = 5
    w = 2
    while i * i <= n:
        if n % i == 0: return False
        i += w
        w = 6 - w
    return True",useful
This function determines primality by first handling small cases and then checking divisibility by numbers of the form 6k  1 up to the square root of n.,"def is_prime(n):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0 or n % 3 == 0: return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0: return False
        i += 6
    return True",useful
"This function tests for primality by checking divisibility from 3 up to the square root of n, skipping even numbers after checking 2.","def is_prime(n):
    if n < 2: return False
    if n == 2: return True
    if n % 2 == 0: return False
    max_div = int(n**0.5) + 1
    for div in range(3, max_div, 2):
        if n % div == 0: return False
    return True",useful
This function implements a prime check with early exits for small primes and an irregular step pattern for divisors starting from 5.,"def is_prime(n):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0 or n % 3 == 0: return False
    i = 5
    while i * i <= n:
        if n % i == 0: return False
        i += 2
        if n % i == 0: return False
        i += 4
    return True",useful
This function uses a wheel factorization approach with steps alternating between 2 and 4 to check for prime numbers efficiently.,"def is_prime(n):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0 or n % 3 == 0: return False
    i = 5
    j = 2
    while i * i <= n:
        if n % i == 0: return False
        i += j
        j = 6 - j
    return True",useful
This function verifies if n is prime by trial division with odd numbers from 3 up to the square root of n.,"def is_prime(n):
    if n < 2: return False
    if n == 2: return True
    if n % 2 == 0: return False
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0: return False
    return True",useful
"This function checks primality with initial checks for small primes and then tests divisors in steps of 2 and 4, including boundary conditions.","def is_prime(n):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0 or n % 3 == 0: return False
    i = 5
    while i * i <= n:
        if n % i == 0: return False
        i += 2
        if i * i <= n and n % i == 0: return False
        i += 4
    return True",useful
This function determines if n is prime by checking odd divisors from 3 up to the square root of n after handling even cases.,"def is_prime(n):
    if n < 2: return False
    if n == 2: return True
    if n % 2 == 0: return False
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0: return False
    return True",useful
"This function implements primality testing with steps of 2 and 4 for divisors after initial small prime checks, ensuring loop bounds.","def is_prime(n):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0 or n % 3 == 0: return False
    i = 5
    while i * i <= n:
        if n % i == 0: return False
        i += 2
        if i * i <= n and n % i == 0: return False
        i += 4
    return True",useful
This function checks for primality using an optimized loop that tests divisors in a 6k  1 pattern with alternating steps.,"def is_prime(n):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0 or n % 3 == 0: return False
    i = 5
    while i * i <= n:
        if n % i == 0: return False
        i += 2
        if i * i <= n and n % i == 0: return False
        i += 4
    return True",useful
This function evaluates a polynomial given coefficients xs at point x by summing coeff * x**i for each term using enumerate.,"def poly(xs, x):
    return sum(coeff * x**i for i, coeff in enumerate(xs))",useful
This function finds the smallest non-negative integer zero of the polynomial by iterating over indices and using the poly function.,"def find_zero(xs):
    return next(x for x in range(len(xs)) if poly(xs, x) == 0)",useful
This function computes the value of a polynomial with coefficients xs at x using a generator expression in sum.,"def poly(xs, x):
    return sum(coeff * x**i for i, coeff in enumerate(xs))",useful
This function locates the first integer root of the polynomial by filtering indices where poly evaluates to zero.,"def find_zero(xs):
    return next(filter(lambda x: poly(xs, x) == 0, range(len(xs))))",useful
This function evaluates the polynomial by calculating the sum of each coefficient multiplied by the appropriate power of x.,"def poly(xs, x):
    return sum(coeff * x**i for i, coeff in enumerate(xs))",not useful
This function returns the first index where the polynomial evaluates to zero using a list comprehension.,"def find_zero(xs):
    return [x for x in range(len(xs)) if poly(xs, x) == 0][0]",useful
This function computes the polynomial value at x by summing powered terms with their coefficients via enumerate.,"def poly(xs, x):
    return sum(coeff * x**i for i, coeff in enumerate(xs))",useful
This function finds the first index where the polynomial is falsy (zero) using a list comprehension and indexing.,"def find_zero(xs):
    return [x for x in range(len(xs)) if not poly(xs, x)][0]",not useful
This function evaluates the polynomial using a sum of coefficient-power products generated with enumerate.,"def poly(xs, x):
    return sum(coeff * x**i for i, coeff in enumerate(xs))",useful
This function identifies the first approximate integer root where the polynomial value is near zero within 1e-9 tolerance.,"def find_zero(xs):
    return [x for x in range(len(xs)) if abs(poly(xs, x)) < 1e-9][0]",not useful
This function sorts every third element of the list in place by slicing and assigning the sorted result back to those positions.,"def sort_third(l):
    l[::3] = sorted(l[::3])
    return l",useful
"This function extracts every third element starting from index 0, sorts them, and replaces them in the original list.","def sort_third(l):
    thirds = sorted(l[i] for i in range(0, len(l), 3))
    for i, val in enumerate(thirds):
        l[i * 3] = val
    return l",useful
This function sorts elements at positions divisible by 3 and reconstructs the list by replacing only those positions with the sorted values.,"def sort_third(l):
    thirds = sorted(l[i] for i in range(len(l)) if i % 3 == 0)
    return [thirds[i // 3] if i % 3 == 0 else val for i, val in enumerate(l)]",useful
"This function collects and sorts every third element from the start, then builds a new list inserting them at the appropriate positions.","def sort_third(l):
    thirds = sorted(l[i] for i in range(0, len(l), 3))
    return [thirds[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]",useful
This function sorts elements where index % 3 == 0 and updates the original list in place using slicing.,"def sort_third(l):
    thirds = sorted(l[i] for i in range(len(l)) if not i % 3)
    l[::3] = thirds
    return l",useful
"This function sorts the elements at indices 0, 3, 6, etc., and updates them in the original list via direct assignment.","def sort_third(l):
    thirds = sorted(l[i] for i in range(0, len(l), 3))
    for i in range(0, len(l), 3):
        l[i] = thirds[i // 3]
    return l",useful
This function sorts every third element starting from 0 and creates a new list with those sorted values in place.,"def sort_third(l):
    thirds = sorted(l[i] for i in range(len(l)) if i % 3 == 0)
    l = [thirds[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]
    return l",not useful
"This function extracts, sorts, and replaces every third element, using a conditional in a list comprehension to build the result.","def sort_third(l):
    thirds = sorted(l[i] for i in range(0, len(l), 3))
    l = [thirds[i // 3] if not i % 3 else val for i, val in enumerate(l)]
    return l",useful
"This function identifies positions i % 3 == 0, sorts those elements, and reconstructs the list with replacements.","def sort_third(l):
    thirds = sorted(l[i] for i in range(len(l)) if i % 3 == 0)
    l = [thirds[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]
    return l",useful
This function sorts elements at multiples of 3 and uses enumerate to conditionally place them in a new list.,"def sort_third(l):
    thirds = sorted(l[i] for i in range(0, len(l), 3))
    l = [thirds[i // 3] if i % 3 == 0 else val for i, val in enumerate(l)]
    return l",useful
This function returns the sorted unique elements from the list by converting to a set and then sorting.,"def unique(l):
    return sorted(set(l))",useful
"This function removes duplicates using dict.fromkeys to preserve order, then sorts the resulting list.","def unique(l):
    return list(dict.fromkeys(l)).sort()",not useful
This function converts the list to a set to remove duplicates and sorts the result into a list.,"def unique(l):
    return sorted(list(set(l)))",useful
This function uses a set comprehension to get unique elements and sorts them.,"def unique(l):
    return sorted({i for i in l})",useful
This function removes duplicates with a set and returns a sorted list of unique elements.,"def unique(l):
    return sorted(list(set(l)))",useful
This function unpacks the list into a set for uniqueness and sorts the result into a list.,"def unique(l):
    return sorted(list({*l}))",useful
This function gets unique elements via set and sorts them into a list.,"def unique(l):
    return sorted(list(set(l)))",useful
This function converts the list to a set for uniqueness and sorts the set directly.,"def unique(l):
    return sorted(set(l))",useful
This function uses a set to eliminate duplicates and produces a sorted list.,"def unique(l):
    return sorted(list(set(l)))",useful
This function returns sorted unique elements by creating a set and sorting it.,"def unique(l):
    return sorted(set(l))",useful
This function uses Python's built-in max() function to return the largest element in the input list.,"def max_element(l):
    return max(l)",useful
This function manually iterates through the list to find and return the maximum element by comparing each value to the current maximum.,"def max_element(l):
    m = l[0]
    for i in l:
        if i > m:
            m = i
    return m",useful
"This function sorts the entire list in ascending order and returns the last element, which is the maximum.","def max_element(l):
    return sorted(l)[-1]",useful
This function uses the reduce() function with a lambda to iteratively compare and return the maximum element from the list.,"def max_element(l):
    return reduce(lambda a, b: a if a > b else b, l)",useful
This function utilizes heapq.nlargest() to find the largest element and returns the first (and only) item from the result.,"def max_element(l):
    return heapq.nlargest(1, l)[0]",useful
"This function applies the built-in max() with a key function that converts elements to integers, returning the maximum value.","def max_element(l):
    return max(l, key=int)",useful
This function uses max() with a default value of None to handle empty lists gracefully by returning None if the list is empty.,"def max_element(l):
    return max(l, default=None)",useful
This function employs max() with a default of negative infinity to ensure a safe minimum value is returned for empty lists.,"def max_element(l):
    return max(l, default=float('-inf'))",useful
"This function uses max() with a default of the first list element, but it will raise an error if the list is empty due to accessing l[0].","def max_element(l):
    return max(l, default=l[0])",not useful
"This function applies max() with a default of the minimum list value, though it errors on empty lists when trying to compute min(l).","def max_element(l):
    return max(l, default=min(l))",not useful
"This function uses inclusion-exclusion to sum the count of '7' digits in strings of numbers up to n that are multiples of 11 or 13, stepping by 11 and 13.","def fizz_buzz(n: int):
    return sum(str(i).count('7') for i in range(11, n, 11)) + sum(str(i).count('7') for i in range(13, n, 13)) - sum(str(i).count('7') for i in range(11*13, n, 11*13))",useful
"This function iterates through numbers from 0 to n-1, counting '7's in their string representations for those divisible by 11 or 13.","def fizz_buzz(n: int):
    return sum(str(i).count('7') for i in range(n) if i % 11 == 0 or i % 13 == 0)",useful
"This function creates sets of multiples of 11 and 13 up to n, unions them, and sums the '7' digit counts in their string forms.","def fizz_buzz(n: int):
    return sum(str(i).count('7') for i in set(range(11, n, 11)) | set(range(13, n, 13)))",useful
This function filters numbers up to n divisible by 11 or 13 using a lambda and sums the occurrences of '7' in their string representations.,"def fizz_buzz(n: int):
    return sum(str(i).count('7') for i in filter(lambda x: x % 11 == 0 or x % 13 == 0, range(n)))",useful
"This function loops through range(n), checking divisibility by 11 or 13, and accumulates the count of '7' digits in each qualifying number's string.","def fizz_buzz(n: int):
    return sum(str(i).count('7') for i in range(n) if i % 11 == 0 or i % 13 == 0)",useful
"This function applies inclusion-exclusion by summing '7' counts for multiples of 11 and 13 separately, subtracting those for multiples of 143 (11*13).","def fizz_buzz(n: int):
    return sum(str(i).count('7') for i in range(n) if i % 11 == 0) + sum(str(i).count('7') for i in range(n) if i % 13 == 0) - sum(str(i).count('7') for i in range(n) if i % (11*13) == 0)",useful
This function sums the '7' digit occurrences in strings of numbers from 0 to n-1 that are divisible by 11 or 13 using a conditional loop.,"def fizz_buzz(n: int):
    return sum(str(i).count('7') for i in range(n) if i % 11 == 0 or i % 13 == 0)",useful
This function uses inclusion-exclusion to calculate the total '7' digits in multiples of 11 or 13 up to n by adding separate sums and subtracting the intersection.,"def fizz_buzz(n: int):
    return sum(str(i).count('7') for i in range(n) if i % 11 == 0) + sum(str(i).count('7') for i in range(n) if i % 13 == 0) - sum(str(i).count('7') for i in range(n) if i % (11*13) == 0)",useful
This function iterates over range(n) and sums '7' counts from strings of numbers divisible by 11 or 13.,"def fizz_buzz(n: int):
    return sum(str(i).count('7') for i in range(n) if i % 11 == 0 or i % 13 == 0)",useful
This function computes the sum of '7' digits in multiples of 11 or 13 using inclusion-exclusion principle across three separate sums.,"def fizz_buzz(n: int):
    return sum(str(i).count('7') for i in range(n) if i % 11 == 0) + sum(str(i).count('7') for i in range(n) if i % 13 == 0) - sum(str(i).count('7') for i in range(n) if i % (11*13) == 0)",useful
"This function extracts even-indexed elements using slicing, sorts them, and replaces them in the original list before returning it.","def sort_even(l):
    evens = sorted(l[::2])
    l[::2] = evens
    return l",useful
"This function slices even indices, sorts the slice in place, and assigns it back to the even positions in the list.","def sort_even(l):
    evens = l[::2]
    evens.sort()
    l[::2] = evens
    return l",useful
"This function uses enumerate and a generator to collect and sort even-indexed values, then updates the list's even positions.","def sort_even(l):
    evens = sorted(v for i, v in enumerate(l) if i % 2 == 0)
    l[::2] = evens
    return l",useful
"This function filters and sorts elements based on their first even index occurrence, then replaces even positions in the list; note that index() is inefficient for duplicates.","def sort_even(l):
    evens = sorted(filter(lambda x: l.index(x) % 2 == 0, l))
    l[::2] = evens
    return l",not useful
"This function uses a list comprehension with enumerate to gather even-indexed elements, sorts them, and substitutes into the list's even indices.","def sort_even(l):
    evens = sorted([v for i, v in enumerate(l) if i % 2 == 0])
    l[::2] = evens
    return l",useful
"This function generates even-indexed elements using a range with step 2, sorts them, and assigns back to even positions in the list.","def sort_even(l):
    evens = sorted(l[i] for i in range(0, len(l), 2))
    l[::2] = evens
    return l",useful
"This function collects even-indexed elements via a generator expression with conditional indexing, sorts, and updates the list accordingly.","def sort_even(l):
    evens = sorted(l[i] for i in range(len(l)) if i % 2 == 0)
    l[::2] = evens
    return l",useful
"This function attempts to sort elements whose first index is even using index(), which may mishandle duplicates, then replaces even positions.","def sort_even(l):
    evens = sorted([x for x in l if l.index(x) % 2 == 0])
    l[::2] = evens
    return l",not useful
This function uses a generator with enumerate and modulo condition to sort even-indexed values and reinsert them into the list.,"def sort_even(l):
    evens = sorted(v for i, v in enumerate(l) if not i % 2)
    l[::2] = evens
    return l",useful
"This function generates even-indexed elements with a conditional range, sorts them, and places them back into the even indices of the list.","def sort_even(l):
    evens = sorted(l[i] for i in range(len(l)) if not i % 2)
    l[::2] = evens
    return l",useful
"This function splits the string into groups of 3 characters, rotates each full group left by one (encode) or right by one (decode), and joins them back; shorter groups remain unchanged.","def encode_cyclic(s): return ''.join(t[1:] + t[0] if len(t) == 3 else t for t in [s[i:i+3] for i in range(0, len(s), 3)])
def decode_cyclic(s): return ''.join(t[-1] + t[:-1] if len(t) == 3 else t for t in [s[i:i+3] for i in range(0, len(s), 3)])",useful
"This function uses a generator to chunk the string into groups of 3, applies left rotation for encoding and right for decoding on full groups, then concatenates the results.","def encode_cyclic(s): return ''.join(g[1:] + g[0] if len(g) == 3 else g for g in (s[i:i+3] for i in range(0, len(s), 3)))
def decode_cyclic(s): return ''.join(g[-1] + g[:-1] if len(g) == 3 else g for g in (s[i:i+3] for i in range(0, len(s), 3)))",useful
"This function employs iter() and zip() to group characters into threes, rotates full groups cyclically for encode/decode, and joins the processed groups.","def encode_cyclic(s): return ''.join(g[1:] + g[0] if len(g) == 3 else g for g in map(''.join, zip(*[iter(s)]*3)))
def decode_cyclic(s): return ''.join(g[-1] + g[:-1] if len(g) == 3 else g for g in map(''.join, zip(*[iter(s)]*3)))",useful
"This function divides the string into triplets via slicing, performs left shift for encoding and right for decoding on length-3 groups, and rejoins them.","def encode_cyclic(s): return ''.join(g[1:] + g[0] if len(g) == 3 else g for g in [s[i:i+3] for i in range(0, len(s), 3)])
def decode_cyclic(s): return ''.join(g[-1] + g[:-1] if len(g) == 3 else g for g in [s[i:i+3] for i in range(0, len(s), 3)])",useful
"This function creates a list of 3-character substrings, rotates qualifying groups left for encode or right for decode, and concatenates the output.","def encode_cyclic(s): return ''.join([g[1:] + g[0] if len(g) == 3 else g for g in [s[i:i+3] for i in range(0, len(s), 3)]])
def decode_cyclic(s): return ''.join([g[-1] + g[:-1] if len(g) == 3 else g for g in [s[i:i+3] for i in range(0, len(s), 3)]])",useful
"This function chunks the string into groups of 3, uses map with lambda to rotate full groups (left for encode, right for decode), and joins the results.","def encode_cyclic(s): return ''.join(map(lambda g: g[1:] + g[0] if len(g) == 3 else g, [s[i:i+3] for i in range(0, len(s), 3)]))
def decode_cyclic(s): return ''.join(map(lambda g: g[-1] + g[:-1] if len(g) == 3 else g, [s[i:i+3] for i in range(0, len(s), 3)]))",useful
"This function generates 3-char groups on-the-fly, applies lambda-based rotation via map for encode/decode on full groups, and concatenates.","def encode_cyclic(s): return ''.join(map(lambda g: g[1:] + g[0] if len(g) == 3 else g, (s[i:i+3] for i in range(0, len(s), 3))))
def decode_cyclic(s): return ''.join(map(lambda g: g[-1] + g[:-1] if len(g) == 3 else g, (s[i:i+3] for i in range(0, len(s), 3))))",useful
"This function groups characters using iter and zip, then maps a lambda to cyclically rotate full groups left for encode or right for decode before joining.","def encode_cyclic(s): return ''.join(map(lambda g: g[1:] + g[0] if len(g) == 3 else g, map(''.join, zip(*[iter(s)]*3))))
def decode_cyclic(s): return ''.join(map(lambda g: g[-1] + g[:-1] if len(g) == 3 else g, map(''.join, zip(*[iter(s)]*3))))",useful
"This function uses zip with iter to form groups of 3, applies list comprehension for rotation (left encode, right decode) on full groups, and joins.","def encode_cyclic(s): return ''.join([g[1:] + g[0] if len(g) == 3 else g for g in map(''.join, zip(*[iter(s)]*3))])
def decode_cyclic(s): return ''.join([g[-1] + g[:-1] if len(g) == 3 else g for g in map(''.join, zip(*[iter(s)]*3))])",useful
"This function slices the string into 3-char lists, maps a lambda to rotate full groups (left for encode, right for decode), and joins the output.","def encode_cyclic(s): return ''.join(map(lambda g: g[1:] + g[0] if len(g) == 3 else g, [s[i:i+3] for i in range(0, len(s), 3)]))
def decode_cyclic(s): return ''.join(map(lambda g: g[-1] + g[:-1] if len(g) == 3 else g, [s[i:i+3] for i in range(0, len(s), 3)]))",useful
"This function generates Fibonacci numbers sequentially, checks each for primality using a basic trial division up to sqrt, and returns the nth prime Fibonacci number.","def prime_fib(n):
    def is_prime(num):
        if num < 2: return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0: return False
        return True
    a, b, count = 0, 1, 0
    while count < n:
        a, b = b, a + b
        if is_prime(a): count += 1
    return a",useful
"This function produces Fibonacci sequence, tests primality with an optimized check skipping evens after 2, and returns the nth prime in the sequence.","def prime_fib(n):
    def is_prime(num):
        if num < 2: return False
        if num == 2: return True
        if num % 2 == 0: return False
        for i in range(3, int(num**0.5) + 1, 2):
            if num % i == 0: return False
        return True
    a, b, count = 0, 1, 0
    while count < n:
        a, b = b, a + b
        if is_prime(a): count += 1
    return a",useful
"This function advances Fibonacci numbers, uses a 6k1 optimized primality test, counting until the nth prime Fibonacci is found and returned.","def prime_fib(n):
    def is_prime(num):
        if num < 2: return False
        if num == 2 or num == 3: return True
        if num % 2 == 0 or num % 3 == 0: return False
        i = 5
        w = 2
        while i * i <= num:
            if num % i == 0: return False
            i += w
            w = 6 - w
        return True
    a, b, count = 0, 1, 0
    while count < n:
        a, b = b, a + b
        if is_prime(a): count += 1
    return a",useful
"This function iterates Fibonacci, applies an efficient primality check testing divisibility by 6k1, and returns the nth prime Fibonacci number.","def prime_fib(n):
    def is_prime(num):
        if num < 2: return False
        if num == 2 or num == 3: return True
        if num % 2 == 0 or num % 3 == 0: return False
        i = 5
        while i * i <= num:
            if num % i == 0 or num % (i + 2) == 0: return False
            i += 6
        return True
    a, b, count = 0, 1, 0
    while count < n:
        a, b = b, a + b
        if is_prime(a): count += 1
    return a",useful
"This function generates Fibonacci terms, checks primality by testing odd divisors up to sqrt, and returns the nth such prime.","def prime_fib(n):
    def is_prime(num):
        if num < 2: return False
        if num == 2: return True
        if num % 2 == 0: return False
        max_div = int(num**0.5) + 1
        for div in range(3, max_div, 2):
            if num % div == 0: return False
        return True
    a, b, count = 0, 1, 0
    while count < n:
        a, b = b, a + b
        if is_prime(a): count += 1
    return a",useful
"This function uses a 6k1 primality test on Fibonacci numbers, collects them in a list until reaching n, and returns the last one.","def prime_fib(n):
    def is_prime(num):
        if num < 2: return False
        if num == 2 or num == 3: return True
        if num % 2 == 0 or num % 3 == 0: return False
        i = 5
        w = 2
        while i * i <= num:
            if num % i == 0: return False
            i += w
            w = 6 - w
        return True
    a, b = 0, 1
    primes = []
    while len(primes) < n:
        a, b = b, a + b
        if is_prime(a): primes.append(a)
    return primes[-1]",useful
"This function starts with known prime 2, generates Fibonacci, checks divisibility by prior primes (though incomplete for fib primes), and returns the nth.","def prime_fib(n):
    def is_prime(num):
        if num < 2: return False
        if num == 2 or num == 3: return True
        if num % 2 == 0 or num % 3 == 0: return False
        i = 5
        w = 2
        while i * i <= num:
            if num % i == 0: return False
            i += w
            w = 6 - w
        return True
    primes = [2]
    a, b = 0, 1
    while len(primes) < n:
        a, b = b, a + b
        if all(a % p > 0 for p in primes): primes.append(a)
    return primes[-1]",not useful
"This function builds a list of prime Fibonaccis using trial division up to sqrt for each new fib term, returning the nth.","def prime_fib(n):
    def is_prime(num):
        if num < 2: return False
        if num == 2 or num == 3: return True
        if num % 2 == 0 or num % 3 == 0: return False
        i = 5
        w = 2
        while i * i <= num:
            if num % i == 0: return False
            i += w
            w = 6 - w
        return True
    primes = []
    a, b = 0, 1
    while len(primes) < n:
        a, b = b, a + b
        if all(a % p > 0 for p in range(2, int(a**0.5) + 1)): primes.append(a)
    return primes[-1]",not useful
"This function attempts primality by checking against a constructed list of potential divisors in 6k1 form, but the logic is flawed; collects and returns nth prime fib.","def prime_fib(n):
    def is_prime(num):
        if num < 2: return False
        if num == 2 or num == 3: return True
        if num % 2 == 0 or num % 3 == 0: return False
        i = 5
        w = 2
        while i * i <= num:
            if num % i == 0: return False
            i += w
            w = 6 - w
        return True
    primes = []
    a, b = 0, 1
    while len(primes) < n:
        a, b = b, a + b
        if all(a % p > 0 for p in [2, 3] + [i for i in range(5, int(a**0.5) + 1, 6)] + [i for i in range(7, int(a**0.5) + 1, 6)]): primes.append(a)
    return primes[-1]",not useful
"This function uses a complex but incorrect divisor list for primality testing on Fibonacci numbers, appending primes to a list and returning the nth.","def prime_fib(n):
    def is_prime(num):
        if num < 2: return False
        if num == 2 or num == 3: return True
        if num % 2 == 0 or num % 3 == 0: return False
        i = 5
        w = 2
        while i * i <= num:
            if num % i == 0: return False
            i += w
            w = 6 - w
        return True
    primes = []
    a, b = 0, 1
    while len(primes) < n:
        a, b = b, a + b
        if all(a % p > 0 for p in [2, 3] + [i for i in range(5, int(a**0.5) + 1, 6)] + [i for i in range(7, int(a**0.5) + 1, 6)] if i * i <= a): primes.append(a)
    return primes[-1]",not useful
"This function sorts the input list and iterates through each element as the first of a potential triple, using two pointers to check if the remaining elements can sum with it to zero, skipping duplicates to avoid redundant checks.","def triples_sum_to_zero(l):
    l.sort()
    for i in range(len(l) - 2):
        if i > 0 and l[i] == l[i - 1]:
            continue
        left, right = i + 1, len(l) - 1
        while left < right:
            if l[i] + l[left] + l[right] < 0:
                left += 1
            elif l[i] + l[left] + l[right] > 0:
                right -= 1
            else:
                return True
    return False",useful
"This function sorts the list and for each fixed element, computes the target sum needed from the other two using two pointers on the subarray, efficiently finding if a pair sums to the negative of the fixed element.","def triples_sum_to_zero(l):
    l.sort()
    for i in range(len(l) - 2):
        if i > 0 and l[i] == l[i - 1]:
            continue
        target = -l[i]
        left, right = i + 1, len(l) - 1
        while left < right:
            if l[left] + l[right] < target:
                left += 1
            elif l[left] + l[right] > target:
                right -= 1
            else:
                return True
    return False",useful
"This function sorts the list and for each fixed element, uses a set to track seen elements in the remaining subarray, checking if the complement needed for the target sum exists in the set.","def triples_sum_to_zero(l):
    l.sort()
    for i in range(len(l) - 2):
        if i > 0 and l[i] == l[i - 1]:
            continue
        target = -l[i]
        seen = set()
        for j in range(i + 1, len(l)):
            complement = target - l[j]
            if complement in seen:
                return True
            seen.add(l[j])
    return False",useful
"This function sorts the list and employs a two-pointer approach for each fixed first element to scan the subarray, adjusting pointers based on whether the current triple sum is less than, greater than, or equal to zero.","def triples_sum_to_zero(l):
    l.sort()
    for i in range(len(l) - 2):
        if i > 0 and l[i] == l[i - 1]:
            continue
        left, right = i + 1, len(l) - 1
        while left < right:
            if l[i] + l[left] + l[right] == 0:
                return True
            elif l[i] + l[left] + l[right] < 0:
                left += 1
            else:
                right -= 1
    return False",useful
"This function sorts the list, fixes one element, sets the target as its negation, and uses two pointers to find if a pair in the subarray sums to that target by comparing their sum.","def triples_sum_to_zero(l):
    l.sort()
    for i in range(len(l) - 2):
        if i > 0 and l[i] == l[i - 1]:
            continue
        target = -l[i]
        left, right = i + 1, len(l) - 1
        while left < right:
            current_sum = l[left] + l[right]
            if current_sum == target:
                return True
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    return False",useful
"This function sorts the list and for each potential first element, applies two pointers on the rest to compute the triple sum directly and adjust based on its value relative to zero.","def triples_sum_to_zero(l):
    l.sort()
    for i in range(len(l) - 2):
        if i > 0 and l[i] == l[i - 1]:
            continue
        left, right = i + 1, len(l) - 1
        while left < right:
            current_sum = l[i] + l[left] + l[right]
            if current_sum == 0:
                return True
            elif current_sum < 0:
                left += 1
            else:
                right -= 1
    return False",useful
"This function sorts the list, fixes an element, computes the target as its negative, and uses two pointers to check if the sum of a pair equals the target, moving pointers accordingly.","def triples_sum_to_zero(l):
    l.sort()
    for i in range(len(l) - 2):
        if i > 0 and l[i] == l[i - 1]:
            continue
        target = -l[i]
        left, right = i + 1, len(l) - 1
        while left < right:
            current_sum = l[left] + l[right]
            if current_sum == target:
                return True
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    return False",useful
"This function sorts the list and iterates with a fixed first element, using two pointers to evaluate the triple sum and increment left or decrement right based on whether it's below or above zero.","def triples_sum_to_zero(l):
    l.sort()
    for i in range(len(l) - 2):
        if i > 0 and l[i] == l[i - 1]:
            continue
        left, right = i + 1, len(l) - 1
        while left < right:
            current_sum = l[i] + l[left] + l[right]
            if current_sum == 0:
                return True
            elif current_sum < 0:
                left += 1
            else:
                right -= 1
    return False",useful
"This function sorts the list, selects a fixed element, defines the target as its negation, and employs two pointers to see if any pair sums to the target by comparing their sum.","def triples_sum_to_zero(l):
    l.sort()
    for i in range(len(l) - 2):
        if i > 0 and l[i] == l[i - 1]:
            continue
        target = -l[i]
        left, right = i + 1, len(l) - 1
        while left < right:
            current_sum = l[left] + l[right]
            if current_sum == target:
                return True
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    return False",useful
"This function sorts the list and for each first element in the triple, uses two pointers on the subarray to calculate the sum and adjust pointers if it's not zero.","def triples_sum_to_zero(l):
    l.sort()
    for i in range(len(l) - 2):
        if i > 0 and l[i] == l[i - 1]:
            continue
        left, right = i + 1, len(l) - 1
        while left < right:
            current_sum = l[i] + l[left] + l[right]
            if current_sum == 0:
                return True
            elif current_sum < 0:
                left += 1
            else:
                right -= 1
    return False",useful
"This function simply returns the square of n by multiplying n by itself, representing the total number of pairwise collisions.","def car_race_collision(n: int) -> int:
    return n * n",useful
"This lambda function computes and returns n squared, calculating the product of n with itself for the collision count.",car_race_collision = lambda n: n * n,useful
"This function uses exponentiation to return n raised to the power of 2, equivalent to n squared for collision calculations.","def car_race_collision(n: int) -> int:
    return n ** 2",useful
"This function initializes a counter and adds n to it n times in a loop, effectively computing n * n for the total collisions.","def car_race_collision(n: int) -> int:
    collisions = 0
    for _ in range(n):
        collisions += n
    return collisions",useful
"This function uses a generator expression inside sum to add n, n times, resulting in n squared as the return value.","def car_race_collision(n: int) -> int:
    return sum(n for _ in range(n))",useful
"This function creates a list of n repeated n times and sums it, yielding n * n as the total number of collisions.","def car_race_collision(n: int) -> int:
    return sum([n] * n)",useful
"This function generates all pairs (x, y) where x and y range from 0 to n-1 using a list comprehension and returns the length, which is n squared.","def car_race_collision(n: int) -> int:
    return len([(x, y) for x in range(n) for y in range(n)])",useful
"This function uses reduce with a lambda to sum a list of n repeated n times, computing the total as n * n.","def car_race_collision(n: int) -> int:
    return reduce(lambda x, y: x + y, [n] * n)",not useful
"This function employs functools.reduce and operator.add to sum a list containing n, n times, resulting in n squared.","def car_race_collision(n: int) -> int:
    return functools.reduce(operator.add, [n] * n)",not useful
"This function returns n squared if n is greater than 0, otherwise 0, handling the case for non-positive inputs in collision counting.","def car_race_collision(n: int) -> int:
    return n * n if n > 0 else 0",useful
This function uses a list comprehension to create a new list where each element of the input is incremented by 1.,"def incr_list(l):
    return [i + 1 for i in l]",useful
"This function applies the map function with a lambda to add 1 to each element in the list, then converts the result back to a list.","def incr_list(l):
    return list(map(lambda x: x + 1, l))",useful
"This function uses a list comprehension with the __add__ method to increment each element by 1, leveraging Python's special methods.","def incr_list(l):
    return [x.__add__(1) for x in l]",useful
"This function creates a new list by incrementing elements that are instances of int using isinstance, skipping non-integer elements.","def incr_list(l):
    return [x + 1 for x in l if isinstance(x, int)]",not useful
"This function attempts to use the in-place __iadd__ method in a list comprehension to increment each element, but note that it creates new integers rather than modifying in place.","def incr_list(l):
    return [x.__iadd__(1) for x in l]",not useful
"This function uses a list comprehension to increment elements where the type is exactly int, excluding subclasses or other types.","def incr_list(l):
    return [x + 1 for x in l if type(x) is int]",not useful
"This function increments elements that are exactly of type int using __add__ in a list comprehension, filtering with type check.","def incr_list(l):
    return [x.__add__(1) for x in l if type(x) is int]",not useful
"This function uses __iadd__ in a list comprehension to increment elements checked with isinstance for int, though it doesn't modify originals.","def incr_list(l):
    return [x.__iadd__(1) for x in l if isinstance(x, int)]",not useful
"This function increments elements where type equals int using a list comprehension, applying the + operator only to matching types.","def incr_list(l):
    return [x + 1 for x in l if type(x) == int]",not useful
"This function uses __add__ to increment elements filtered by exact type int in a list comprehension, creating a new list.","def incr_list(l):
    return [x.__add__(1) for x in l if type(x) == int]",not useful
"This function uses a set to track elements seen so far and checks if the negation of the current element exists in the set, returning true if a pair sums to zero.","def pairs_sum_to_zero(l):
    s = set()
    for i in l:
        if -i in s:
            return True
        s.add(i)
    return False",useful
"This function sorts the list and uses two pointers from the ends to find if any pair sums to zero, moving pointers based on the current sum.","def pairs_sum_to_zero(l):
    l.sort()
    left, right = 0, len(l) - 1
    while left < right:
        s = l[left] + l[right]
        if s == 0:
            return True
        elif s < 0:
            left += 1
        else:
            right -= 1
    return False",useful
"This function uses a dictionary to mark potential complements; for each element, it checks if its negation is already a key before adding the current as a potential match for future negations.","def pairs_sum_to_zero(l):
    d = {}
    for i in l:
        if i in d:
            return True
        d[-i] = True
    return False",not useful
"This function uses any with a generator to check all distinct pairs in the list, returning true if any two sum to zero.","def pairs_sum_to_zero(l):
    return any(i + j == 0 for i in l for j in l if i != j)",not useful
"This function concatenates the list with the negations of its elements and compares lengths to the unique set, detecting duplicates that indicate a pair summing to zero.","def pairs_sum_to_zero(l):
    return len(l) != len(set(l + [-i for i in l]))",not useful
This function creates a set of the list elements and checks if any negation of an element exists in that set using any and a generator.,"def pairs_sum_to_zero(l):
    s = set(l)
    return any(i in s for i in (-x for x in l))",not useful
"This function iterates through the list and uses count to check if the negation of each element appears at least once, returning true if so.","def pairs_sum_to_zero(l):
    return any(l.count(-i) > 0 for i in l)",not useful
"This function sums the counts of negations for each element and returns true if the total is greater than zero, indicating at least one pair.","def pairs_sum_to_zero(l):
    return sum(l.count(-i) for i in l) > 0",not useful
"This function creates a list of elements whose negations exist in the original list and returns true if more than one such element is found, though it may overcount self-pairs.","def pairs_sum_to_zero(l):
    return len([i for i in l if -i in l]) > 1",useful
"This function computes the intersection of the set of list elements and the set of their negations, returning true if non-empty.","def pairs_sum_to_zero(l):
    return len(set(l) & set(-i for i in l)) > 0",not useful
"This function attempts to format the binary representation of x with a width based on bit length and base, but it's designed for binary output regardless of base.","def change_base(x: int, base: int) -> str:
    return '{0:0{1}b}'.format(x, (x.bit_length() + base - 1) // base)",not useful
This function uses NumPy's base_repr to convert the integer x to a string in the specified base.,"def change_base(x: int, base: int) -> str:
    return np.base_repr(x, base)",useful
"This function converts x to binary, then tries to reformat it as binary again using __format__, which doesn't correctly change to the desired base.","def change_base(x: int, base: int) -> str:
    return int(bin(x)[2:], 2).__format__('{:b}'.format(base))",not useful
"This function iteratively computes remainders using divmod in a generator until x is zero, collects digits as strings, and reverses them to form the base representation.","def change_base(x: int, base: int) -> str:
    return ''.join(reversed([str(x % base) for x in iter(lambda: x // base, 0)]))",not useful
"This function recursively builds the base representation by appending the remainder digit and calling itself on the quotient, but it's structured to return a tuple that needs joining.","def change_base(x: int, base: int) -> str:
    return ''.join(divmod(x, base) if x < base else divmod(x, base) + (change_base(x // base, base),))",not useful
"This function recursively prepends the digit (0-9) for x % base and calls itself on x // base until x is zero, assuming base <=10 for single-digit chars.","def change_base(x: int, base: int) -> str:
    return ('0123456789'[x % base] + change_base(x // base, base)) if x > 0 else ''",not useful
"This function uses an iterator to generate digits by repeatedly taking x % base as a char from '0123456789' and updating x to x // base, then reverses the joined string.","def change_base(x: int, base: int) -> str:
    return ''.join(iter(lambda: '0123456789'[x % base] if x > 0 else '', x := x // base))[::-1]",not useful
"This function generates a sequence of remainders using an iterator on x // base until zero, converts them to strings, and reverses to build the base number string.","def change_base(x: int, base: int) -> str:
    return ''.join(reversed([str(x % base) for x in iter(lambda: x // base, 0)]))",not useful
"This function iteratively computes remainders with a generator until x is zero, collects them as strings, and reverses the list to form the correct base representation.","def change_base(x: int, base: int) -> str:
    return ''.join(reversed([str(x % base) for x in iter(lambda: x // base, 0)]))",not useful
"This function uses an iterator to produce successive x // base values until zero, collects the % base as strings, and reverses them to construct the base conversion string.","def change_base(x: int, base: int) -> str:
    return ''.join(reversed([str(x % base) for x in iter(lambda: x // base, 0)]))",not useful
This function calculates the area of a triangle using the formula (1/2) * base * height with explicit multiplication by 0.5.,"def triangle_area(a, h):
    return 0.5 * a * h",useful
"This lambda function computes the triangle area as 0.5 times base and height, providing a concise alternative to a full function definition.","triangle_area = lambda a, h: 0.5 * a * h",useful
"This function determines the triangle area by multiplying base and height then dividing by 2, equivalent to the standard formula.","def triangle_area(a, h):
    return a * h / 2",useful
"A lambda expression that calculates triangle area using integer division by 2 after multiplication, assuming integer inputs.","triangle_area = lambda a, h: a * h / 2",not useful
"This function uses a right bit shift (>> 1) to divide the product of base and height by 2, which works for positive integers but may lose precision for floats.","def triangle_area(a, h):
    return a * h >> 1",not useful
"A lambda using bit shift to halve the product of base and height, efficient for integers but not suitable for floating-point numbers.","triangle_area = lambda a, h: a * h >> 1",not useful
This computes the triangle area with explicit float division by 2.0 to ensure a floating-point result.,"def triangle_area(a, h):
    return a * h / 2.0",useful
Lambda function that multiplies base and height then divides by 2.0 for floating-point precision in area calculation.,"triangle_area = lambda a, h: a * h / 2.0",useful
"The function calculates triangle area with parentheses around the multiplication for clarity, then divides by 2.0.","def triangle_area(a, h):
    return (a * h) / 2.0",useful
A lambda that uses parenthesized multiplication before floating-point division by 2.0 to compute the triangle area.,"triangle_area = lambda a, h: (a * h) / 2.0",useful
"This function computes the nth term of a sequence where each term is the sum of the previous four, starting with [0,0,2,0], using iterative variable updates but returns incorrectly for n>=3.","def fib4(n):
    a, b, c, d = 0, 0, 2, 0
    for _ in range(n - 3):
        a, b, c, d = b, c, d, a + b + c + d
    return d",not useful
"It preallocates a list for the sequence with initial values [0,0,2,0] and iteratively computes each subsequent term as the sum of the prior four up to index n.","def fib4(n):
    fib = [0, 0, 2, 0] + [0] * (n - 3)
    for i in range(4, n + 1):
        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4]
    return fib[n]",useful
"Handles base cases for n<4 by direct lookup, then iteratively updates four variables to compute the nth term of the sum-of-previous-four sequence.","def fib4(n):
    if n < 4:
        return [0, 0, 2, 0][n]
    a, b, c, d = 0, 0, 2, 0
    for _ in range(n - 3):
        a, b, c, d = b, c, d, a + b + c + d
    return d",useful
"For n<4, returns initial values; otherwise, initializes a list with fib[2]=2 and fills it iteratively by summing the previous four elements.","def fib4(n):
    if n < 4:
        return [0, 0, 2, 0][n]
    fib = [0] * (n + 1)
    fib[2] = 2
    for i in range(4, n + 1):
        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4]
    return fib[n]",useful
"Base cases for n<4 use a list lookup; then starts with [0,0,2,0] and appends the sum of the last four elements in a loop up to n.","def fib4(n):
    if n < 4:
        return [0, 0, 2, 0][n]
    fib = [0, 0, 2, 0]
    for _ in range(4, n + 1):
        fib.append(sum(fib[-4:]))
    return fib[n]",useful
"After base case handling, it iterates to update four variables but incorrectly returns their sum instead of the last one for the nth term.","def fib4(n):
    if n < 4:
        return [0, 0, 2, 0][n]
    a, b, c, d = 0, 0, 2, 0
    for _ in range(n - 3):
        a, b, c, d = b, c, d, a + b + c + d
    return a + b + c + d",not useful
"For small n, uses direct return; otherwise, creates a list, sets fib[2]=2, and computes each term as the sum of the four preceding ones using slicing.","def fib4(n):
    if n < 4:
        return [0, 0, 2, 0][n]
    fib = [0] * (n + 1)
    fib[2] = 2
    for i in range(4, n + 1):
        fib[i] = sum(fib[i - 4:i])
    return fib[n]",useful
"Base cases handled; starts with initial list and iteratively replaces it by shifting and appending the sum of all current elements, but this mutates incorrectly.","def fib4(n):
    if n < 4:
        return [0, 0, 2, 0][n]
    fib = [0, 0, 2, 0]
    for _ in range(4, n + 1):
        fib = fib[1:] + [sum(fib)]
    return fib[-1]",not useful
"After base cases, begins with [0,0,2,0] and updates the list by taking the last three plus the sum of all four, leading to incorrect sequence.","def fib4(n):
    if n < 4:
        return [0, 0, 2, 0][n]
    fib = [0, 0, 2, 0]
    for _ in range(4, n + 1):
        fib = fib[-3:] + [sum(fib)]
    return fib[-1]",not useful
"Handles small n directly; then iteratively shifts the list by one and appends the sum of the last three, which approximates but may not exactly match the sequence.","def fib4(n):
    if n < 4:
        return [0, 0, 2, 0][n]
    fib = [0, 0, 2, 0]
    for _ in range(4, n + 1):
        fib = fib[1:] + [sum(fib[-3:])]
    return fib[-1]",not useful
This function sorts the input list in place and returns the middle element for odd length or the average of the two middle elements for even length.,"def median(l):
    l.sort()
    n = len(l)
    return l[n//2] if n % 2 else (l[n//2 - 1] + l[n//2]) / 2",useful
"It sorts a copy of the list and computes the median as the average of the element at n//2 and the one at -(n//2 + 1), which works for both odd and even lengths.","def median(l):
    l = sorted(l)
    n = len(l)
    return (l[n//2] + l[-(n//2 + 1)]) / 2",useful
"Imports the statistics module and directly uses its median function to compute the median of the list, handling both odd and even lengths automatically.","import statistics
def median(l):
    return statistics.median(l)",useful
"Uses NumPy's median function after importing the library, providing a robust way to calculate the median for numerical lists.","import numpy as np
def median(l):
    return np.median(l)",useful
"Sorts the list in place, finds the middle index, and averages the middle element(s) using negative indexing for the lower middle in even cases.","def median(l):
    l.sort()
    mid = len(l) // 2
    return (l[mid] + l[-mid - 1]) / 2",useful
"Creates a sorted copy of the list, computes the middle index, and averages the two middle elements using negative indexing for even lengths.","def median(l):
    l = sorted(l)
    mid = len(l) // 2
    return (l[mid] + l[-mid - 1]) / 2",useful
"Implements an online median using two heaps (max-heap for lower half, min-heap for upper half) to maintain balance and compute the median efficiently without full sorting.","import heapq
def median(l):
    min_heap, max_heap = [], []
    for num in l:
        if not max_heap or num < -max_heap[0]:
            heapq.heappush(max_heap, -num)
        else:
            heapq.heappush(min_heap, num)
        if len(min_heap) > len(max_heap):
            heapq.heappush(max_heap, -heapq.heappop(min_heap))
        elif len(max_heap) > len(min_heap) + 1:
            heapq.heappush(min_heap, -heapq.heappop(max_heap))
    if len(min_heap) == len(max_heap):
        return (-max_heap[0] + min_heap[0]) / 2
    return -max_heap[0]",useful
"Sorts the list, then for odd length returns the middle element; for even, averages the two middle ones using a slice and sum.","def median(l):
    l = sorted(l)
    n = len(l)
    return l[n//2] if n % 2 else sum(l[n//2-1:n//2+1])/2",useful
"Sorts in place and returns the middle for odd n or the float average of two middles for even n, ensuring floating-point result.","def median(l):
    l.sort()
    n = len(l)
    return l[n//2] if n % 2 else (l[n//2 - 1] + l[n//2]) / 2.0",useful
Sorts a copy of the list and computes the median as the middle element or the float average of the two central elements.,"def median(l):
    l = sorted(l)
    n = len(l)
    return l[n//2] if n % 2 else (l[n//2 - 1] + l[n//2]) / 2.0",useful
This function checks if the string is a palindrome by comparing it to its reverse using slicing.,"def is_palindrome(text: str):
    return text == text[::-1]",useful
It verifies palindrome by checking if each character from the start matches the corresponding from the end using a generator expression up to half the length.,"def is_palindrome(text: str):
    return all(text[i] == text[-i-1] for i in range(len(text)//2))",useful
"Uses two pointers starting from ends of the string, moving inward while comparing characters, returning False on mismatch or True if all match.","def is_palindrome(text: str):
    i, j = 0, len(text) - 1
    while i < j:
        if text[i] != text[j]:
            return False
        i, j = i + 1, j - 1
    return True",useful
"Reverses the string using reversed() and join, then compares it to the original to check for palindrome.","def is_palindrome(text: str):
    return ''.join(reversed(text)) == text",useful
"Reverses the string and checks if the original starts with the reversed version, which only works correctly for single-character strings.","def is_palindrome(text: str):
    return text[::-1].startswith(text)",not useful
"Reverses the string and checks if the original ends with it, incorrectly identifying non-palindromes as true for certain lengths.","def is_palindrome(text: str):
    return text[::-1].endswith(text)",not useful
"Reverses the string and uses find to check if the original appears at position 0 in the reverse, which fails for most palindromes longer than 1.","def is_palindrome(text: str):
    return text[::-1].find(text) == 0",not useful
"Uses rfind on the reverse to locate the original starting at position 0, but this logic is flawed and won't correctly identify palindromes.","def is_palindrome(text: str):
    return text[::-1].rfind(text) == len(text) - len(text)",not useful
"Reverses the string and uses index to check if the original is at position 0, raising errors or failing for non-exact matches in palindromes.","def is_palindrome(text: str):
    return text[::-1].index(text) == 0",not useful
"Employs rindex on the reverse to find the original at offset 0, but this approach is incorrect for detecting palindromes beyond trivial cases.","def is_palindrome(text: str):
    return text[::-1].rindex(text) == len(text) - len(text)",not useful
This function computes 2 raised to the power n modulo p using Python's built-in pow function for efficient modular exponentiation.,"def modp(n: int, p: int):
    return pow(2, n, p)",useful
"Implements binary exponentiation iteratively: squares the base and halves the exponent, multiplying result when exponent bit is set, all modulo p.","def modp(n: int, p: int):
    result = 1
    base = 2
    while n > 0:
        if n % 2 == 1:
            result = (result * base) % p
        base = (base * base) % p
        n //= 2
    return result",useful
"Recursively computes 2^n mod p: for even n, squares the half-power mod p; for odd, multiplies 2 by (n-1) power mod p; base case n=0 returns 1.","def modp(n: int, p: int):
    if n == 0:
        return 1
    elif n % 2 == 0:
        half_power = modp(n // 2, p)
        return (half_power * half_power) % p
    else:
        return (2 * modp(n - 1, p)) % p",useful
"A recursive modular exponentiation for 2^n mod p, using exponentiation by squaring for even exponents and recursive multiplication for odd.","def modp(n: int, p: int):
    if n == 0:
        return 1
    elif n % 2 == 0:
        return modp(n // 2, p) ** 2 % p
    else:
        return 2 * modp(n - 1, p) % p",useful
"Uses left bit shift (1 << n) to compute 2^n, then takes modulo p, but may overflow for large n before modding.","def modp(n: int, p: int):
    return (1 << n) % p",useful
"Directly computes 2 ** n % p using Python's exponentiation operator, which handles large exponents but may be slow without mod during computation.","def modp(n: int, p: int):
    return 2 ** n % p",useful
"Efficiently calculates 2^n modulo p with the built-in pow function, which uses fast exponentiation.","def modp(n: int, p: int):
    return pow(2, n, p)",useful
"Computes 2 to the power n then applies modulo p, relying on Python's arbitrary-precision integers.","def modp(n: int, p: int):
    return (2 ** n) % p",useful
"Uses pow(2, n, p) for optimized modular exponentiation to find 2^n mod p.","def modp(n: int, p: int):
    return pow(2, n, p)",useful
"Calculates 2 ** n and takes the result modulo p, suitable for Python's handling of large numbers.","def modp(n: int, p: int):
    return (2 ** n) % p",useful
"This code implements a Caesar cipher for encoding and decoding strings by shifting lowercase letters by 5 positions forward and backward in the alphabet, using modulo 26 for wrapping and assuming all input characters are lowercase letters.","def encode_shift(s): return ''.join(chr((ord(ch) - 97 + 5) % 26 + 97) for ch in s)
def decode_shift(s): return ''.join(chr((ord(ch) - 97 - 5) % 26 + 97) for ch in s)",useful
"This function performs a Caesar cipher shift of 5 positions on strings, converting the input to lowercase first to handle both cases uniformly, and wraps around the alphabet using modulo 26.","def encode_shift(s): return ''.join(chr((ord(ch) - 97 + 5) % 26 + 97) for ch in s.lower())
def decode_shift(s): return ''.join(chr((ord(ch) - 97 - 5) % 26 + 97) for ch in s.lower())",useful
"The code encodes and decodes strings using a Caesar shift of 5 positions for lowercase letters, employing list comprehensions to transform each character via ordinal values and modulo 26 wrapping.","def encode_shift(s): return ''.join([chr(97 + (ord(ch) - 97 + 5) % 26) for ch in s])
def decode_shift(s): return ''.join([chr(97 + (ord(ch) - 97 - 5) % 26) for ch in s])",useful
"This solution uses map with a lambda function to apply a Caesar cipher shift of 5 to each lowercase letter in the string, joining the results and wrapping around the alphabet with modulo 26.","def encode_shift(s): return ''.join(map(lambda ch: chr((ord(ch) - 97 + 5) % 26 + 97), s))
def decode_shift(s): return ''.join(map(lambda ch: chr((ord(ch) - 97 - 5) % 26 + 97), s))",useful
"The code attempts a Caesar shift by adding 5 to characters before 'y' and keeping others unchanged for encoding, but uses invalid string addition; decoding subtracts 5 from characters after 'e'.","def encode_shift(s): return ''.join([chr(c) if c > 'y' else chr(c + 5) for c in s])
def decode_shift(s): return ''.join([chr(c) if c < 'f' else chr(c - 5) for c in s])",not useful
"This implements a Caesar cipher by adding 5 to letters before 'v' and subtracting 21 (to wrap around) for later letters in encoding, with the reverse logic for decoding, assuming lowercase input.","def encode_shift(s): return ''.join([chr(ord(ch) + 5) if ch < 'v' else chr(ord(ch) - 21) for ch in s])
def decode_shift(s): return ''.join([chr(ord(ch) - 5) if ch > 'e' else chr(ord(ch) + 21) for ch in s])",useful
"The function shifts lowercase letters by 5 positions using ordinal comparisons (118 for 'v'), adding 5 or subtracting 21 for wrapping in encoding, and reverses for decoding.","def encode_shift(s): return ''.join([chr(ord(ch) + 5) if ord(ch) < 118 else chr(ord(ch) - 21) for ch in s])
def decode_shift(s): return ''.join([chr(ord(ch) - 5) if ord(ch) > 101 else chr(ord(ch) + 21) for ch in s])",useful
"This Caesar cipher code shifts only lowercase letters by 5 positions, wrapping as needed, while preserving non-lowercase characters unchanged in both encoding and decoding.","def encode_shift(s): return ''.join([chr(ord(ch) + 5) if ch.islower() and ch < 'v' else chr(ord(ch) - 21) if ch.islower() else ch for ch in s])
def decode_shift(s): return ''.join([chr(ord(ch) - 5) if ch.islower() and ch > 'e' else chr(ord(ch) + 21) if ch.islower() else ch for ch in s])",useful
"The code applies a Caesar shift of 5 to alphabetic lowercase letters only, wrapping around the alphabet, and leaves non-alphabetic or uppercase characters unchanged.","def encode_shift(s): return ''.join([chr(ord(ch) + 5) if ch.isalpha() and ch.islower() and ch < 'v' else chr(ord(ch) - 21) if ch.isalpha() and ch.islower() else ch for ch in s])
def decode_shift(s): return ''.join([chr(ord(ch) - 5) if ch.isalpha() and ch.islower() and ch > 'e' else chr(ord(ch) + 21) if ch.isalpha() and ch.islower() else ch for ch in s])",useful
"This solution performs a precise Caesar shift of 5 on lowercase alphabetic characters, using conditional checks for wrapping (before 'v' add 5, after 'u' subtract 21), preserving others.","def encode_shift(s): return ''.join([chr(ord(ch) + 5) if ch.isalpha() and ch.islower() and ch < 'v' else chr(ord(ch) - 21) if ch.isalpha() and ch.islower() and ch > 'u' else ch for ch in s])
def decode_shift(s): return ''.join([chr(ord(ch) - 5) if ch.isalpha() and ch.islower() and ch > 'e' else chr(ord(ch) + 21) if ch.isalpha() and ch.islower() and ch < 'f' else ch for ch in s])",useful
"This function removes all vowels (a, e, i, o, u) from the text, handling both uppercase and lowercase by converting to lowercase for comparison.","def remove_vowels(text):
    return ''.join(c for c in text if c.lower() not in 'aeiou')",useful
"Using the str.translate method with maketrans, this efficiently removes both uppercase and lowercase vowels from the input text.","def remove_vowels(text):
    return text.translate(str.maketrans('', '', 'aeiouAEIOU'))",useful
"The code employs regular expressions with re.sub and IGNORECASE flag to replace all vowels (a, e, i, o, u) regardless of case with empty strings.","def remove_vowels(text):
    return re.sub(r'[aeiou]', '', text, flags=re.IGNORECASE)",useful
"This uses the filter function with a lambda to exclude characters whose lowercase form is a vowel, joining the remaining characters.","def remove_vowels(text):
    return ''.join(filter(lambda x: x.lower() not in 'aeiou', text))",useful
"The function iterates through the text with a generator expression, keeping only non-vowel characters by explicitly checking both cases.","def remove_vowels(text):
    return ''.join(c for c in text if c not in 'aeiouAEIOU')",useful
"Similar to a list comprehension, this generator expression joins characters that are not vowels, checking both uppercase and lowercase explicitly.","def remove_vowels(text):
    return ''.join(ch for ch in text if ch not in 'aeiouAEIOU')",useful
"This list comprehension removes vowels by converting each character to lowercase and checking against the vowel set, preserving case in output.","def remove_vowels(text):
    return ''.join([char for char in text if char.lower() not in 'aeiou'])",useful
"The code uses a generator to join non-vowel characters, explicitly excluding both uppercase and lowercase vowels while keeping others intact.","def remove_vowels(text):
    return ''.join(char for char in text if char not in 'aeiouAEIOU')",useful
"This generator expression filters out vowels by lowercasing each character for comparison, effectively removing them case-insensitively.","def remove_vowels(text):
    return ''.join(ch for ch in text if ch.lower() not in 'aeiou')",useful
"Using a list comprehension, the function excludes characters that match uppercase or lowercase vowels, joining the rest to form the output.","def remove_vowels(text):
    return ''.join(char for char in text if char not in 'aeiouAEIOU')",not useful
This function checks if all elements in the list are below the threshold using the built-in all() function with a generator expression.,"def below_threshold(l, t):
    return all(i < t for i in l)",useful
"By finding the maximum value in the list and comparing it to the threshold, this determines if every element is below the threshold.","def below_threshold(l, t):
    return max(l) < t",useful
"The code loops through the list, returning False if any element meets or exceeds the threshold, otherwise True after checking all.","def below_threshold(l, t):
    for i in l:
        if i >= t:
            return False
    return True",useful
It uses a generator to count elements at or above the threshold and returns True only if the count is zero.,"def below_threshold(l, t):
    return sum(i >= t for i in l) == 0",useful
"This creates a list of elements at or above the threshold and checks if its length is zero, indicating all are below.","def below_threshold(l, t):
    return len([i for i in l if i >= t]) == 0",useful
"Using the any() function negated, it returns True if no element in the list is at or above the threshold.","def below_threshold(l, t):
    return not any(i >= t for i in l)",useful
"The filter function with a lambda collects elements at or above the threshold, and the function returns True if the filtered list is empty.","def below_threshold(l, t):
    return len(list(filter(lambda x: x >= t, l))) == 0",useful
"This applies functools.reduce with a lambda to cumulatively check if each element is below the threshold, starting from True.","def below_threshold(l, t):
    return reduce(lambda x, y: x and y < t, l, True)",useful
"A recursive approach checks the minimum of the list and recurses on the tail, but incorrectly uses min < t; base case returns True for empty list.","def below_threshold(l, t):
    return min(l) < t and below_threshold(l[1:], t) if l else True",not useful
"By sorting the list and checking if the last (largest) element is below the threshold, this verifies all elements are below.","def below_threshold(l, t):
    return sorted(l)[-1] < t",useful
This simple function returns the sum of two integers x and y using the + operator.,"def add(x: int, y: int) -> int:
    return x + y",useful
"Defined as a lambda function, this concisely adds the two integer arguments x and y.","add = lambda x, y: x + y",useful
The function sums a list containing x and y to compute their addition.,"def add(x: int, y: int) -> int:
    return sum([x, y])",useful
"Using functools.reduce and operator.add on a list of x and y, this performs the addition.","def add(x: int, y: int) -> int:
    return functools.reduce(operator.add, [x, y])",useful
This leverages NumPy's add function to compute the sum of x and y (requires NumPy import).,"def add(x: int, y: int) -> int:
    return np.add(x, y)",useful
The code calls the __add__ method on x with y as the argument to perform addition.,"def add(x: int, y: int) -> int:
    return x.__add__(y)",useful
"This uses eval to dynamically evaluate the string expression '{x} + {y}' for addition, which is functional but potentially unsafe.","def add(x: int, y: int) -> int:
    return eval(f""{x} + {y}"")",useful
"It explicitly converts x and y to integers before adding them, ensuring type safety.","def add(x: int, y: int) -> int:
    return int(x) + int(y)",not useful
"This attempts bitwise addition using XOR, AND, and shift operations, but the formula is incorrect for general integer addition.","def add(x: int, y: int) -> int:
    return x | y + (x & y) << 1",not useful
"Implementing bitwise addition without carry propagation loop, it simulates binary addition using XOR for sum and AND-shift for carry until no carry remains.","def add(x: int, y: int) -> int:
    while y != 0:
        carry = x & y
        x = x ^ y
        y = carry << 1
    return x",useful
"This checks if two strings have the same unique characters by comparing their sets, ignoring frequencies and order.","def same_chars(s0: str, s1: str) -> bool:
    return set(s0) == set(s1)",not useful
"Using collections.Counter, the function verifies if both strings have identical character frequencies, confirming they are anagrams.","def same_chars(s0: str, s1: str) -> bool:
    return Counter(s0) == Counter(s1)",useful
"By sorting both strings and comparing the results, this determines if they contain the same characters with the same frequencies.","def same_chars(s0: str, s1: str) -> bool:
    return sorted(s0) == sorted(s1)",useful
The code uses collections.Counter to compare the frequency counts of characters in both strings for anagram verification.,"def same_chars(s0: str, s1: str) -> bool:
    return collections.Counter(s0) == collections.Counter(s1)",useful
"It first checks equal lengths, then ensures no characters in s0 are missing from s1 using set difference, but ignores frequencies.","def same_chars(s0: str, s1: str) -> bool:
    return len(s0) == len(s1) and not (set(s0) - set(s1))",not useful
"After verifying equal lengths, it checks that every character in s0 appears the same number of times in s1 using count().","def same_chars(s0: str, s1: str) -> bool:
    return len(s0) == len(s1) and all(s0.count(c) == s1.count(c) for c in s0)",useful
"This confirms equal lengths and that each unique character in s0 has the same count in s1, efficiently using set(s0).","def same_chars(s0: str, s1: str) -> bool:
    return len(s0) == len(s1) and all(s0.count(c) == s1.count(c) for c in set(s0))",useful
"Using Counter intersection, it checks if the common characters match s0's counter exactly, implying same frequencies if lengths equal (but length not checked).","def same_chars(s0: str, s1: str) -> bool:
    return collections.Counter(s0) & collections.Counter(s1) == collections.Counter(s0)",not useful
"The function compares if s0's character frequencies are a subset of s1's using items() <=, but requires equal lengths for full anagram check (not included).","def same_chars(s0: str, s1: str) -> bool:
    return collections.Counter(s0).items() <= collections.Counter(s1).items()",not useful
"By subtracting counters and checking if the result is empty, this verifies that s0's characters are fully covered by s1's frequencies (assumes equal lengths for anagrams).","def same_chars(s0: str, s1: str) -> bool:
    return not (collections.Counter(s0) - collections.Counter(s1))",not useful
"This function computes the nth Fibonacci number iteratively by initializing two variables to 0 and 1, then repeatedly updating them through n iterations to generate the sequence without recursion.","def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a",useful
"This implements Binet's closed-form formula using the golden ratio to approximate the nth Fibonacci number, but floating-point precision may cause inaccuracies for larger n.","def fib(n):
    return ((1 + 5 ** 0.5) / 2) ** n / 5 ** 0.5",not useful
This uses Binet's formula to calculate the nth Fibonacci number and applies rounding to obtain the nearest integer value.,"def fib(n):
    return round(((1 + 5 ** 0.5) / 2) ** n / 5 ** 0.5)",useful
This applies Binet's formula for the nth Fibonacci number and uses integer conversion with an added 0.5 for rounding towards the nearest integer.,"def fib(n):
    return int(((1 + 5 ** 0.5) / 2) ** n / 5 ** 0.5 + 0.5)",useful
This computes the nth Fibonacci number via Binet's formula and truncates the floating-point result to the nearest lower integer.,"def fib(n):
    return int(((1 + 5 ** 0.5) / 2) ** n / 5 ** 0.5)",not useful
This uses Binet's formula to approximate the nth Fibonacci number and converts the result to an integer by truncation.,"def fib(n):
    return int((((1 + 5 ** 0.5) / 2) ** n) / 5 ** 0.5)",not useful
"This implements Binet's formula with explicit parentheses for the nth Fibonacci number, truncating to an integer.","def fib(n):
    return int((((1 + 5 ** 0.5) / 2) ** n) / (5 ** 0.5))",not useful
"This attempts Binet's formula but incorrectly divides by sqrt(10) instead of sqrt(5), resulting in inaccurate Fibonacci approximations converted to integers.","def fib(n):
    return int((((1 + 5 ** 0.5) / 2) ** n) / (2 ** 0.5 * 5 ** 0.5))",not useful
"This modifies Binet's formula by dividing by an erroneous denominator (sqrt(10) + 0.5), leading to incorrect integer results for Fibonacci numbers.","def fib(n):
    return int((((1 + 5 ** 0.5) / 2) ** n) / (2 ** 0.5 * 5 ** 0.5 + 0.5))",not useful
"This uses a flawed version of Binet's formula with denominator sqrt(10) - 0.5, producing inaccurate integer approximations of the nth Fibonacci number.","def fib(n):
    return int((((1 + 5 ** 0.5) / 2) ** n) / (2 ** 0.5 * 5 ** 0.5 - 0.5))",not useful
"This function checks if the count of opening brackets '<' equals the count of closing brackets '>', but does not verify proper ordering or nesting.","def correct_bracketing(brackets: str):
    return brackets.count(""<"") == brackets.count("">"")",not useful
"This iterates through the string, counting occurrences of '<' and '>', and returns true only if the counts are equal, ignoring sequence validity.","def correct_bracketing(brackets: str):
    open_count = close_count = 0
    for b in brackets:
        if b == ""<"":
            open_count += 1
        elif b == "">"":
            close_count += 1
    return open_count == close_count",not useful
"This uses a stack to push '<' and pop on '>', returning false if a '>' appears without a matching '<' or if unmatched '<' remain, ensuring balanced nesting.","def correct_bracketing(brackets: str):
    stack = []
    for b in brackets:
        if b == ""<"":
            stack.append(b)
        elif b == "">"" and stack:
            stack.pop()
        else:
            return False
    return not stack",useful
"This repeatedly replaces matched pairs '<>' with empty strings until none remain, returning true if the final string is empty, indicating balanced brackets.","def correct_bracketing(brackets: str):
    while ""<>"" in brackets:
        brackets = brackets.replace(""<>"", """")
    return not brackets",useful
"This maintains a balance counter, incrementing for '<' and decrementing for '>', ensuring it never goes negative and ends at zero for correct bracketing.","def correct_bracketing(brackets: str):
    diff = 0
    for b in brackets:
        diff += 1 if b == ""<"" else -1
        if diff < 0:
            return False
    return diff == 0",useful
"This computes the total balance by summing +1 for '<' and -1 for '>', returning true if the sum is zero, but ignores ordering.","def correct_bracketing(brackets: str):
    return sum(1 if b == ""<"" else -1 for b in brackets) == 0",not useful
"This removes all '<' and '>' characters using string translation and checks if the result is empty, verifying only the presence of brackets without balance check.","def correct_bracketing(brackets: str):
    return brackets.translate(str.maketrans(""<>"", """")) == """"",not useful
"This repeatedly checks if the count of '<' equals '>', but the 'all()' wrapper makes it ineffective for balance verification.","def correct_bracketing(brackets: str):
    return all(brackets.count(""<"") == brackets.count("">""))",not useful
"This replaces all '<' and then '>' with empty strings and checks if the length is zero, confirming only that the string consists solely of brackets without balance.","def correct_bracketing(brackets: str):
    return len(brackets.replace(""<"", """").replace("">"", """")) == 0",not useful
"This uses accumulate to track running balance (+1 for '<', -1 for '>'), returning true if no prefix sum is negative, but omits final balance check.","def correct_bracketing(brackets: str):
    return not any(i < 0 for i in accumulate(1 if b == ""<"" else -1 for b in brackets))",not useful
This checks if the list is non-decreasing (all x <= y) or non-increasing (all x >= y) by comparing consecutive elements.,"def monotonic(l):
    return all(x<=y for x, y in zip(l, l[1:])) or all(x>=y for x, y in zip(l, l[1:]))",useful
"This verifies if the list equals its sorted version (increasing) or reverse-sorted version (decreasing), confirming monotonicity.","def monotonic(l):
    return l == sorted(l) or l == sorted(l, reverse=True)",useful
"This computes differences between consecutive elements and checks if all are non-negative or all non-positive, indicating monotonicity.","def monotonic(l):
    diff = [a-b for a, b in zip(l, l[1:])]
    return all(i >= 0 for i in diff) or all(i <= 0 for i in diff)",useful
This iterates through indices to check if all consecutive pairs are non-decreasing or all non-increasing.,"def monotonic(l):
    return (all(l[i] <= l[i + 1] for i in range(len(l) - 1)) or
            all(l[i] >= l[i + 1] for i in range(len(l) - 1)))",useful
"This generates boolean comparisons (x < y) for consecutive pairs and checks if the set has at most one unique value, detecting strictly monotonic sequences but failing on equals.","def monotonic(l):
    return len(set(x<y for x, y in zip(l, l[1:]))) <= 1",not useful
"This uses reduce to build lists conditionally for increasing or decreasing order, comparing the result to the original to verify monotonicity, though overly complex.","def monotonic(l):
    return reduce(lambda a, b: a if (a and (a[-1] <= b)) else (a + [b]), l[1:], l[:1]) == l or reduce(lambda a, b: a if (a and (a[-1] >= b)) else (a + [b]), l[1:], l[:1]) == l",not useful
"This checks if the list is contained in a list of its sorted and reverse-sorted versions, effectively verifying equality for monotonicity.","def monotonic(l):
    return l in [sorted(l), sorted(l, reverse=True)]",useful
This compares the list to its sorted version or the reversed sorted version to determine if it is monotonic increasing or decreasing.,"def monotonic(l):
    return l == list(sorted(l)) or l == list(reversed(sorted(l)))",useful
"This checks equality with the first len(l) elements of sorted(l) or reverse-sorted(l), which is equivalent to full sorted comparison for monotonicity.","def monotonic(l):
    return l == sorted(l)[:len(l)] or l == sorted(l, reverse=True)[:len(l)]",useful
"This uses zip to compare consecutive elements, returning true if all pairs satisfy a <= b or all a >= b, confirming non-strict monotonicity.","def monotonic(l):
    return all(a <= b for a, b in zip(l, l[1:])) or all(a >= b for a, b in zip(l, l[1:]))",useful
This finds the intersection of sets from both lists and returns the sorted unique common elements.,"def common(l1, l2):
    return sorted(set(l1) & set(l2))",useful
"This computes the set intersection between set(l1) and l2, converts to list, and sorts the common elements.","def common(l1, l2):
    return sorted(list(set(l1).intersection(l2)))",useful
"This filters unique elements from l1 that exist in l2 using a lambda, then sorts the resulting common elements list.","def common(l1, l2):
    return sorted(list(filter(lambda x: x in l2, set(l1))))",useful
"This uses a list comprehension to select unique elements from l1 present in l2, then sorts them to get common elements.","def common(l1, l2):
    return sorted([x for x in set(l1) if x in l2])",useful
This performs set intersection on sets of both lists and returns the sorted unique common elements.,"def common(l1, l2):
    return sorted(set(l1).intersection(set(l2)))",useful
"This finds the set intersection of l1 and l2, converts to a list, and sorts the common unique elements.","def common(l1, l2):
    return sorted(list(set(l1) & set(l2)))",useful
"This uses the intersection method on sets from both lists, converts to a sorted list of unique common elements.","def common(l1, l2):
    return sorted(list(set(l1).intersection(set(l2))))",useful
"This computes the bitwise AND on sets of l1 and l2, lists and sorts the unique common elements.","def common(l1, l2):
    return sorted(list(set(l1) & set(l2)))",not useful
"This intersects set(l1) with l2 directly, converts to a sorted list of unique common elements.","def common(l1, l2):
    return sorted(list(set(l1).intersection(l2)))",useful
"This finds common unique elements via set intersection of l1 and l2, then sorts the resulting list.","def common(l1, l2):
    return sorted(list(set(l1) & set(l2)))",useful
"This repeatedly divides n by the smallest integer i starting from 2 while i squared <= n, returning the remaining n as the largest prime factor.","def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",useful
"This handles even factors by dividing by 2 first, then checks odd divisors from 3, returning the remaining n if greater than 2 or the last odd divisor otherwise.","def largest_prime_factor(n):
    while n % 2 == 0:
        n = n // 2
    i = 3
    while i * i <= n:
        while n % i == 0:
            n = n // i
        i += 2
    if n > 2:
        return n
    else:
        return i - 2",not useful
"This tracks the maximum prime factor found while dividing n by divisors up to sqrt(n), updating it with each factor and the final n if prime.","def largest_prime_factor(n):
    i = 2
    max_prime = -1
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            max_prime = i
    if n > 2:
        max_prime = n
    return max_prime",not useful
"This divides n by divisors up to sqrt(n), then returns i if n is fully factored to 1, otherwise the remaining n as the largest prime factor.","def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return i if n == 1 else n",not useful
"This performs trial division up to sqrt(n), returning the remaining n if greater than 1, or i-1 otherwise, aiming for the largest prime factor.","def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n if n > 1 else i - 1",not useful
"This divides n by increasing i up to sqrt(n), then returns i if it exceeds the remaining n, otherwise n, to identify the largest prime factor.","def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return i if i > n else n",not useful
"This exhaustively divides n by each i up to sqrt(n) while possible, then returns the remaining n, which may be 1 if fully factored.","def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        while n % i == 0:
            n //= i
        i += 1
    return n",not useful
"This optimizes for odd divisors after 2 by stepping i by 2, dividing multiples, and returns the remaining n as the largest prime factor.","def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        while n % i == 0:
            n //= i
        i += 1 if i == 2 else 2
    return n",not useful
"This divides n by each i up to sqrt(n) completely, then returns i if n is 1 (indicating full factorization), else the remaining n.","def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        while n % i == 0:
            n //= i
        i += 1
    return i if n == 1 else n",not useful
"This performs trial division up to sqrt(n), returning i if i > 2 or the remaining n, attempting to find the largest prime factor.","def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        while n % i == 0:
            n //= i
        i += 1
    return i if i > 2 else n",not useful
This function computes the sum of integers from 1 to n using the closed-form formula n*(n+1)/2 with integer division for efficiency.,def sum_to_n(n: int): return n * (n + 1) // 2,useful
"This function sums the integers from 0 to n using the built-in sum function on a range object, effectively calculating the sum from 1 to n since adding 0 does not change the result.",def sum_to_n(n: int): return sum(range(n + 1)),useful
This function creates a list of integers from 1 to n using a list comprehension and then sums them with the built-in sum function.,"def sum_to_n(n: int): return sum([i for i in range(1, n + 1)])",useful
This function uses a generator expression to yield integers from 1 to n and sums them efficiently with the built-in sum function without creating an intermediate list.,"def sum_to_n(n: int): return sum(i for i in range(1, n + 1))",useful
This function applies the reduce function with a lambda to cumulatively add integers from 1 to n generated by range.,"def sum_to_n(n: int): return reduce(lambda x, y: x + y, range(1, n + 1))",not useful
"This function uses itertools.count to generate an infinite sequence starting from 1, slices the first n numbers with islice, and sums them.","def sum_to_n(n: int): return sum(itertools.islice(itertools.count(1), n))",not useful
This function calculates the sum using the formula n*(n+1) and performs integer division by 2 via a right bit shift operation.,def sum_to_n(n: int): return n * (n + 1) >> 1,useful
This function computes the sum of integers from 1 to n using the equivalent closed-form formula (n+1)*n//2.,def sum_to_n(n: int): return (n + 1) * n // 2,useful
This function uses the standard arithmetic series formula (n * (n + 1)) // 2 to efficiently sum integers from 1 to n.,def sum_to_n(n: int): return (n * (n + 1)) // 2,useful
This function applies the closed-form formula (n + 1) * n // 2 to calculate the sum of the first n natural numbers.,def sum_to_n(n: int): return (n + 1) * n // 2,useful
"This function uses a counter to track open parentheses, decrementing for closes and returning False if it goes negative, finally checking if it returns to zero for balance.","def correct_bracketing(brackets: str):
    count = 0
    for b in brackets:
        if b == '(':
            count += 1
        elif b == ')':
            count -= 1
            if count < 0:
                return False
    return count == 0",useful
"This function employs a stack to push opening parentheses and pop on closing ones, returning True if the stack is empty at the end and no premature closes occur.","def correct_bracketing(brackets: str):
    stack = []
    for b in brackets:
        if b == '(':
            stack.append(b)
        elif b == ')':
            if not stack:
                return False
            stack.pop()
    return not stack",useful
"This function repeatedly replaces matched '()' pairs with empty strings until none remain, returning True if the string becomes empty.","def correct_bracketing(brackets: str):
    while '()' in brackets:
        brackets = brackets.replace('()', '')
    return not brackets",useful
This function simply counts the number of '(' and ')' characters and returns True if they are equal.,"def correct_bracketing(brackets: str):
    return brackets.count('(') == brackets.count(')')",not useful
"This function counts the occurrences of '(' and ')' using generator expressions and sum, returning True if the counts match.","def correct_bracketing(brackets: str):
    open_count = sum(1 for b in brackets if b == '(')
    close_count = sum(1 for b in brackets if b == ')')
    return open_count == close_count",not useful
"This function removes all '(' and ')' characters using string translation and checks if the resulting string is empty, verifying only brackets are present.","def correct_bracketing(brackets: str):
    return brackets.translate(str.maketrans('', '', '()')) == ''",not useful
This function uses regular expression substitution to remove all '()' pairs and checks if the resulting string is empty.,"def correct_bracketing(brackets: str):
    return len(re.sub(r'\(\)', '', brackets)) == 0",not useful
"This function checks if the count of '(' equals the count of ')' for the entire string, repeated unnecessarily for each character.","def correct_bracketing(brackets: str):
    return all(brackets.count('(') == brackets.count(')') for _ in brackets)",not useful
"This function uses reduce to apply +1 for '(' and -1 for ')', accumulating the difference and checking if it equals zero at the end.","def correct_bracketing(brackets: str):
    return reduce(lambda x, y: x + (1 if y == '(' else -1), brackets, 0) == 0",not useful
"This function computes the net balance by summing +1 for each '(' and -1 for each ')', returning True if the total is zero.","def correct_bracketing(brackets: str):
    return sum(1 if b == '(' else -1 for b in brackets) == 0",not useful
This function computes polynomial derivative coefficients by multiplying each coefficient by its index and slicing off the first (constant term) element.,"def derivative(xs):
    return [i * x for i, x in enumerate(xs)][1:]",useful
"This function generates derivative coefficients by multiplying each coefficient xs[i] by i for i > 0, skipping the constant term.","def derivative(xs):
    return [x * i for i, x in enumerate(xs) if i > 0]",useful
"This function uses map to multiply each xs[i] by i for i from 1 to len(xs)-1, creating the list of derivative coefficients.","def derivative(xs):
    return list(map(lambda i: i * xs[i], range(1, len(xs))))",useful
"This function uses enumerate on xs[1:] starting from index 1 to directly multiply each coefficient by its power, producing the derivative coefficients.","def derivative(xs):
    return [x * i for i, x in enumerate(xs[1:], start=1)]",useful
"This function multiplies coefficients by their indices, filters out the zero index, and slices from the second element to get derivative terms.","def derivative(xs):
    return [i * x for i, x in enumerate(xs) if i][1:]",not useful
"This function computes derivative coefficients by multiplying each xs[i] by i, excluding the i=0 term.","def derivative(xs):
    return [x * i for i, x in enumerate(xs) if i != 0]",useful
"This function generates the derivative by multiplying each coefficient by its positive index, skipping the constant term.","def derivative(xs):
    return [i * x for i, x in enumerate(xs) if i > 0]",useful
"This function multiplies coefficients by indices and slices from the first to the last element, effectively including all but the constant.","def derivative(xs):
    return [i * x for i, x in enumerate(xs)][1:len(xs)]",useful
"This function creates index-coefficient pairs, filters non-zero indices, and slices from the second to obtain derivative coefficients.","def derivative(xs):
    return [i * x for i, x in enumerate(xs) if i][1:]",not useful
"This function multiplies each coefficient by its index, excluding the i=0 case to produce the derivative coefficients.","def derivative(xs):
    return [i * x for i, x in enumerate(xs) if i != 0]",useful
"This function iteratively computes the nth term of the tribonacci sequence starting with 0,0,1 by updating three variables in a loop from 2 to n.","def fibfib(n):
    a, b, c = 0, 0, 1
    for _ in range(2, n):
        a, b, c = b, c, a + b + c
    return c",not useful
"This function preallocates a list for the tribonacci sequence with initial values 0,0,1 and fills it iteratively by summing the last three terms up to index n.","def fibfib(n):
    fib = [0, 0, 1] + [0] * (n - 2)
    for i in range(3, n + 1):
        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3]
    return fib[n]",useful
This function handles base cases for n<3 and then iteratively updates three variables to compute the nth tribonacci term by summing the previous three.,"def fibfib(n):
    if n < 3:
        return [0, 0, 1][n]
    a, b, c = 0, 0, 1
    for _ in range(n - 2):
        a, b, c = b, c, a + b + c
    return c",useful
"This function manages base cases for n=0,1,2 and then uses a loop with three variables to iteratively sum the previous three terms for the nth value.","def fibfib(n):
    if n == 0:
        return 0
    elif n == 1 or n == 2:
        return 1 if n == 2 else 0
    else:
        a, b, c = 0, 0, 1
        for _ in range(n - 2):
            a, b, c = b, c, a + b + c
        return c",useful
"This function builds a list starting with [0,0,1] and appends the sum of the last three elements until the list length exceeds n, returning the nth term.","def fibfib(n):
    fib = [0, 0, 1]
    while len(fib) <= n:
        fib.append(sum(fib[-3:]))
    return fib[n]",useful
"This function initializes a list with [0,0,1] and appends the sum of the last three elements n-2 times to compute the nth tribonacci number.","def fibfib(n):
    fib = [0, 0, 1]
    for _ in range(n - 2):
        fib.append(sum(fib[-3:]))
    return fib[n]",useful
"This function handles base cases for n<2 and n=2, then builds a list by appending sums of the last three elements n-2 times, returning the last one.","def fibfib(n):
    if n < 2:
        return 0
    elif n == 2:
        return 1
    else:
        fib = [0, 0, 1]
        for _ in range(n - 2):
            fib.append(sum(fib[-3:]))
        return fib[-1]",useful
"This function starts with a list [0,0,1] and appends the sum of the last three elements n-2 times, returning the nth index value.","def fibfib(n):
    fib = [0, 0, 1]
    for _ in range(n - 2):
        fib.append(fib[-1] + fib[-2] + fib[-3])
    return fib[n]",useful
"This function uses base cases for n<3, initializes a list [0,0,1], appends sums of last three n-2 times, and returns the last element.","def fibfib(n):
    if n < 3:
        return [0, 0, 1][n]
    fib = [0, 0, 1]
    for _ in range(n - 2):
        fib.append(fib[-1] + fib[-2] + fib[-3])
    return fib[-1]",useful
"This function builds the tribonacci sequence in a list starting from [0,0,1] by appending the sum of the last three elements n-2 times and returns the nth term.","def fibfib(n):
    fib = [0, 0, 1]
    for _ in range(n - 2):
        fib.append(fib[-3] + fib[-2] + fib[-1])
    return fib[n]",useful
This function counts vowels in the lowercase string by summing occurrences of aeiou and conditionally including 'y' only if it is the last character of the original string.,"def vowels_count(s):
    return sum(1 for c in s.lower() if c in 'aeiou' or (c == 'y' and s[-1] == 'y'))",not useful
This function uses a generator expression to sum 1 for each lowercase character that is a vowel or 'y' if the string ends with 'y'.,"def vowels_count(s):
    return sum(c in 'aeiou' or (c == 'y' and s[-1] == 'y') for c in s.lower())",not useful
"This function counts vowels using a set for quick lookup of aeiou and adds 'y' conditionally if it is the last character, via a generator and sum.","def vowels_count(s):
    vowels = set('aeiou')
    return sum(c in vowels or (c == 'y' and s[-1] == 'y') for c in s.lower())",not useful
This function sums the counts of each lowercase vowel in the string and adds 1 if the last character is lowercase 'y'.,"def vowels_count(s):
    vowels = 'aeiou'
    return sum(s.lower().count(v) for v in vowels) + (s[-1].lower() == 'y')",not useful
"This function lowers the string and manually sums the counts of 'a','e','i','o','u', plus 1 if it ends with 'y'.","def vowels_count(s):
    s = s.lower()
    return s.count('a') + s.count('e') + s.count('i') + s.count('o') + s.count('u') + (s[-1] == 'y')",not useful
"This function lowers the string, sums the counts of vowels using map and count, and adds 1 if it ends with 'y'.","def vowels_count(s):
    s = s.lower()
    return sum(map(s.count, 'aeiou')) + (s[-1] == 'y')",not useful
"This function lowers the string, creates a list of vowels plus 'y' if ending with 'y', and returns its length (though this counts positions, not actual 'y' occurrences).","def vowels_count(s):
    s = s.lower()
    return len([c for c in s if c in 'aeiou'] + ['y'] if s[-1] == 'y' else [])",not useful
"This function lowers the string and uses filter with a lambda to count characters that are vowels or 'y' if the string ends with 'y', returning the filtered list length.","def vowels_count(s):
    s = s.lower()
    return len(list(filter(lambda c: c in 'aeiou' or (c == 'y' and s[-1] == 'y'), s)))",not useful
"This function lowers the string and counts characters in 'aeiouy' via list comprehension, excluding 'y' unless it is the last character.","def vowels_count(s):
    s = s.lower()
    return len([c for c in s if c in 'aeiouy' and (c != 'y' or s[-1] == 'y')])",not useful
"This function lowers the string and uses a list comprehension to count vowels plus 'y' occurrences only if the string ends with 'y', returning the list length.","def vowels_count(s):
    s = s.lower()
    return len([c for c in s if c in 'aeiou' or c == 'y' and s.endswith('y')])",not useful
"This function converts the input number x to a string and performs a right circular shift by the specified shift positions; if shift is greater than or equal to the string length, it returns the reversed string.","def circular_shift(x, shift):
    s = str(x)
    return s[-shift:] + s[:-shift] if shift < len(s) else s[::-1]",not useful
"This function converts the input number x to a string and performs a left circular shift by the specified shift positions; if shift is greater than or equal to the string length, it returns the reversed string.","def circular_shift(x, shift):
    s = str(x)
    return (s[shift:] + s[:shift]) if shift < len(s) else s[::-1]",not useful
"This function converts the input number x to a string and performs a left circular shift by the specified shift positions; if shift is greater than or equal to the string length, it returns the reversed string.","def circular_shift(x, shift):
    s = str(x)
    return s[shift:] + s[:shift] if shift < len(s) else s[::-1]",not useful
"This function converts the input number x to a string and performs a right circular shift by the specified shift positions; if shift is greater than or equal to the string length, it returns the reversed string.","def circular_shift(x, shift):
    s = str(x)
    return s[-shift:] + s[:-shift] if shift < len(s) else s[::-1]",not useful
"This function converts the input number x to a string and performs a left circular shift by the specified shift positions; if shift is greater than or equal to the string length, it returns the reversed string.","def circular_shift(x, shift):
    s = str(x)
    return s[shift:] + s[:shift] if shift < len(s) else s[::-1]",not useful
"This function converts the input number x to a string and performs a right circular shift by the specified shift positions; if shift is greater than or equal to the string length, it returns the reversed string.","def circular_shift(x, shift):
    s = str(x)
    return s[-shift:] + s[:-shift] if shift < len(s) else s[::-1]",not useful
"This function converts the input number x to a string and performs a left circular shift by the specified shift positions; if shift is greater than or equal to the string length, it returns the reversed string.","def circular_shift(x, shift):
    s = str(x)
    return s[shift:] + s[:shift] if shift < len(s) else s[::-1]",not useful
"This function converts the input number x to a string and performs a right circular shift by the specified shift positions; if shift is greater than or equal to the string length, it returns the reversed string.","def circular_shift(x, shift):
    s = str(x)
    return s[-shift:] + s[:-shift] if shift < len(s) else s[::-1]",not useful
"This function converts the input number x to a string and performs a left circular shift by the specified shift positions; if shift is greater than or equal to the string length, it returns the reversed string.","def circular_shift(x, shift):
    s = str(x)
    return s[shift:] + s[:shift] if shift < len(s) else s[::-1]",not useful
"This function converts the input number x to a string and performs a right circular shift by the specified shift positions; if shift is greater than or equal to the string length, it returns the reversed string.","def circular_shift(x, shift):
    s = str(x)
    return s[-shift:] + s[:-shift] if shift < len(s) else s[::-1]",not useful
This function sums the ASCII values of all uppercase letters in the input string s using a generator expression and the sum function.,"def digitSum(s):
    return sum(ord(c) for c in s if c.isupper())",useful
This function uses map and filter to sum the ASCII values of uppercase letters in the input string s by applying ord to filtered uppercase characters.,"def digitSum(s):
    return sum(map(ord, filter(str.isupper, s)))",useful
This function sums the ASCII values of characters in the input string s that fall within the uppercase range 'A' to 'Z' using a generator expression.,"def digitSum(s):
    return sum(ord(c) for c in s if 'A' <= c <= 'Z')",useful
This function sums the ASCII values of characters in the input string s that are between 'A' and 'Z' inclusive using a generator expression with explicit comparisons.,"def digitSum(s):
    return sum(ord(c) for c in s if c >= 'A' and c <= 'Z')",useful
"This function sums the ASCII values of all non-lowercase characters in the input string s, which includes uppercase letters but may include others if not strictly alphabetic.","def digitSum(s):
    return sum(ord(c) for c in s if c.islower() is False)",not useful
"This function sums the ASCII values of alphabetic characters in the input string s that are uppercase, using isalpha and isupper checks in a generator expression.","def digitSum(s):
    return sum(ord(c) for c in s if c.isalpha() and c.isupper())",useful
"This function sums the ASCII values of alphabetic characters in the input string s that are not equal to their lowercase version, identifying uppercase letters.","def digitSum(s):
    return sum(ord(c) for c in s if c.isalpha() and c != c.lower())",useful
"This function sums the ASCII values of alphabetic characters in the input string s that remain unchanged when converted to uppercase, confirming they are already uppercase.","def digitSum(s):
    return sum(ord(c) for c in s if c.isalpha() and c.upper() == c)",useful
"This function sums the ASCII values of alphabetic characters in the input string s whose lowercase version differs from the original, indicating uppercase letters.","def digitSum(s):
    return sum(ord(c) for c in s if c.isalpha() and c.lower() != c)",useful
"This function sums the ASCII values of alphabetic characters in the input string s that are equal to their swapcase version, which identifies uppercase letters.","def digitSum(s):
    return sum(ord(c) for c in s if c.isalpha() and c.swapcase() == c)",not useful
This function parses the input string s to extract the number of apples and oranges using string splitting and returns the difference from n.,"def fruit_distribution(s, n):
    a, o = map(int, s.split(' apples and ')[0], s.split(' oranges')[0].split()[-1])
    return n - a - o",not useful
This function uses regular expressions to find all numeric values in the input string s and computes n minus their sum to get the remaining fruits.,"import re
def fruit_distribution(s, n):
    a, o = map(int, re.findall(r'\d+', s))
    return n - a - o",useful
"This function splits the input string s into words and extracts the first and sixth words as integers for apples and oranges, then returns n minus their sum.","def fruit_distribution(s, n):
    a = int(s.split()[0])
    o = int(s.split()[5])
    return n - a - o",not useful
"This function filters digits from the first and sixth words of the split input string s to extract apple and orange counts, then returns n minus their sum.","def fruit_distribution(s, n):
    a = int(''.join(filter(str.isdigit, s.split()[0])))
    o = int(''.join(filter(str.isdigit, s.split()[5])))
    return n - a - o",not useful
"This function extracts all digits from the entire string s for apples and from the sixth word for oranges, then returns n minus their sum.","def fruit_distribution(s, n):
    a = int(''.join(c for c in s if c.isdigit()))
    o = int(''.join(c for c in s.split()[5] if c.isdigit()))
    return n - a - o",not useful
"This function splits the input string s and collects all numeric words as integers for apples and oranges, then returns n minus their sum.","def fruit_distribution(s, n):
    a, o = [int(i) for i in s.split() if i.isdigit()]
    return n - a - o",useful
"This function splits the input string s, collects numeric words as integers, and returns n minus the sum of apples and oranges using a list sum.","def fruit_distribution(s, n):
    a, o = [int(x) for x in s.split() if x.isdigit()]
    return n - sum([a, o])",useful
"This function splits the input string s and collects numeric words as integers for apples and oranges, then returns n minus their sum.","def fruit_distribution(s, n):
    a, o = [int(c) for c in s.split() if c.isdigit()]
    return n - a - o",useful
"This function splits the input string s and uses map with filter to convert numeric words to integers for apples and oranges, then returns n minus their sum.","def fruit_distribution(s, n):
    a, o = map(int, filter(str.isdigit, s.split()))
    return n - a - o",useful
"This function splits the input string s, collects numeric words into a list, maps them to integers, and returns n minus the sum of apples and oranges.","def fruit_distribution(s, n):
    a, o = map(int, [i for i in s.split() if i.isdigit()])
    return n - a - o",useful
"This function iterates through the array to find the smallest even value and its index, initializing with infinity, and returns the pair or an empty list if none found.","def pluck(arr):
    min_val, min_idx = float('inf'), -1
    for i, val in enumerate(arr):
        if val % 2 == 0 and val < min_val:
            min_val, min_idx = val, i
    return [min_val, min_idx] if min_idx != -1 else []",useful
"This function creates a list of even values with their indices, then uses min with a key to select the one with smallest value and then smallest index, or empty list if none.","def pluck(arr):
    evens = [(val, i) for i, val in enumerate(arr) if val % 2 == 0]
    return min(evens, key=lambda x: (x[0], x[1])) if evens else []",useful
"This function uses min on a generator of even values with indices from enumerate, returning the smallest pair or empty list if the array is empty.","def pluck(arr):
    return min((val, i) for i, val in enumerate(arr) if val % 2 == 0) if arr else []",not useful
"This function finds the minimum even value first, then uses next to get the first occurrence's value and index pair, or empty list if none.","def pluck(arr):
    return next((val, i) for i, val in enumerate(arr) if val % 2 == 0 and val == min(x for x in arr if x % 2 == 0)) if arr else []",not useful
"This function uses min on filtered enumerate pairs where the value is even, with a default empty list, implicitly selecting the smallest value and index.","def pluck(arr):
    return min(filter(lambda x: x[0] % 2 == 0, enumerate(arr)), default=[])",not useful
"This function uses min on a generator of even value-index pairs from enumerate, with a default empty list for the smallest even and its index.","def pluck(arr):
    return min((val, i) for i, val in enumerate(arr) if val % 2 == 0, default=[])",useful
"This function uses min on a generator of even value-index pairs with a key for value then index, providing a default empty list if no evens exist.","def pluck(arr):
    return min((val, i) for i, val in enumerate(arr) if val % 2 == 0, key=lambda x: (x[0], x[1]), default=[])",useful
"This function uses min on a generator of even value-index pairs with itemgetter key for value then index, defaulting to empty list if no evens.","def pluck(arr):
    return min((val, i) for i, val in enumerate(arr) if val % 2 == 0, key=itemgetter(0, 1), default=[])",useful
"This function filters enumerate pairs where the value is even, then mins with key for value then index using itemgetter, defaulting to empty list.","def pluck(arr):
    return min(filter(lambda x: x[1] % 2 == 0, enumerate(arr)), key=itemgetter(1, 0), default=[])",useful
"This function uses min on a generator of even value-index pairs with a lambda key for value then index, defaulting to empty list if no evens.","def pluck(arr):
    return min((val, i) for i, val in enumerate(arr) if val % 2 == 0, key=lambda x: (x[0], x[1]), default=[])",useful
"This function counts occurrences of each number in the list using a dictionary, then checks from largest to smallest if any number appears at least that many times, returning it or -1.","def search(lst):
    count = {}
    for num in lst:
        count[num] = count.get(num, 0) + 1
    for num in sorted(count.keys(), reverse=True):
        if count[num] >= num:
            return num
    return -1",useful
"This function uses a list to count occurrences up to the max value, then iterates backward from the end to find the largest number that appears at least that many times, or -1.","def search(lst):
    count = [0] * (max(lst) + 1)
    for num in lst:
        count[num] += 1
    for num in range(len(count) - 1, 0, -1):
        if count[num] >= num:
            return num
    return -1",useful
"This function counts occurrences in a list up to max, then uses next on a reversed range generator to find the largest qualifying number or -1.","def search(lst):
    count = [0] * (max(lst) + 1)
    for num in lst:
        count[num] += 1
    return next((i for i in range(len(count) - 1, 0, -1) if count[i] >= i), -1)",useful
"This function uses Counter to count occurrences, then iterates over sorted keys in reverse to find the largest number appearing at least that many times, or -1.","from collections import Counter
def search(lst):
    count = Counter(lst)
    for num in sorted(count.keys(), reverse=True):
        if count[num] >= num:
            return num
    return -1",useful
"This function counts in a list up to max, then uses max on a generator of indices where count meets the condition, defaulting to -1.","def search(lst):
    count = [0] * (max(lst) + 1)
    for num in lst:
        count[num] += 1
    return max((i for i in range(1, len(count)) if count[i] >= i), default=-1)",useful
"This function builds a dictionary count, then uses max on keys where value >= key, defaulting to -1 for the largest qualifying number.","def search(lst):
    count = {}
    for num in lst:
        count[num] = count.get(num, 0) + 1
    return max((k for k, v in count.items() if v >= k), default=-1)",useful
"This function uses a count list up to max, then loops backward through indices to find and return the first (largest) where count >= index, or -1.","def search(lst):
    count = [0] * (max(lst) + 1)
    for num in lst:
        count[num] += 1
    for i in range(len(count) - 1, 0, -1):
        if count[i] >= i:
            return i
    return -1",useful
"This function uses Counter for counts, then max on keys where count value >= key, defaulting to -1 for the largest qualifying number.","from collections import Counter
def search(lst):
    count = Counter(lst)
    return max((k for k, v in count.items() if v >= k), default=-1)",useful
"This function counts in a list up to max, then uses reversed range to iterate and return the first (largest) index where count >= index, or -1.","def search(lst):
    count = [0] * (max(lst) + 1)
    for num in lst:
        count[num] += 1
    for i in reversed(range(1, len(count))):
        if count[i] >= i:
            return i
    return -1",useful
"This function counts with a dictionary, then uses next on a reversed sorted keys generator to find the largest number where count >= number, or -1.","def search(lst):
    count = {}
    for num in lst:
        count[num] = count.get(num, 0) + 1
    return next((num for num in reversed(sorted(count.keys())) if count[num] >= num), -1)",useful
"This function sorts the input list in ascending order, then swaps elements starting from the second position with those from the end towards the middle, effectively reversing the inner portion while leaving the first element unchanged.","def strange_sort_list(lst):
    lst.sort()
    i, j = 1, len(lst) - 1
    while i < j:
        lst[i], lst[j] = lst[j], lst[i]
        i += 1
        j -= 1
    return lst",useful
"After sorting the list, it interleaves every other element from the start with elements from the reversed list starting from the end, appending any middle element for odd lengths to create an alternating pattern.","def strange_sort_list(lst):
    lst.sort()
    return [val for pair in zip(lst[::2], lst[-1::-2]) for val in pair] + lst[len(lst) % 2:]",not useful
"The code sorts the list and zips the first half with the reversed second half, flattening the pairs into a new list and adding the middle element if the length is odd.","def strange_sort_list(lst):
    lst.sort()
    return [x for i in zip(lst[:len(lst)//2], lst[len(lst)//2:][::-1]) for x in i] + lst[len(lst)%2:]",not useful
"It sorts the list, then zips the first half with the reversed second half starting from the second-to-last element, flattening the result and appending the middle for odd lengths.","def strange_sort_list(lst):
    lst.sort()
    return [x for pair in zip(lst[:len(lst)//2], lst[len(lst)//2-1::-1]) for x in pair] + lst[len(lst)%2:]",not useful
"Following sorting, the function zips the first half of the list with the reversed second half, flattens the pairs, and adds the middle element if the list has an odd length.","def strange_sort_list(lst):
    lst.sort()
    return [x for pair in zip(lst[:len(lst)//2], reversed(lst[len(lst)//2:])) for x in pair] + lst[len(lst)%2:]",not useful
"This sorts the list and interleaves every other element from the beginning with elements from the reversed list starting near the end, appending the middle element for odd lengths.","def strange_sort_list(lst):
    lst.sort()
    return [val for pair in zip(lst[::2], lst[len(lst) - 1::-2]) for val in pair] + lst[len(lst) % 2:]",not useful
"After sorting, it zips every second element from the start with the reversed list, flattens the pairs, and appends any remaining middle element for odd-length lists.","def strange_sort_list(lst):
    lst.sort()
    return [val for pair in zip(lst[::2], lst[-1::-2]) for val in pair] + lst[len(lst) % 2:]",not useful
"The function sorts the input, then uses zip to pair every other element from the front with reversed elements from the back, flattening and adding the odd-length remainder.","def strange_sort_list(lst):
    lst.sort()
    return [val for pair in zip(lst[::2], lst[len(lst) - 1::-2]) for val in pair] + lst[len(lst) % 2:]",not useful
"It sorts the list and creates a new one by interleaving elements from the start (every second) with the reversed list, including the middle for odd lengths.","def strange_sort_list(lst):
    lst.sort()
    return [val for pair in zip(lst[::2], lst[-1::-2]) for val in pair] + lst[len(lst) % 2:]",not useful
"Sorting is followed by zipping alternate starting elements with the reversed list from the end, flattening the result and appending the middle if odd-length.","def strange_sort_list(lst):
    lst.sort()
    return [val for pair in zip(lst[::2], lst[len(lst) - 1::-2]) for val in pair] + lst[len(lst) % 2:]",not useful
"This function checks if three sides form a valid triangle using the triangle inequality, then computes the area via Heron's formula rounded to two decimals, returning -1 if invalid.","def triangle_area(a, b, c):
    if a + b > c and a + c > b and b + c > a:
        s = (a + b + c) / 2
        return round((s * (s - a) * (s - b) * (s - c)) ** 0.5, 2)
    return -1",useful
"It sorts the sides and verifies the triangle inequality on the sorted values, applying Heron's formula for the area if valid, rounded to two places, else -1.","def triangle_area(a, b, c):
    sides = sorted([a, b, c])
    if sides[0] + sides[1] > sides[2]:
        s = sum(sides) / 2
        return round((s * (s - sides[0]) * (s - sides[1]) * (s - sides[2])) ** 0.5, 2)
    return -1",useful
"Using math.sqrt, it validates the triangle with inequalities, calculates the semi-perimeter, and returns the rounded area from Heron's formula or -1 if not a triangle.","import math
def triangle_area(a, b, c):
    if a + b > c and a + c > b and b + c > a:
        s = (a + b + c) / 2
        return round(math.sqrt(s * (s - a) * (s - b) * (s - c)), 2)
    return -1",useful
"The code checks the negated triangle inequalities for invalidity, computes the semi-perimeter, and applies Heron's formula rounded to two decimals if valid, else -1.","def triangle_area(a, b, c):
    if a + b <= c or a + c <= b or b + c <= a:
        return -1
    s = (a + b + c) / 2
    return round((s * (s - a) * (s - b) * (s - c)) ** 0.5, 2)",useful
"It negates the triangle inequality check to return -1 early if invalid, otherwise uses Heron's formula with square root via exponentiation, rounded to two decimals.","def triangle_area(a, b, c):
    if not (a + b > c and a + c > b and b + c > a):
        return -1
    s = (a + b + c) / 2
    return round((s * (s - a) * (s - b) * (s - c)) ** 0.5, 2)",useful
"Sorting the sides allows checking if the largest is less than the sum of the others; if valid, Heron's formula computes the rounded area, else -1.","def triangle_area(a, b, c):
    sides = sorted([a, b, c])
    if sides[2] >= sides[0] + sides[1]:
        return -1
    s = sum(sides) / 2
    return round((s * (s - sides[0]) * (s - sides[1]) * (s - sides[2])) ** 0.5, 2)",useful
"With math.sqrt for precision, it uses negated inequalities to detect invalid triangles early, then applies Heron's formula rounded to two decimals.","import math
def triangle_area(a, b, c):
    if a + b <= c or a + c <= b or b + c <= a:
        return -1
    s = (a + b + c) / 2
    return round(math.sqrt(s * (s - a) * (s - b) * (s - c)), 2)",useful
"This validates the triangle inequalities, computes the semi-perimeter as the sum divided by 2, and returns the rounded area from Heron's formula or -1.","def triangle_area(a, b, c):
    if a + b > c and a + c > b and b + c > a:
        s = sum([a, b, c]) / 2
        return round((s * (s - a) * (s - b) * (s - c)) ** 0.5, 2)
    return -1",useful
"Negated triangle inequalities allow quick return of -1 for invalid cases; otherwise, Heron's formula with exponentiated square root gives the rounded area.","def triangle_area(a, b, c):
    if a + b <= c or a + c <= b or b + c <= a:
        return -1
    s = (a + b + c) / 2
    return round((s * (s - a) * (s - b) * (s - c)) ** 0.5, 2)",useful
"Using math.sqrt, it checks triangle validity with inequalities, computes the semi-perimeter, and returns the rounded Heron's formula area or -1 if invalid.","import math
def triangle_area(a, b, c):
    if not (a + b > c and a + c > b and b + c > a):
        return -1
    s = (a + b + c) / 2
    return round(math.sqrt(s * (s - a) * (s - b) * (s - c)), 2)",useful
"The function checks if the list q is a palindrome by comparing it to its reverse and verifies if the sum of its elements is at most w, returning True if both conditions hold.","def will_it_fly(q, w):
    return q == q[::-1] and sum(q) <= w",useful
"It uses a generator to compare each pair of elements from start and end for palindrome check, and ensures the sum of q is <= w for the return value.","def will_it_fly(q, w):
    return all(q[i] == q[-i-1] for i in range(len(q)//2)) and sum(q) <= w",useful
"This concise code reverses q and compares it to the original to check for palindrome, while also ensuring sum(q) <= w.","def will_it_fly(q, w):
    return q[::-1] == q and sum(q) <= w",useful
"Converting q to a reversed list explicitly, it checks equality for palindrome and compares sum(q) to w.","def will_it_fly(q, w):
    return q == list(reversed(q)) and sum(q) <= w",useful
It compares a slice of q to its reverse for palindrome verification and checks if sum(q) <= w.,"def will_it_fly(q, w):
    return q[:] == q[::-1] and sum(q) <= w",useful
"Using slices, it verifies q equals its reverse for palindrome and sum(q) <= w.","def will_it_fly(q, w):
    return q[::-1] == q[:] and sum(q) <= w",useful
The function returns True if q is a palindrome (equals its reverse) and the sum of its elements does not exceed w.,"def will_it_fly(q, w):
    return q == q[::-1] and sum(q) <= w",useful
It checks palindrome by direct reverse comparison and ensures the total sum of q is within limit w.,"def will_it_fly(q, w):
    return q == q[::-1] and sum(q) <= w",useful
"Palindrome is confirmed by q matching its reversed version, combined with sum(q) <= w check.","def will_it_fly(q, w):
    return q == q[::-1] and sum(q) <= w",useful
This returns True when q reads the same forwards and backwards and its elements sum to at most w.,"def will_it_fly(q, w):
    return q == q[::-1] and sum(q) <= w",useful
"The function counts mismatches between the list and its reverse using zip, then divides by 2 to find the minimum changes needed for a palindrome.","def smallest_change(arr):
    return sum(a != b for a, b in zip(arr, arr[::-1])) // 2",useful
"It uses a list comprehension with zip and reversed to count differing pairs, returning half that count as the smallest changes for palindromicity.","def smallest_change(arr):
    return len([1 for a, b in zip(arr, reversed(arr)) if a != b]) // 2",useful
"Applying map with a lambda to zip the list and its reverse, it sums the mismatches and divides by 2 for the minimum palindrome changes.","def smallest_change(arr):
    return sum(map(lambda x: x[0] != x[1], zip(arr, arr[::-1]))) // 2",useful
"Using Counters on the list and its reverse, it computes the sum of differences in counts divided by 2, though this may not accurately reflect position-based changes.","from collections import Counter
def smallest_change(arr):
    c1, c2 = Counter(arr), Counter(arr[::-1])
    return sum((c1 - c2).values()) // 2",not useful
"This zips the list with its reverse and sums absolute differences, dividing by 2; it assumes numeric elements and measures total difference rather than change count.","def smallest_change(arr):
    return sum(abs(a - b) for a, b in zip(arr, arr[::-1])) // 2",not useful
"Zipping with reversed list, it counts unequal pairs and halves the result to estimate minimum changes to make the list a palindrome.","def smallest_change(arr):
    return sum(a != b for a, b in zip(arr, reversed(arr))) // 2",useful
"A list comprehension iterates up to half the length, counting positions where elements differ from their mirrored counterparts for palindrome changes.","def smallest_change(arr):
    return len([i for i in range(len(arr) // 2) if arr[i] != arr[-i - 1]])",useful
"Using a generator expression, it sums inequalities between symmetric positions up to half the list length to find palindrome adjustment count.","def smallest_change(arr):
    return sum(arr[i] != arr[-i - 1] for i in range(len(arr) // 2))",useful
"It sums mismatches via zip with reverse, then right-shifts by 1 (equivalent to divide by 2) for the minimum changes to palindrome.","def smallest_change(arr):
    return sum(a != b for a, b in zip(arr, arr[::-1])) >> 1",useful
"Assuming operator.ne is imported, it maps inequality checks over zipped list and reverse, summing and dividing by 2 for palindrome changes.","def smallest_change(arr):
    return sum(map(operator.ne, arr, arr[::-1])) // 2",useful
"This compares the total lengths of strings in lst1 and lst2, returning the list with the smaller sum.","def total_match(lst1, lst2):
    return lst1 if sum(len(s) for s in lst1) < sum(len(s) for s in lst2) else lst2",useful
"Using min with a key function that sums string lengths, it returns the list with the shorter total character count.","def total_match(lst1, lst2):
    return min(lst1, lst2, key=lambda lst: sum(len(s) for s in lst))",useful
It sums the lengths via map for both lists and returns the one with the smaller total.,"def total_match(lst1, lst2):
    return lst1 if sum(map(len, lst1)) < sum(map(len, lst2)) else lst2",useful
Sorting the two lists by their total string lengths and selecting the first gives the one with minimal total length.,"def total_match(lst1, lst2):
    return sorted([lst1, lst2], key=lambda lst: sum(len(s) for s in lst))[0]",useful
"Using indexing with a comparison of summed lengths via map, it selects and returns the list with smaller total length.","def total_match(lst1, lst2):
    return [lst1, lst2][sum(map(len, lst2)) < sum(map(len, lst1))]",useful
Joining each list into a string and comparing their lengths returns the list whose concatenated strings are shorter.,"def total_match(lst1, lst2):
    return lst1 if len(''.join(lst1)) < len(''.join(lst2)) else lst2",useful
"It compares summed string lengths and returns lst1 if smaller or equal, otherwise lst2.","def total_match(lst1, lst2):
    return lst1 if sum(len(i) for i in lst1) <= sum(len(i) for i in lst2) else lst2",useful
The function returns the list with the smaller or equal total string length sum.,"def total_match(lst1, lst2):
    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",useful
"Summing lengths for each list, it returns the one with strictly smaller total length.","def total_match(lst1, lst2):
    return lst1 if sum(len(i) for i in lst1) < sum(len(i) for i in lst2) else lst2",useful
"This attempts to sum lengths after joining, but map(len, ''.join(lst)) is incorrect as it maps over a string; it aims to return the shorter total list.","def total_match(lst1, lst2):
    return lst1 if sum(map(len, ''.join(lst1))) < sum(map(len, ''.join(lst2))) else lst2",not useful
Generic comment: Code solution for the given function.,"def is_multiply_prime(a):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    for i in primes:
        if a % i == 0:
            for j in primes:
                if a % j == 0 and a // i % j == 0 and a // i // j < 2:
                    return True
    return False",not useful
Generic comment: Code solution for the given function.,"def is_multiply_prime(a):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    for i in primes:
        if a % i == 0:
            for j in primes:
                if a % j == 0 and a // i % j == 0:
                    if a // i // j in primes:
                        return True
    return False",not useful
Generic comment: Code solution for the given function.,"def is_multiply_prime(a):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    for i in primes:
        if a % i == 0:
            b = a // i
            for j in primes:
                if b % j == 0:
                    if b // j in primes:
                        return True
    return False",not useful
Generic comment: Code solution for the given function.,"def is_multiply_prime(a):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    for i in primes:
        if a % i == 0:
            b = a // i
            for j in primes:
                if b % j == 0 and b // j in primes:
                    return True
    return False",not useful
Generic comment: Code solution for the given function.,"def is_multiply_prime(a):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    for i in range(len(primes)):
        if a % primes[i] == 0:
            b = a // primes[i]
            for j in range(i, len(primes)):
                if b % primes[j] == 0 and b // primes[j] in primes:
                    return True
    return False",not useful
Generic comment: Code solution for the given function.,"def is_multiply_prime(a):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    for i in primes:
        if a % i == 0:
            b = a // i
            for j in primes:
                if j >= i and b % j == 0 and b // j in primes:
                    return True
    return False",not useful
Generic comment: Code solution for the given function.,"def is_multiply_prime(a):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    for i in range(len(primes)):
        if a % primes[i] == 0:
            b = a // primes[i]
            for j in range(i, len(primes)):
                if b % primes[j] == 0:
                    if b // primes[j] in primes:
                        return True
    return False",not useful
Generic comment: Code solution for the given function.,"def is_multiply_prime(a):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    for i in primes:
        if a % i == 0:
            b = a // i
            for j in primes:
                if j >= i and b % j == 0:
                    if b // j in primes:
                        return True
    return False",not useful
Generic comment: Code solution for the given function.,"def is_multiply_prime(a):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    for i in range(len(primes)):
        if a % primes[i] == 0:
            b = a // primes[i]
            for j in range(i, len(primes)):
                if b % primes[j] == 0 and b // primes[j] in primes:
                    return True
    return False",not useful
Generic comment: Code solution for the given function.,"def is_multiply_prime(a):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    for i in primes:
        if a % i == 0:
            b = a // i
            for j in primes:
                if j >= i and b % j == 0 and b // j in primes:
                    return True
    return False",not useful
Generic comment: Code solution for the given function.,"def is_simple_power(x, n):
    return x > 0 and (x == 1 or n > 1 and x % n == 0 and is_simple_power(x // n, n))",not useful
Generic comment: Code solution for the given function.,"def is_simple_power(x, n):
    if x < 1 or n < 2:
        return False
    while x % n == 0:
        x /= n
    return x == 1",not useful
Generic comment: Code solution for the given function.,"def is_simple_power(x, n):
    if x < 1 or n < 2:
        return False
    return n ** int(math.log(x, n)) == x",not useful
Generic comment: Code solution for the given function.,"def is_simple_power(x, n):
    if x < 1 or n < 2:
        return False
    return all(x % n**i != 0 for i in range(1, int(math.log(x, n)) + 1))",not useful
Generic comment: Code solution for the given function.,"def is_simple_power(x, n):
    if x < 1 or n < 2:
        return False
    return any(n**i == x for i in range(int(math.log(x, n)) + 1))",not useful
Generic comment: Code solution for the given function.,"def is_simple_power(x, n):
    if x < 1 or n < 2:
        return False
    return bin(x).count('1') == 1 and x % n == 0",not useful
Generic comment: Code solution for the given function.,"def is_simple_power(x, n):
    if x < 1 or n < 2:
        return False
    return math.log(x, n).is_integer()",not useful
Generic comment: Code solution for the given function.,"def is_simple_power(x, n):
    if x < 1 or n < 2:
        return False
    return functools.reduce(lambda a, b: a * b, [n] * (int(math.log(x, n)) if math.log(x, n).is_integer() else 0)) == x",not useful
Generic comment: Code solution for the given function.,"def is_simple_power(x, n):
    if x < 1 or n < 2:
        return False
    return np.log(x) / np.log(n) % 1 == 0",not useful
Generic comment: Code solution for the given function.,"def is_simple_power(x, n):
    if x < 1 or n < 2:
        return False
    return x == reduce(lambda a, _: a * n, range(int(math.log(x, n)) + 1), 1)",not useful
Generic comment: Code solution for the given function.,"def iscube(a):
    return round(a ** (",not useful
Generic comment: Code solution for the given function.,/ 3)) ** 3 == a,not useful
Generic comment: Code solution for the given function.,"def iscube(a):
    return int(round(abs(a) ** (",not useful
Generic comment: Code solution for the given function.,/ 3))) ** 3 == abs(a),not useful
Generic comment: Code solution for the given function.,"def iscube(a):
    a = abs(a)
    return (a ** (",not useful
Generic comment: Code solution for the given function.,/ 3)).is_integer(),not useful
Generic comment: Code solution for the given function.,"def iscube(a):
    a = abs(a)
    return a == int(a ** (",not useful
Generic comment: Code solution for the given function.,/ 3)) ** 3,not useful
Generic comment: Code solution for the given function.,"def iscube(a):
    a = abs(a)
    return a == round(a ** (",not useful
Generic comment: Code solution for the given function.,/ 3)) ** 3,not useful
Generic comment: Code solution for the given function.,"def hex_key(num):
    return sum(1 for c in num if c in '2357BD')",not useful
Generic comment: Code solution for the given function.,"def hex_key(num):
    return sum(c in '2357BD' for c in num)",not useful
Generic comment: Code solution for the given function.,"def hex_key(num):
    return len([c for c in num if c in '2357BD'])",not useful
Generic comment: Code solution for the given function.,"def hex_key(num):
    return num.count('2') + num.count('3') + num.count('5') + num.count('7') + num.count('B') + num.count('D')",not useful
Generic comment: Code solution for the given function.,"def hex_key(num):
    primes = {'2', '3', '5', '7', 'B', 'D'}
    return sum(c in primes for c in num)",not useful
Generic comment: Code solution for the given function.,"def hex_key(num):
    return sum(num.count(c) for c in '2357BD')",not useful
Generic comment: Code solution for the given function.,"def hex_key(num):
    return len(list(filter(lambda c: c in '2357BD', num)))",not useful
Generic comment: Code solution for the given function.,"def hex_key(num):
    return len([c for c in num if c in set('2357BD')])",not useful
Generic comment: Code solution for the given function.,"def hex_key(num):
    return sum(num.count(c) for c in '2357BD')",not useful
Generic comment: Code solution for the given function.,"def hex_key(num):
    return len([c for c in num if c in ('2', '3', '5', '7', 'B', 'D')])",not useful
Generic comment: Code solution for the given function.,"def decimal_to_binary(decimal):
    return f""db{bin(decimal)[2:]}db""",not useful
Generic comment: Code solution for the given function.,"def decimal_to_binary(decimal):
    return 'db' + format(decimal, 'b') + 'db'",not useful
Generic comment: Code solution for the given function.,"def decimal_to_binary(decimal):
    return 'db%sdb' % format(decimal, 'b')",not useful
Generic comment: Code solution for the given function.,"def decimal_to_binary(decimal):
    return 'db{0:b}db'.format(decimal)",not useful
Generic comment: Code solution for the given function.,"def decimal_to_binary(decimal):
    return 'db' + ''.join(format(decimal, 'b')) + 'db'",not useful
Generic comment: Code solution for the given function.,"def decimal_to_binary(decimal):
    return 'db' + ''.join(map(str, bin(decimal)[2:])) + 'db'",not useful
Generic comment: Code solution for the given function.,"def decimal_to_binary(decimal):
    return 'db' + ''.join(list(bin(decimal)[2:])) + 'db'",not useful
Generic comment: Code solution for the given function.,"def decimal_to_binary(decimal):
    return 'db' + ''.join(str(x) for x in bin(decimal)[2:]) + 'db'",not useful
Generic comment: Code solution for the given function.,"def decimal_to_binary(decimal):
    return 'db' + ''.join(str(int(x)) for x in bin(decimal)[2:]) + 'db'",not useful
Generic comment: Code solution for the given function.,"def decimal_to_binary(decimal):
    return 'db' + ''.join(str(int(b)) for b in bin(decimal)[2:]) + 'db'",not useful
This function checks if the string length is at least 3 and every triplet of consecutive characters consists of three distinct characters by using a chained inequality in the all() condition.,"def is_happy(s):
    return len(s) >= 3 and all(s[i] != s[i+1] != s[i+2] != s[i] for i in range(len(s) - 2))",useful
"This function verifies that the string is at least 3 characters long and each set of three consecutive characters has exactly three unique elements, ensuring all are distinct.","def is_happy(s):
    return len(s) >= 3 and all(len(set(s[i:i+3])) == 3 for i in range(len(s) - 2))",useful
"This function returns True if the string length is >=3 and no two characters in any three consecutive positions are the same, explicitly checking pairwise inequalities.","def is_happy(s):
    return len(s) >= 3 and all(s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2] for i in range(len(s) - 2))",useful
"This function determines if the string is long enough and every window of three characters forms a set of size 3, meaning all distinct, using a set comprehension.","def is_happy(s):
    return len(s) >= 3 and all(len({s[i], s[i+1], s[i+2]}) == 3 for i in range(len(s) - 2))",useful
"This function checks the length condition and ensures that for each position i, the character at i does not appear in the next two positions, verifying distinctness in triplets.","def is_happy(s):
    return len(s) >= 3 and all(s[i] not in s[i+1:i+3] for i in range(len(s) - 2))",not useful
This function confirms the string length >=3 and that each substring of three characters has no duplicates by comparing its length to the length of its set.,"def is_happy(s):
    return len(s) >= 3 and all(len(s[i:i+3]) == len(set(s[i:i+3])) for i in range(len(s) - 2))",useful
"This function checks if the string is >=3 long and for every triplet, counts the occurrences of each character in the entire string, but this approach is inefficient as it counts globally instead of locally.","def is_happy(s):
    return len(s) >= 3 and all(s.count(s[i]) == 1 and s.count(s[i+1]) == 1 and s.count(s[i+2]) == 1 for i in range(len(s) - 2))",not useful
This function verifies length >=3 and uses nested loops to ensure each character in every three-character substring appears exactly once within that substring.,"def is_happy(s):
    return len(s) >= 3 and all(s[i:i+3].count(c) == 1 for i in range(len(s) - 2) for c in s[i:i+3])",useful
This function checks if the string length is at least 3 and confirms that every three consecutive characters are unique by equating substring length to set length.,"def is_happy(s):
    return len(s) >= 3 and all(len(s[i:i+3]) == len(set(s[i:i+3])) for i in range(len(s) - 2))",useful
"This function returns True for strings of length >=3 where all consecutive triplets have pairwise distinct characters, using explicit inequality checks.","def is_happy(s):
    return len(s) >= 3 and all(s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2] for i in range(len(s) - 2))",useful
This function converts a list of GPA values to letter grades using a single list comprehension with nested conditional expressions for each grade range.,"def numerical_letter_grade(grades):
    return ['A+' if g == 4.0 else 'A' if 3.7 < g <= 4.0 else 'A-' if 3.3 < g <= 3.7 else 'B+' if 3.0 < g <= 3.3 else 'B' if 2.7 < g <= 3.0 else 'B-' if 2.3 < g <= 2.7 else 'C+' if 2.0 < g <= 2.3 else 'C' if 1.7 < g <= 2.0 else 'C-' if 1.3 < g <= 1.7 else 'D+' if 1.0 < g <= 1.3 else 'D' if 0.7 < g <= 1.0 else 'D-' if 0.0 < g <= 0.7 else 'E' for g in grades]",not useful
"This function iterates through each grade in the list and appends the corresponding letter grade based on if-elif conditions for each GPA threshold, returning the list of grades.","def numerical_letter_grade(grades):
    letter_grades = []
    for g in grades:
        if g == 4.0:
            letter_grades.append('A+')
        elif 3.7 < g <= 4.0:
            letter_grades.append('A')
        elif 3.3 < g <= 3.7:
            letter_grades.append('A-')
        elif 3.0 < g <= 3.3:
            letter_grades.append('B+')
        elif 2.7 < g <= 3.0:
            letter_grades.append('B')
        elif 2.3 < g <= 2.7:
            letter_grades.append('B-')
        elif 2.0 < g <= 2.3:
            letter_grades.append('C+')
        elif 1.7 < g <= 2.0:
            letter_grades.append('C')
        elif 1.3 < g <= 1.7:
            letter_grades.append('C-')
        elif 1.0 < g <= 1.3:
            letter_grades.append('D+')
        elif 0.7 < g <= 1.0:
            letter_grades.append('D')
        elif 0.0 < g <= 0.7:
            letter_grades.append('D-')
        else:
            letter_grades.append('E')
    return letter_grades",not useful
"This function attempts to map grades using a dictionary of tuples for ranges, but the implementation has syntax errors in the keys and the return uses a malformed list comprehension.","def numerical_letter_grade(grades):
    grade_map = {
        (4.0, 4.0): 'A+',
        (3.7, 4.0]: 'A',
        (3.3, 3.7]: 'A-',
        (3.0, 3.3]: 'B+',
        (2.7, 3.0]: 'B',
        (2.3, 2.7]: 'B-',
        (2.0, 2.3]: 'C+',
        (1.7, 2.0]: 'C',
        (1.3, 1.7]: 'C-',
        (1.0, 1.3]: 'D+',
        (0.7, 1.0]: 'D',
        (0.0, 0.7]: 'D-',
        (0.0, 0.0]: 'E'
    }
    return [grade for g in grades for lower, upper in grade_map if lower < g <= upper]",not useful
"This function uses a list of tuples for grade boundaries and finds the next matching letter for each grade by iterating through the map, defaulting to 'E' for grades below 0.","def numerical_letter_grade(grades):
    grade_map = [(4.0, 'A+'), (3.7, 'A'), (3.3, 'A-'), (3.0, 'B+'), (2.7, 'B'), (2.3, 'B-'), (2.0, 'C+'), (1.7, 'C'), (1.3, 'C-'), (1.0, 'D+'), (0.7, 'D'), (0.0, 'D-')]
    return ['E' if g < 0.0 else next(letter for gpa, letter in grade_map if g <= gpa) for g in grades]",not useful
"This function employs a dictionary mapping threshold GPAs to letters and uses next() with a generator to find the highest applicable letter for each grade, defaulting to 'E'.","def numerical_letter_grade(grades):
    grade_map = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-'}
    return [next((letter for gpa, letter in grade_map.items() if g <= gpa), 'E') for g in grades]",not useful
"This function sorts the grade map keys in descending order and uses filter to find the largest GPA threshold <= the input grade, retrieving the corresponding letter or 'E'.","def numerical_letter_grade(grades):
    grade_map = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-'}
    return [grade_map.get(next(filter(lambda x: x <= g, sorted(grade_map.keys(), reverse=True))), 'E') for g in grades]",not useful
"This function uses a dictionary of GPA thresholds to letters and finds the first (highest) threshold <= the grade using next() on a generator, defaulting to 'E' for lower grades.","def numerical_letter_grade(grades):
    grade_map = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-'}
    return [next((letter for gpa, letter in grade_map.items() if gpa <= g), 'E') for g in grades]",useful
"This function creates a grade map and for each input grade, finds the maximum threshold <= the grade to get the letter, explicitly handling grades <0 as 'E'.","def numerical_letter_grade(grades):
    grade_map = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-'}
    return [grade_map[max(gpa for gpa in grade_map if gpa <= g)] if g >= 0.0 else 'E' for g in grades]",useful
"This function iterates over the grade map in reverse order using reversed() to find the highest threshold <= the input grade, defaulting to 'E' if none match.","def numerical_letter_grade(grades):
    grade_map = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-'}
    return [next((letter for gpa, letter in reversed(grade_map.items()) if gpa <= g), 'E') for g in grades]",not useful
"This function uses a dictionary for grade thresholds and applies next() to find the first (highest) GPA key <= the input grade, returning 'E' if no match.","def numerical_letter_grade(grades):
    grade_map = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-'}
    return [next((letter for gpa, letter in grade_map.items() if gpa <= g), 'E') for g in grades]",useful
"This function calculates the length n of the string and checks if n is prime by testing divisibility from 2 to sqrt(n), returning False for n < 2.","def prime_length(string):
    n = len(string)
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True",useful
"This function gets the string length n and uses all() to check if n is not divisible by any integer from 2 to sqrt(n), effectively testing primality for n >= 2.","def prime_length(string):
    n = len(string)
    if n < 2:
        return False
    return all(n % i for i in range(2, int(n**0.5) + 1))",useful
"This function determines if the string length n is prime by negating any() divisibility check from 2 to sqrt(n), returning False if n < 2.","def prime_length(string):
    n = len(string)
    if n < 2:
        return False
    return not any(n % i == 0 for i in range(2, int(n**0.5) + 1))",useful
This function computes the string length n and sums the number of divisors in the range 2 to sqrt(n); returns True if the sum is 0 (prime) and n >=2.,"def prime_length(string):
    n = len(string)
    if n < 2:
        return False
    return sum(n % i == 0 for i in range(2, int(n**0.5) + 1)) == 0",useful
"This function checks if the string length n >1 and uses all() to ensure n % i !=0 for i from 2 to sqrt(n), confirming primality.","def prime_length(string):
    n = len(string)
    if n < 2:
        return False
    return all(n % i for i in range(2, int(n**0.5) + 1)) and n > 1",not useful
"This function verifies the string length n >1 and uses not any() to check for no divisors in 2 to sqrt(n), indicating a prime length.","def prime_length(string):
    n = len(string)
    if n < 2:
        return False
    return not any(n % i == 0 for i in range(2, int(n**0.5) + 1)) and n > 1",not useful
"This function calculates string length n and returns True if n >1 and the count of divisors from 2 to sqrt(n) is zero, i.e., prime.","def prime_length(string):
    n = len(string)
    if n < 2:
        return False
    return sum(n % i == 0 for i in range(2, int(n**0.5) + 1)) == 0 and n > 1",not useful
"This function gets n = len(string) and checks n >=2, then uses all() for no divisibility up to sqrt(n), but adds redundant n !=1 check.","def prime_length(string):
    n = len(string)
    if n < 2:
        return False
    return all(n % i for i in range(2, int(n**0.5) + 1)) and n != 1",useful
"This function returns True if string length n >=2 and has no divisors from 2 to sqrt(n) using not any(), with extra n !=1 condition.","def prime_length(string):
    n = len(string)
    if n < 2:
        return False
    return not any(n % i == 0 for i in range(2, int(n**0.5) + 1)) and n != 1",useful
"This function computes n = len(string) and checks if n >=2 with zero divisors in 2 to sqrt(n) via sum(), plus redundant n !=1.","def prime_length(string):
    n = len(string)
    if n < 2:
        return False
    return sum(n % i == 0 for i in range(2, int(n**0.5) + 1)) == 0 and n != 1",useful
"This function computes the count of n-digit numbers starting and ending with 1 using a mathematical formula with powers of 9 and 10, handling base cases for n=1 and n=2.","def starts_one_ends(n):
    if n == 1: return 1
    if n == 2: return 3
    return 10 * (9 ** (n - 2)) * 2 + 9 ** (n - 1)",not useful
"This function calculates the desired count for n>1 using powers of 9 and 8, returning 1 for n<=1, though the formula may target specific patterns like starting with 1.","def starts_one_ends(n):
    return 2 * 9 ** (n - 1) + 10 * 8 ** (n - 2) if n > 1 else 1",not useful
"This function uses the difference of powers (10^n - 8^n)*2 for n>1 to compute the count, returning 1 for n=1, likely counting numbers starting and ending with 1.","def starts_one_ends(n):
    return (10 ** n - 8 ** n) * 2 if n > 1 else 1",not useful
"This function computes (10^n - 8^n + 8) for n>1 as the count, with base case 1, approximating numbers with specific start and end digits.","def starts_one_ends(n):
    return (10 ** n - 8 ** n + 8) if n > 1 else 1",not useful
"This function calculates (10^n - 9^n)*2 -1 for n>1 to get the count of qualifying n-digit numbers, returning 1 for n=1.","def starts_one_ends(n):
    return (10 ** n - 9 ** n) * 2 - 1 if n > 1 else 1",not useful
"This function uses (10^n - 9^n)*2 +1 for n>1 to determine the count, with 1 for n=1, targeting numbers starting and ending with 1.","def starts_one_ends(n):
    return (10 ** n - 9 ** n) * 2 + 1 if n > 1 else 1",not useful
"This function computes (10^n - 8^n)*2 +2 for n>1 as the count, returning 1 for n=1, for specific digit patterns.","def starts_one_ends(n):
    return (10 ** n - 8 ** n) * 2 + 2 if n > 1 else 1",not useful
"This function calculates (10^n - 9^n +1)*2 for n>1 to find the count, with base case 1, likely for numbers starting with 1 and ending with 1.","def starts_one_ends(n):
    return (10 ** n - 9 ** n + 1) * 2 if n > 1 else 1",not useful
"This function uses (10^n - 8^n)*2 -8 for n>1 to compute the count of n-digit numbers with certain properties, returning 1 for n=1.","def starts_one_ends(n):
    return (10 ** n - 8 ** n) * 2 - 8 if n > 1 else 1",not useful
"This function computes (10^n - 9^n)*2 +9 for n>1 as the count, with 1 for n=1, approximating the desired numerical count.","def starts_one_ends(n):
    return (10 ** n - 9 ** n) * 2 + 9 if n > 1 else 1",not useful
This function sums the binary digits of N (population count) and returns the binary representation of that sum as a string without the '0b' prefix.,"def solve(N):
    return bin(sum(int(d) for d in bin(N)[2:]))[2:]",useful
This function calculates the sum of 1s in the binary form of N and formats that sum as a binary string using format().,"def solve(N):
    return format(sum(int(b) for b in bin(N)[2:]), 'b')",useful
This function computes the population count of N's binary and converts it back to binary string using string formatting.,"def solve(N):
    return '{0:b}'.format(sum(int(b) for b in bin(N)[2:]))",useful
This function sums the bits in N's binary representation and uses an f-string to output the binary of that sum.,"def solve(N):
    return f'{sum(int(b) for b in bin(N)[2:]):b}'",useful
"This function converts N to binary string, joins the digits, and counts the '1's, returning the integer population count instead of binary.","def solve(N):
    return ''.join(str(int(b)) for b in bin(N)[2:]).count('1')",not useful
This function uses map to sum the integer binary digits of N and then converts that sum to a binary string.,"def solve(N):
    return bin(sum(map(int, bin(N)[2:])))[2:]",useful
This function sums the binary digits of N using map and formats the result as binary.,"def solve(N):
    return format(sum(map(int, bin(N)[2:])), 'b')",useful
This function computes the sum of N's binary digits with map and formats it to binary using '{0:b}'.,"def solve(N):
    return '{0:b}'.format(sum(map(int, bin(N)[2:])))",useful
This function sums the bits of N's binary using map and outputs the binary representation via f-string.,"def solve(N):
    return f'{sum(map(int, bin(N)[2:])):b}'",useful
"This function extracts binary digits of N as strings, joins them, and counts occurrences of '1', returning the popcount integer.","def solve(N):
    return ''.join(str(int(b)) for b in bin(N)[2:]).count('1')",not useful
This function sums the even numbers from the list at odd indices (1-based positioning) using a generator expression with modulo checks.,"def add(lst):
    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)",useful
"This function iterates over the list with enumerate to sum values at odd indices that are even, using modulo for both index and value checks.","def add(lst):
    return sum(v for i, v in enumerate(lst) if i % 2 != 0 and v % 2 == 0)",useful
This function slices the list to get elements at odd indices and uses filter with a lambda to sum only the even values among them.,"def add(lst):
    return sum(filter(lambda x: x % 2 == 0, lst[1::2]))",useful
"This function uses a generator to sum elements at odd indices (0-based) that are even, checking both conditions with modulo.","def add(lst):
    return sum(lst[i] for i in range(len(lst)) if i % 2 != 0 and lst[i] % 2 == 0)",useful
This function slices the list for odd indices and sums the even values using enumerate on the slice with a modulo check.,"def add(lst):
    return sum(v for i, v in enumerate(lst[1::2]) if v % 2 == 0)",useful
This function sums even numbers at odd indices using a generator and bitwise AND to check for evenness (not odd).,"def add(lst):
    return sum(lst[i] for i in range(1, len(lst), 2) if not lst[i] & 1)",useful
This function uses enumerate to sum values where the index is odd (i % 2 truthy) and the value is even (not v % 2).,"def add(lst):
    return sum(v for i, v in enumerate(lst) if i % 2 and not v % 2)",useful
"This function sums elements at odd indices that are even, using bitwise shift to check if the number equals itself after right-shift by 1 and left-shift back.","def add(lst):
    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] >> 1 << 1 == lst[i])",useful
This function slices the list for odd indices and sums even values using enumerate with bitwise AND for even check.,"def add(lst):
    return sum(v for i, v in enumerate(lst[1::2]) if not v & 1)",useful
This function sums even numbers at odd indices using bitwise AND with -2 to check if the number is even.,"def add(lst):
    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] & -2 == lst[i])",useful
"This function splits the string into words, sorts alphabetic words by joining sorted characters, and leaves non-alphabetic words unchanged, then rejoins with spaces.","def anti_shuffle(s):
    return ''.join(''.join(sorted(word)) if word.isalpha() else word for word in s.split(' '))",not useful
This function splits the string into words and sorts the characters in each word alphabetically before rejoining with spaces.,"def anti_shuffle(s):
    return ' '.join(''.join(sorted(word)) for word in s.split())",not useful
This function uses map with a lambda to sort characters in each split word and joins them back with spaces.,"def anti_shuffle(s):
    return ' '.join(map(lambda word: ''.join(sorted(word)), s.split()))",not useful
"This function splits the string, sorts characters in alphabetic words only, leaves others unchanged, and rejoins with spaces.","def anti_shuffle(s):
    return ' '.join(sorted(word) if word.isalpha() else word for word in s.split())",not useful
"This function splits the string by spaces, sorts characters in alphabetic words, preserves non-alphabetic ones, and rejoins with spaces.","def anti_shuffle(s):
    return ' '.join(sorted(word) if word.isalpha() else word for word in s.split(' '))",not useful
This function applies a lambda via map to sort characters in each word from the split string and joins with spaces.,"def anti_shuffle(s):
    return ' '.join(map(lambda word: ''.join(sorted(word)), s.split(' ')))",not useful
"This function splits the string, sorts characters only in alphabetic words, keeps others intact, and rejoins with spaces.","def anti_shuffle(s):
    return ' '.join(sorted(word) if word.isalpha() else word for word in s.split())",not useful
This function maps a lambda over split words to sort their characters alphabetically and joins the results with spaces.,"def anti_shuffle(s):
    return ' '.join(map(lambda word: ''.join(sorted(word)), s.split()))",not useful
"This function processes split words by sorting characters in alphabetic ones, preserving non-alphabetic, and rejoins with spaces.","def anti_shuffle(s):
    return ' '.join(sorted(word) if word.isalpha() else word for word in s.split(' '))",not useful
This function uses map with a lambda to sort characters in each word from the split string and rejoins with spaces.,"def anti_shuffle(s):
    return ' '.join(map(lambda word: ''.join(sorted(word)), s.split(' ')))",not useful
"This function finds all (row, col) positions where the value equals x in the nested list and sorts them by row ascending, then column descending.","def get_row(lst, x):
    return sorted([(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x], key=lambda x: (x[0], -x[1]))",useful
"This function collects coordinates of x in the 2D list using nested loops and sorts by row ascending, column descending.","def get_row(lst, x):
    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(coords, key=lambda x: (x[0], -x[1]))",not useful
"This function uses nested loops to gather (i, j) positions where lst[i][j] == x and sorts by row ascending, column descending.","def get_row(lst, x):
    coords = []
    for i in range(len(lst)):
        for j in range(len(lst[i])):
            if lst[i][j] == x:
                coords.append((i, j))
    return sorted(coords, key=lambda x: (x[0], -x[1]))",useful
"This function iterates with enumerate over rows and columns to collect positions of x, then sorts by row ascending and column descending.","def get_row(lst, x):
    coords = []
    for i, row in enumerate(lst):
        for j, val in enumerate(row):
            if val == x:
                coords.append((i, j))
    return sorted(coords, key=lambda x: (x[0], -x[1]))",useful
"This function uses loops over rows and list comprehensions per row to collect positions of x, then sorts by row and reverse column.","def get_row(lst, x):
    coords = []
    for i in range(len(lst)):
        coords.extend([(i, j) for j, val in enumerate(lst[i]) if val == x])
    return sorted(coords, key=lambda x: (x[0], -x[1]))",useful
"This function employs enumerate for rows and list comprehensions for columns to gather x positions, sorting by row ascending and column descending.","def get_row(lst, x):
    coords = []
    for i, row in enumerate(lst):
        coords.extend([(i, j) for j, val in enumerate(row) if val == x])
    return sorted(coords, key=lambda x: (x[0], -x[1]))",useful
"This function builds a list of (i, j) where lst[i][j] == x using nested loops, then sorts in place by row ascending and column descending.","def get_row(lst, x):
    coords = []
    for i in range(len(lst)):
        for j in range(len(lst[i])):
            if lst[i][j] == x:
                coords.append((i, j))
    coords.sort(key=lambda x: (x[0], -x[1]))
    return coords",useful
"This function collects positions of x with enumerate on rows and range on columns, then sorts in place by row and reverse column.","def get_row(lst, x):
    coords = []
    for i, row in enumerate(lst):
        for j in range(len(row)):
            if row[j] == x:
                coords.append((i, j))
    coords.sort(key=lambda x: (x[0], -x[1]))
    return coords",useful
"This function loops over rows and uses list comprehensions to extend coordinates of x, then sorts by row ascending and column descending.","def get_row(lst, x):
    coords = []
    for i in range(len(lst)):
        coords.extend([(i, j) for j in range(len(lst[i])) if lst[i][j] == x])
    return sorted(coords, key=lambda x: (x[0], -x[1]))",useful
"This function gathers x positions by extending lists per row with comprehensions, then sorts in place by row and reverse column.","def get_row(lst, x):
    coords = []
    for i in range(len(lst)):
        coords.extend([(i, j) for j in range(len(lst[i])) if lst[i][j] == x])
    coords.sort(key=lambda x: (x[0], -x[1]))
    return coords",useful
"This function sorts the array in descending order if the sum of first and last elements is even, otherwise ascending.","def sort_array(array):
    return sorted(array, reverse=(array[0] + array[-1]) % 2 == 0)",not useful
"This function returns a copy of the array if length < 2; otherwise sorts descending if first + last sum is even, else ascending.","def sort_array(array):
    return array[:] if len(array) < 2 else sorted(array, reverse=(array[0] + array[-1]) % 2 == 0)",useful
"This function handles short arrays by copying them; for longer ones, sorts descending if first + last sum even, else ascending.","def sort_array(array):
    if len(array) < 2:
        return array[:]
    else:
        return sorted(array, reverse=(array[0] + array[-1]) % 2 == 0)",useful
This function returns a copy for empty or single-element arrays; otherwise sorts based on parity of first + last sum (descending if even).,"def sort_array(array):
    if not array or len(array) == 1:
        return array[:]
    else:
        return sorted(array, reverse=(array[0] + array[-1]) % 2 == 0)",useful
"This function copies short arrays; for others, sorts descending if first + last sum even, ascending otherwise.","def sort_array(array):
    if len(array) < 2:
        return array.copy()
    else:
        return sorted(array, reverse=(array[0] + array[-1]) % 2 == 0)",useful
This function copies arrays shorter than 2; otherwise sorts with reverse based on whether first + last sum is odd (not %2).,"def sort_array(array):
    if len(array) < 2:
        return array[:]
    else:
        return sorted(array, reverse=not (array[0] + array[-1]) % 2)",not useful
"This function uses copy for short arrays and sorts longer ones descending if first + last sum odd, ascending if even.","def sort_array(array):
    if len(array) < 2:
        return array.copy()
    else:
        return sorted(array, reverse=not (array[0] + array[-1]) % 2)",not useful
"This function copies short arrays; for others, sorts descending if first + last sum is odd (bool %2).","def sort_array(array):
    if len(array) < 2:
        return array[:]
    else:
        return sorted(array, reverse=bool((array[0] + array[-1]) % 2))",not useful
This function handles short arrays with copy and sorts longer ones descending if first + last sum odd.,"def sort_array(array):
    if len(array) < 2:
        return array.copy()
    else:
        return sorted(array, reverse=bool((array[0] + array[-1]) % 2))",not useful
"This function copies short arrays; for longer, sorts descending if first + last sum is odd (bitwise &1).","def sort_array(array):
    if len(array) < 2:
        return array[:]
    else:
        return sorted(array, reverse=(array[0] + array[-1]) & 1)",not useful
"This function performs a Caesar cipher shift of 4 positions on lowercase letters, wrapping around the alphabet using modulo 26.","def encrypt(s):
    return ''.join([chr((ord(c) - 97 + 4) % 26 + 97) for c in s])",not useful
"This function shifts lowercase letters by 8 positions using bitwise AND with 25 for wrapping, then converts back to characters.","def encrypt(s):
    return ''.join([chr(((ord(c) - 97 + 8) & 25) + 97) for c in s])",not useful
"This function applies an 8-position Caesar shift to lowercase letters only, leaving others unchanged, with modulo wrapping.","def encrypt(s):
    return ''.join([chr((ord(c) - 97 + 8) % 26 + 97) if c.islower() else c for c in s])",useful
"This function shifts letters between 'a' and 'z' by 8 positions using modulo 26, preserving non-lowercase characters.","def encrypt(s):
    return ''.join([chr((ord(c) - 97 + 8) % 26 + 97) if 'a' <= c <= 'z' else c for c in s])",useful
"This function performs an 8-shift Caesar cipher on lowercase alphabetic characters only, leaving others intact with modulo wrapping.","def encrypt(s):
    return ''.join([chr((ord(c) - 97 + 8) % 26 + 97) if c.isalpha() and c.islower() else c for c in s])",useful
"This function shifts characters in the alphabet by 8 positions using modulo, leaving non-alphabetic characters unchanged.","def encrypt(s):
    return ''.join([chr((ord(c) - 97 + 8) % 26 + 97) if c in 'abcdefghijklmnopqrstuvwxyz' else c for c in s])",not useful
"This function converts the string to lowercase, then shifts 'a'-'z' letters by 8 positions with modulo wrapping.","def encrypt(s):
    return ''.join([chr((ord(c) - 97 + 8) % 26 + 97) if 'a' <= c <= 'z' else c for c in s.lower()])",useful
This function lowercases the string and applies an 8-position shift to alphabetic characters using modulo 26.,"def encrypt(s):
    return ''.join([chr((ord(c) - 97 + 8) % 26 + 97) if c.isalpha() else c for c in s.lower()])",useful
"This function lowercases the input and shifts alphabet characters by 8, preserving non-alphabetic with modulo wrapping.","def encrypt(s):
    return ''.join([chr((ord(c) - 97 + 8) % 26 + 97) if c in 'abcdefghijklmnopqrstuvwxyz' else c for c in s.lower()])",useful
"This function lowercases the string and applies an 8-shift to lowercase letters only, using modulo for wrapping.","def encrypt(s):
    return ''.join([chr((ord(c) - 97 + 8) % 26 + 97) if c.islower() else c for c in s.lower()])",not useful
"This function finds the second smallest unique number in the list by tracking the smallest (a) and next smallest (b) values during a single pass, returning None if fewer than two unique elements exist.","def next_smallest(lst):
    a = b = float('inf')
    for i in lst:
        if i < a:
            a, b = i, a
        elif i < b and i != a:
            b = i
    return None if b == float('inf') else b",useful
"This function identifies the second smallest unique element by creating a set to remove duplicates, removing the minimum, and returning the new minimum if at least two unique elements exist, otherwise None.","def next_smallest(lst):
    s = set(lst)
    if len(s) < 2:
        return None
    s.remove(min(s))
    return min(s)",useful
"This function sorts the unique elements from the list and returns the second element if there are at least two, otherwise None.","def next_smallest(lst):
    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]",useful
"This function converts the list to a set to remove duplicates, sorts it, and returns the second element if the list has at least two elements, otherwise None.","def next_smallest(lst):
    lst = list(set(lst))
    if len(lst) < 2:
        return None
    lst.sort()
    return lst[1]",useful
"This function removes duplicates using dict.fromkeys, checks for at least two elements, removes the minimum, and returns the new minimum.","def next_smallest(lst):
    lst = list(dict.fromkeys(lst))
    if len(lst) < 2:
        return None
    lst.remove(min(lst))
    return min(lst)",useful
"This function removes duplicates with a set, sorts the list, and returns the second element if there are at least two unique elements, otherwise None.","def next_smallest(lst):
    lst = list(set(lst))
    if len(lst) < 2:
        return None
    lst.sort()
    return lst[1]",useful
"This function sorts the unique elements from the list and returns the second smallest if more than one unique element exists, otherwise None.","def next_smallest(lst):
    lst = sorted(list(set(lst)))
    return lst[1] if len(lst) > 1 else None",useful
"This function removes duplicates using a set, sorts the list, and returns the second element if at least two unique elements are present, otherwise None.","def next_smallest(lst):
    lst = list(set(lst))
    if len(lst) < 2:
        return None
    lst.sort()
    return lst[1]",useful
"This function sorts the set of unique elements and returns the second one if the set has more than one element, otherwise None.","def next_smallest(lst):
    lst = sorted(set(lst))
    return lst[1] if len(lst) > 1 else None",useful
"This function converts the list to a set to eliminate duplicates, sorts it, and returns the second smallest element if there are at least two, otherwise None.","def next_smallest(lst):
    lst = list(set(lst))
    if len(lst) < 2:
        return None
    lst.sort()
    return lst[1]",useful
This function splits the string by '. ' and counts how many resulting sentences start with 'I' using a generator expression.,def is_bored(S): return sum(1 for s in S.split('. ') if s.startswith('I')),useful
This function splits the string by '. ' and returns the length of the list comprehension that filters sentences starting with 'I'.,def is_bored(S): return len([s for s in S.split('. ') if s.startswith('I')]),useful
This function uses a generator to sum the boolean results of checking if each sentence from splitting by '. ' starts with 'I'.,def is_bored(S): return sum(s.startswith('I') for s in S.split('. ')),useful
This function splits the string by '. ' and sums the checks for whether the first character of each sentence is 'I'.,def is_bored(S): return sum(s[0] == 'I' for s in S.split('. ')),not useful
This function splits the string by '. ' and returns the count of sentences where the first character is 'I' using list comprehension.,def is_bored(S): return len([s for s in S.split('. ') if s[0] == 'I']),not useful
This function uses regex to split the string by sentence-ending punctuation and sums the sentences starting with 'I'.,"def is_bored(S): return sum(s.startswith('I') for s in re.split('[.?!]', S))",not useful
This function splits the string using regex on punctuation and returns the length of the list of sentences starting with 'I'.,"def is_bored(S): return len([s for s in re.split('[.?!]', S) if s.startswith('I')])",not useful
This function uses regex to split by punctuation and sums the boolean checks for sentences starting with 'I' via first character.,"def is_bored(S): return sum(s[0] == 'I' for s in re.split('[.?!]', S))",not useful
This function splits with regex on punctuation and counts sentences where the first character is 'I' using list comprehension.,"def is_bored(S): return len([s for s in re.split('[.?!]', S) if s[0] == 'I'])",not useful
"This function splits the string using regex on punctuation, strips whitespace, and sums sentences starting with 'I'.","def is_bored(S): return sum(s.strip().startswith('I') for s in re.split('[.?!]', S))",useful
This function checks if all inputs are integers and if one is the sum of the other two using explicit isinstance checks and conditions.,"def any_int(x, y, z):
    return isinstance(x, int) and isinstance(y, int) and isinstance(z, int) and (x == y + z or y == x + z or z == x + y)",useful
"This function uses all() with isinstance to verify integers, then checks if any one variable equals the sum of the other two, returning False otherwise.","def any_int(x, y, z):
    if all(isinstance(i, int) for i in (x, y, z)):
        return x + y == z or x + z == y or y + z == x
    return False",useful
"This function employs map and lambda with isinstance to check all are integers, then verifies if one is the sum of the others.","def any_int(x, y, z):
    return all(map(lambda i: isinstance(i, int), (x, y, z))) and (x + y == z or x + z == y or y + z == x)",useful
"This function explicitly checks each input with isinstance for being int, then tests the sum conditions, returning False if not all integers.","def any_int(x, y, z):
    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):
        return x + y == z or x + z == y or y + z == x
    return False",useful
"This function uses type() equality to confirm all are int, then checks the Pythagorean-like sum conditions.","def any_int(x, y, z):
    return type(x) == int and type(y) == int and type(z) == int and (x + y == z or x + z == y or y + z == x)",not useful
"This function applies map and lambda with type() == int to check all integers, followed by sum condition verification.","def any_int(x, y, z):
    return all(map(lambda i: type(i) == int, (x, y, z))) and (x + y == z or x + z == y or y + z == x)",useful
"This function checks each type() == int explicitly, tests sum conditions if true, otherwise returns False.","def any_int(x, y, z):
    if type(x) == int and type(y) == int and type(z) == int:
        return x + y == z or x + z == y or y + z == x
    return False",useful
"This function uses map and lambda to check if each equals int(it), then verifies sum conditions; note this may not handle all non-int cases correctly.","def any_int(x, y, z):
    return all(map(lambda i: i == int(i), (x, y, z))) and (x + y == z or x + z == y or y + z == x)",not useful
"This function checks if each equals its integer cast, then tests sum conditions if all pass, otherwise False.","def any_int(x, y, z):
    if x == int(x) and y == int(y) and z == int(z):
        return x + y == z or x + z == y or y + z == x
    return False",not useful
"This function uses map and lambda with is_integer() method (assuming floats), then checks sum conditions; suitable for numeric inputs including floats.","def any_int(x, y, z):
    return all(map(lambda i: i.is_integer(), (x, y, z))) and (x + y == z or x + z == y or y + z == x)",not useful
"This function applies a ROT13-like translation to all characters, then replaces vowels with a specific mapping using two translate calls.","def encode(message):
    vowels = 'aeiouAEIOU'
    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB')
    return message.translate(trans).translate(str.maketrans(vowels, 'iguoeIUOE'))",not useful
"This function creates a ROT13 translation table but applies it only to non-vowels, replacing vowels with characters from 'iguoeIUOE' based on index.","def encode(message):
    vowels = 'aeiouAEIOU'
    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB')
    return ''.join([trans[c] if c not in vowels else 'iguoeIUOE'[vowels.index(c)] for c in message])",not useful
This function uses a generator to apply ROT13 translation to non-vowels and replace vowels with mapped characters from 'iguoeIUOE'.,"def encode(message):
    vowels = 'aeiouAEIOU'
    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB')
    return ''.join(trans[c] if c not in vowels else 'iguoeIUOE'[vowels.index(c)] for c in message)",not useful
"This function attempts to translate non-vowels with ROT13 and map vowels, but the condition 'c in trans' may not work as intended since trans is a table.","def encode(message):
    vowels = 'aeiouAEIOU'
    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB')
    return ''.join(trans[c] if c in trans else 'iguoeIUOE'[vowels.index(c)] for c in message)",not useful
"This function checks if characters are in the translation table keys for ROT13, otherwise maps vowels; however, trans.keys() is not standard for str.maketrans.","def encode(message):
    vowels = 'aeiouAEIOU'
    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB')
    return ''.join(trans[c] if c in trans.keys() else 'iguoeIUOE'[vowels.index(c)] for c in message)",not useful
"This function first translates the entire message with ROT13, then attempts to replace vowels in the result, but the condition may not correctly identify vowels post-translation.","def encode(message):
    vowels = 'aeiouAEIOU'
    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB')
    return ''.join(trans[c] if c in trans else 'iguoeIUOE'[vowels.index(c)] for c in message.translate(trans))",not useful
"This function applies ROT13 only to non-vowels and uses str.find for vowel indexing to map to 'iguoeIUOE', but find returns -1 for non-vowels causing errors.","def encode(message):
    vowels = 'aeiouAEIOU'
    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB')
    return ''.join(trans[c] if c in trans else 'iguoeIUOE'[vowels.find(c)] for c in message)",not useful
"This function translates the message with ROT13 first, then tries to map vowels in the translated string using find, which may lead to errors for non-vowels.","def encode(message):
    vowels = 'aeiouAEIOU'
    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB')
    return ''.join(trans[c] if c in trans else 'iguoeIUOE'[vowels.find(c)] for c in message.translate(trans))",not useful
"This function applies ROT13 to non-vowels but uses lower() for vowel indexing, which mismatches case in 'iguoeIUOE' and may cause index errors.","def encode(message):
    vowels = 'aeiouAEIOU'
    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB')
    return ''.join(trans[c] if c in trans else 'iguoeIUOE'[vowels.index(c.lower())] for c in message)",not useful
"This function translates with ROT13 first, then maps vowels in the result using lower() for indexing, potentially causing case mismatches and errors.","def encode(message):
    vowels = 'aeiouAEIOU'
    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB')
    return ''.join(trans[c] if c in trans else 'iguoeIUOE'[vowels.index(c.lower())] for c in message.translate(trans))",not useful
"This function defines an is_prime helper, finds the max prime in the list, converts it to string, and sums its digits; assumes primes exist.","def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    return sum(int(d) for d in str(max(n for n in lst if is_prime(n))))",not useful
"This function uses an is_prime helper to filter primes, finds the max if any exist (else 0), converts to string, and sums digits.","def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    primes = [n for n in lst if is_prime(n)]
    return sum(int(d) for d in str(max(primes))) if primes else 0",useful
"This function employs an is_prime helper, uses max with generator and default=0 for the largest prime, then sums its digits.","def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    largest_prime = max((n for n in lst if is_prime(n)), default=0)
    return sum(int(d) for d in str(largest_prime))",useful
"This function filters primes with is_prime, takes max if primes exist (else 0), and sums digits using map(int, str()).","def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    primes = [n for n in lst if is_prime(n)]
    return sum(map(int, str(max(primes)))) if primes else 0",useful
"This function uses is_prime to filter with max and default=0, then sums the digits of the largest prime.","def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    largest_prime = max(filter(is_prime, lst), default=0)
    return sum(int(d) for d in str(largest_prime))",useful
"This function filters primes, uses max with default=0, and sums digits with map(int, str()).","def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    primes = [n for n in lst if is_prime(n)]
    return sum(map(int, str(max(primes, default=0))))",useful
"This function finds the max prime with generator and default=None, sums digits if prime exists, else 0.","def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    largest_prime = max((n for n in lst if is_prime(n)), default=None)
    return sum(int(d) for d in str(largest_prime)) if largest_prime else 0",useful
"This function filters primes, uses max with default='0' (string), then sums digits; may cause int conversion error on '0'.","def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    primes = [n for n in lst if is_prime(n)]
    return sum(map(int, str(max(primes, default='0'))))",not useful
"This function uses filter with is_prime and max default=None, sums digits if prime found, else 0.","def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    largest_prime = max(filter(is_prime, lst), default=None)
    return sum(int(d) for d in str(largest_prime)) if largest_prime else 0",useful
"This function filters primes, conditionally uses max with default=0 if primes exist, and sums digits with map.","def skjkasdkd(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    primes = [n for n in lst if is_prime(n)]
    return sum(map(int, str(max(primes, default=0)))) if primes else 0",useful
This function checks if all string keys in the dictionary are either entirely lowercase or entirely uppercase by using generator expressions with all() to verify case consistency for string keys only.,"def check_dict_case(d):
    return all(isinstance(k, str) and k.islower() for k in d) or all(isinstance(k, str) and k.isupper() for k in d)",not useful
"This function determines if all string keys have the same case by creating a set of their islower() results and checking if it contains exactly one unique value, ignoring non-string keys.","def check_dict_case(d):
    return len(set(k.islower() for k in d if isinstance(k, str))) == 1",not useful
"This function iterates through the dictionary keys, counting how many string keys are entirely lowercase or uppercase, and returns True if all string keys are of one consistent case.","def check_dict_case(d):
    lower, upper = 0, 0
    for k in d:
        if isinstance(k, str):
            lower += k.islower()
            upper += k.isupper()
    return lower == 0 or upper == 0",not useful
This function verifies that all string keys are either all lowercase or all uppercase by applying all() to filtered keys from d.keys() that are strings.,"def check_dict_case(d):
    return all(k.islower() for k in d.keys() if isinstance(k, str)) or all(k.isupper() for k in d.keys() if isinstance(k, str))",useful
This function creates a set of isupper() flags for string keys (using None for non-strings) and checks if the set has exactly one element to ensure case consistency.,"def check_dict_case(d):
    return len(set(k.isupper() if isinstance(k, str) else None for k in d)) == 1",not useful
"This function filters string keys and uses all() to check if they are all lowercase or all uppercase, returning True for empty or non-string key sets.","def check_dict_case(d):
    return all(k.islower() for k in d if isinstance(k, str)) or all(k.isupper() for k in d if isinstance(k, str))",useful
This function checks for consistent case in string keys by ensuring the set of islower() values from d.keys() has exactly one unique element.,"def check_dict_case(d):
    return len(set(k.islower() for k in d.keys() if isinstance(k, str))) == 1",not useful
This function verifies uniform case for string keys using all() and explicitly returns True for empty dictionaries.,"def check_dict_case(d):
    return all(k.islower() for k in d if isinstance(k, str)) or all(k.isupper() for k in d if isinstance(k, str)) or not d",useful
"This function checks the set of isupper() values for string keys and returns True if its length is 0 or equals the dictionary length, aiming to confirm case uniformity.","def check_dict_case(d):
    return len(set(k.isupper() for k in d if isinstance(k, str))) in (0, len(d))",not useful
This function checks if all string keys are the same case using all() and handles empty dictionaries by returning True when len(d) == 0.,"def check_dict_case(d):
    return all(k.islower() for k in d if isinstance(k, str)) or all(k.isupper() for k in d if isinstance(k, str)) or len(d) == 0",useful
"This implements the Sieve of Eratosthenes by initializing a boolean array and marking multiples of each prime starting from 2 up to n, then collecting unmarked indices as primes.","def count_up_to(n):
    primes = [True] * n
    p = 2
    while p * p <= n:
        if primes[p]:
            for i in range(p * p, n, p):
                primes[i] = False
        p += 1
    return [p for p in range(2, n) if primes[p]]",useful
"This uses an optimized Sieve of Eratosthenes, iterating up to the square root of n to mark multiples starting from x squared, and returns the list of primes.","def count_up_to(n):
    sieve = [True] * n
    for x in range(2, int(n**0.5) + 1):
        if sieve[x]:
            for i in range(x*x, n, x):
                sieve[i] = False
    return [x for x in range(2, n) if sieve[x]]",useful
"This finds primes up to n using trial division, checking each candidate number for divisibility by integers up to its square root.","def count_up_to(n):
    primes = []
    for possiblePrime in range(2, n):
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return primes",useful
This incrementally builds a list of primes by checking each candidate against divisibility by previously identified primes.,"def count_up_to(n):
    primes = []
    for possiblePrime in range(2, n):
        if all(possiblePrime % prime != 0 for prime in primes):
            primes.append(possiblePrime)
    return primes",useful
This identifies primes by testing each number from 2 to n-1 for divisibility against all integers from 2 up to its square root.,"def count_up_to(n):
    primes = []
    for num in range(2, n):
        if all(num % i != 0 for i in range(2, int(num**0.5) + 1)):
            primes.append(num)
    return primes",useful
"This applies the Sieve of Eratosthenes with an outer loop up to n, marking multiples of each unmarked number starting from its square.","def count_up_to(n):
    sieve = [True] * n
    for x in range(2, n):
        if sieve[x]:
            for u in range(x*x, n, x):
                sieve[u] = False
    return [i for i in range(2, n) if sieve[i]]",useful
This determines primes using trial division by checking divisibility against all smaller positive integers up to num-1.,"def count_up_to(n):
    primes = []
    for num in range(2, n):
        if all(num % i != 0 for i in range(2, num)):
            primes.append(num)
    return primes",useful
"This uses naive trial division to find primes, testing each possible prime against all smaller numbers for divisibility.","def count_up_to(n):
    primes = []
    for possiblePrime in range(2, n):
        isPrime = True
        for num in range(2, possiblePrime):
            if possiblePrime % num == 0:
                isPrime = False
        if isPrime:
            primes.append(possiblePrime)
    return primes",useful
This efficiently implements the Sieve of Eratosthenes by marking multiples only up to the square root of n and collecting surviving primes.,"def count_up_to(n):
    sieve = [True] * n
    for x in range(2, int(n**0.5) + 1):
        if sieve[x]:
            for i in range(x*x, n, x):
                sieve[i] = False
    return [x for x in range(2, n) if sieve[x]]",not useful
"This finds primes through trial division, verifying each number by checking non-divisibility against all preceding integers.","def count_up_to(n):
    primes = []
    for num in range(2, n):
        if all(num % i != 0 for i in range(2, num)):
            primes.append(num)
    return primes",useful
This function multiplies the absolute values of the last digits of a and b using modulo 10.,"def multiply(a, b):
    return abs(a % 10) * abs(b % 10)",useful
"This extracts the last four bits of a and b using bitwise AND with 0xf and multiplies them, suitable for small non-negative integers.","def multiply(a, b):
    return (a & 0xf) * (b & 0xf)",not useful
"This converts a and b to strings, extracts the last characters as integers, and multiplies them to get the product of the last digits.","def multiply(a, b):
    return int(str(a)[-1]) * int(str(b)[-1])",useful
"This uses divmod to obtain the remainders when dividing a and b by 10, effectively getting the last digits, and multiplies them.","def multiply(a, b):
    return divmod(a, 10)[1] * divmod(b, 10)[1]",useful
"This computes the absolute last digits of a and b using modulo 10 and multiplies them, though the list indexing is redundant.","def multiply(a, b):
    return [abs(a % 10), abs(b % 10)][0] * [abs(a % 10), abs(b % 10)][1]",not useful
This derives the product of the last digits using a formula involving integer division and modulo to sum and subtract components.,"def multiply(a, b):
    return (a // 10 + a % 10) * (b // 10 + b % 10) - a // 10 * b // 10",not useful
"This uses complex bitwise shifts to extract components resembling digits and multiplies them, likely intended for specific binary representations.","def multiply(a, b):
    return (a >> 4 * (a >> 15 & 1) + 4 * (a >> 12 & 1) + 2 * (a >> 9 & 1) + (a >> 6 & 1)) * (b >> 4 * (b >> 15 & 1) + 4 * (b >> 12 & 1) + 2 * (b >> 9 & 1) + (b >> 6 & 1))",not useful
This calculates the product of last digits through an algebraic identity using floor division and modulo operations.,"def multiply(a, b):
    return (a // 10 + a % 10) * (b // 10 + b % 10) - a // 10 * b // 10",not useful
"This multiplies the last digits of a and b, adjusting for signs by negating one operand if they differ in sign.","def multiply(a, b):
    return (a % 10) * (b % 10) if a >= 0 and b >= 0 else (a % 10) * (-b % 10)",not useful
"This multiplies the last digits and applies a negative sign if a and b have opposite signs, otherwise positive.","def multiply(a, b):
    return (a % 10) * (b % 10) if a * b >= 0 else -(a % 10) * (b % 10)",not useful
This counts occurrences of uppercase vowels in even-indexed positions by summing a generator over every second character starting from 0.,"def count_upper(s):
    return sum(1 for i in range(0, len(s), 2) if s[i] in 'AEIOU')",useful
"This uses a list comprehension with enumerate to filter even indices and uppercase vowels, then returns the list length.","def count_upper(s):
    return len([c for i, c in enumerate(s) if i % 2 == 0 and c in 'AEIOU'])",useful
This sums boolean checks for uppercase vowels using enumerate to access indices and characters at even positions.,"def count_upper(s):
    return sum(c in 'AEIOU' for i, c in enumerate(s) if i % 2 == 0)",useful
This directly sums membership checks for uppercase vowels by iterating over even indices with range and step 2.,"def count_upper(s):
    return sum(s[i] in 'AEIOU' for i in range(0, len(s), 2))",useful
This employs a set for efficient vowel lookup while summing checks over even indices in the string.,"def count_upper(s):
    vowels = set('AEIOU')
    return sum(s[i] in vowels for i in range(0, len(s), 2))",useful
This slices the string to even positions using s[::2] and sums the count of characters that are uppercase vowels.,"def count_upper(s):
    return sum(c in 'AEIOU' for c in s[::2])",useful
This builds a list of 1s for each uppercase vowel at even positions and returns its length.,"def count_upper(s):
    return len([1 for i in range(0, len(s), 2) if s[i] in 'AEIOU'])",useful
"This sums vowel membership over all indices, filtering for even positions using modulo in the generator.","def count_upper(s):
    return sum(s[i] in 'AEIOU' for i in range(len(s)) if i % 2 == 0)",useful
This counts characters at even positions that are both uppercase and vowels using isupper() and membership checks.,"def count_upper(s):
    return sum(1 for i in range(0, len(s), 2) if s[i].isupper() and s[i] in 'AEIOU')",useful
This slices the string to even positions and counts the number of uppercase vowels in the resulting substring using a list comprehension.,"def count_upper(s):
    return len([c for c in s[::2] if c in 'AEIOU'])",useful
"This rounds the float value to the nearest integer by adding 0.5 for positive numbers or subtracting 0.5 for negative, then casting to int.","def closest_integer(value):
    return int(float(value) + 0.5 * (1 if float(value) > 0 else -1))",useful
"This uses eval to convert the string to float, then applies rounding by adding or subtracting 0.5 based on sign before integer conversion.","def closest_integer(value):
    return int(eval(value) + 0.5 * (1 if eval(value) > 0 else -1))",not useful
This imports math and uses floor for positive values (adding 0.5) or ceil for negative values (subtracting 0.5) to round to nearest integer.,"import math
def closest_integer(value):
    return int(math.floor(float(value) + 0.5) if float(value) > 0 else math.ceil(float(value) - 0.5))",useful
"This converts the string to float and rounds by adding 0.5 if positive or subtracting 0.5 if negative, then takes the integer part.","def closest_integer(value):
    num = float(value)
    return int(num + 0.5) if num > 0 else int(num - 0.5)",useful
This parses the string to float and adds 0.5 for positive or -0.5 for negative values before converting to int for rounding.,"def closest_integer(value):
    num = float(value)
    return int(num + (0.5 if num > 0 else -0.5))",useful
This handles integer values directly and for non-integers adds 0.5 or -0.5 based on sign before integer conversion.,"def closest_integer(value):
    num = float(value)
    return int(num + (0 if num == int(num) else 0.5 * (1 if num > 0 else -1)))",useful
"This checks if the float is already an integer and returns it directly; otherwise, rounds by adding or subtracting 0.5 based on sign.","def closest_integer(value):
    num = float(value)
    return int(num) if num == int(num) else int(num + 0.5) if num > 0 else int(num - 0.5)",useful
This uses is_integer() to detect whole numbers and applies sign-based 0.5 adjustment for rounding non-integers to nearest int.,"def closest_integer(value):
    num = float(value)
    return int(num) if num.is_integer() else int(num + 0.5) if num > 0 else int(num - 0.5)",useful
This detects integers via modulo 1 and rounds non-integers by adding 0.5 for positive or subtracting 0.5 for negative before int conversion.,"def closest_integer(value):
    num = float(value)
    return int(num) if num % 1 == 0 else int(num + 0.5) if num > 0 else int(num - 0.5)",useful
This checks for integer values with is_integer() and rounds others by adding 0.5 or -0.5 depending on the sign.,"def closest_integer(value):
    num = float(value)
    return int(num) if num.is_integer() else int(num + (0.5 if num > 0 else -0.5))",useful
"This function generates a list of n integers starting from n, where each element increases by (1 + n % 2), which is 1 for even n and 2 for odd n, using a list comprehension.","def make_a_pile(n):
    return [n + i * (1 + n % 2) for i in range(n)]",useful
"This function creates a list of n numbers starting at n, incrementing by (2 - n % 2), resulting in steps of 2 for even n and 1 for odd n, via list comprehension.","def make_a_pile(n):
    return [n + i * (2 - n % 2) for i in range(n)]",not useful
"This function builds a list starting from n, adding i multiplied by (n & 1) plus i times 2 times (1 - (n & 1)), effectively using bit operations to set step to 1 if n odd or 2 if even.","def make_a_pile(n):
    return [n + i * (n & 1) + i * 2 * (1 - (n & 1)) for i in range(n)]",not useful
"This function produces a list of n elements starting at n, where each increases by i * (n | 1), using bitwise OR to make the step odd (n if odd, n+1 if even).","def make_a_pile(n):
    return [n + i * (n | 1) for i in range(n)]",not useful
"This function generates a list starting from n, incrementing by i * (n ^ 1), where XOR with 1 flips the least significant bit, making step n-1 if odd or n+1 if even.","def make_a_pile(n):
    return [n + i * (n ^ 1) for i in range(n)]",not useful
"This function creates a list of n numbers from n, adding i * ((n + 1) % 2), which results in increments of 0 or 1 depending on n's parity, but likely incorrect for intended stepping.","def make_a_pile(n):
    return [n + i * (n + 1) % 2 for i in range(n)]",not useful
"This function builds a list starting at n, with each element increased by i * (2 + n % 2), leading to steps of 2 for even n and 3 for odd n using modulo.","def make_a_pile(n):
    return [n + i * (2 + n % 2) for i in range(n)]",not useful
"This function generates a list of n integers from n, incrementing by i * (n % 2 + 1), which gives steps of 1 for even n and 2 for odd n.","def make_a_pile(n):
    return [n + i * (n % 2 + 1) for i in range(n)]",useful
"This function creates a list starting from n, adding i * (n & 1) + i * (n & 2), using bitwise AND to compute increments based on n's lower bits, resulting in variable steps.","def make_a_pile(n):
    return [n + i * (n & 1) + i * (n & 2) for i in range(n)]",not useful
"This function produces a list from n, adding i * ((n - 1) % 2) + i * 2, which simplifies to increments of 2 plus a parity adjustment for n-1.","def make_a_pile(n):
    return [n + i * (n - 1) % 2 + i * 2 for i in range(n)]",not useful
"This function replaces commas in the string s with spaces and splits on whitespace to get a list of words, automatically removing empty strings.","def words_string(s):
    return s.replace(',', ' ').split()",useful
"Using regex, this function splits the string s on either 'comma space' or space, producing a list of words but may include empties if multiple separators.","import re
def words_string(s):
    return re.split(', | ', s)",not useful
"This function replaces commas with spaces, splits on spaces, and filters out empty strings using a list comprehension to return non-empty words.","def words_string(s):
    return [word for word in s.replace(',', ' ').split(' ') if word]",useful
"This function replaces commas with spaces, splits on spaces, and uses filter with None to remove empty strings, converting the result to a list of words.","def words_string(s):
    return list(filter(None, s.replace(',', ' ').split(' ')))",useful
"This function replaces commas with spaces, splits on spaces, and applies str.strip to each part via map to clean and return a list of trimmed words.","def words_string(s):
    return list(map(str.strip, s.replace(',', ' ').split(' ')))",not useful
"Using regex to split on 'comma space' or space, this function strips whitespace from each resulting word in a list comprehension to get clean words.","def words_string(s):
    return [word.strip() for word in re.split(', | ', s)]",not useful
"This function uses regex to split on 'comma space' or space, strips each part with map, and filters out empty strings to return a list of clean words.","def words_string(s):
    return list(filter(None, map(str.strip, re.split(', | ', s))))",not useful
"This function employs regex findall with word boundaries and word characters to extract and return a sorted list? No, unsorted list of words from s, ignoring punctuation.","def words_string(s):
    return [word for word in re.findall(r'\b\w+\b', s)]",useful
This function uses str.translate to replace commas with spaces in s and then splits on whitespace to obtain a list of words.,"def words_string(s):
    return s.translate(str.maketrans(',', ' ')).split()",useful
"This function removes all commas from s and splits on spaces to create a list of words, but may produce empties if commas were separating spaces.","def words_string(s):
    return s.replace(',', '').split(' ')",not useful
"This function computes the largest even number <= y (y - y % 2) and returns it if >= x, otherwise -1.","def choose_num(x, y):
    return y - y % 2 if x <= y - y % 2 else -1",useful
"This function checks if y is even and >= x to return y, or if odd and y-1 >= x to return y-1, else -1, using integer division and modulo.","def choose_num(x, y):
    return (y // 2) * 2 if x <= y and y % 2 == 0 else (y - 1 if x <= y - 1 and y % 2 != 0 else -1)",useful
"This function returns y if even and >= x, y-1 if x <= y-1, else -1, prioritizing even y when possible.","def choose_num(x, y):
    if y % 2 == 0 and x <= y:
        return y
    elif x <= y - 1:
        return y - 1
    else:
        return -1",useful
"This function returns -1 if x > y, otherwise y if even or y-1 if odd, but may return y-1 even if x > y-1 when y odd.","def choose_num(x, y):
    if x > y:
        return -1
    elif y % 2 == 0:
        return y
    else:
        return y - 1",not useful
"This function returns -1 if x > y, else the largest even <= y (y if even, y-1 if odd), without further checks.","def choose_num(x, y):
    if x > y:
        return -1
    return y if y % 2 == 0 else y - 1",not useful
"This function returns -1 if x > y or if x == y and x odd, else largest even <= y, adding an extra condition for odd equality.","def choose_num(x, y):
    if x > y or (x % 2 != 0 and x == y):
        return -1
    return y if y % 2 == 0 else y - 1",useful
"This function returns -1 if x > y, otherwise y minus (y % 2) to get the largest even <= y.","def choose_num(x, y):
    if x > y:
        return -1
    return y - (y % 2)",not useful
"This function returns -1 if x > y, else y minus (y & 1) using bitwise AND to subtract 1 if y odd, yielding largest even <= y.","def choose_num(x, y):
    if x > y:
        return -1
    return y - (y & 1)",not useful
"This function returns -1 if x > y, else y minus 1 if y % 2 == 1 (true is 1), effectively getting largest even <= y.","def choose_num(x, y):
    if x > y:
        return -1
    return y - (y % 2 == 1)",not useful
"This function returns -1 if x > y, else y minus 1 if (y & 1 == 1), using bitwise check to find largest even <= y.","def choose_num(x, y):
    if x > y:
        return -1
    return y - (y & 1 == 1)",not useful
"This function returns -1 if n > m, otherwise the binary string of the rounded average of n and m using round and bin.","def rounded_avg(n, m):
    return -1 if n > m else bin(round((n + m) / 2))",useful
"This function returns -1 if n > m, computes integer average if even sum or rounds if odd, then converts to binary string.","def rounded_avg(n, m):
    if n > m: return -1
    avg = (n + m) // 2 if (n + m) % 2 == 0 else round((n + m) / 2)
    return bin(avg)",useful
"This function returns -1 if n > m, calculates rounded average using integer division with +1 adjustment for odd sums, then to binary.","def rounded_avg(n, m):
    if n > m: return -1
    avg = (n + m + 1) // 2 if (n + m) % 2 else (n + m) // 2
    return bin(avg)",not useful
"This function returns -1 if n > m, computes float average and rounds by adding 0.5 before int, then converts to binary string.","def rounded_avg(n, m):
    if n > m: return -1
    avg = (n + m) / 2
    return bin(int(avg + 0.5))",not useful
"This function returns -1 if n > m, computes floor average and rounds up if sum odd using round, then to binary.","def rounded_avg(n, m):
    if n > m: return -1
    avg = (n + m) // 2
    if (n + m) % 2: avg = round(avg)
    return bin(avg)",not useful
"This function returns -1 if n > m, calculates float average and uses int if integer or round otherwise, then converts to binary string.","def rounded_avg(n, m):
    if n > m: return -1
    avg = (n + m) / 2
    return bin(int(avg) if avg.is_integer() else round(avg))",useful
"This function returns -1 if n > m, computes float average and adds 1 if fractional part >=0.5 for rounding, then to binary via int.","def rounded_avg(n, m):
    if n > m: return -1
    avg = (n + m) / 2
    return bin(int(avg) + (avg % 1 >= 0.5))",not useful
"This function returns -1 if n > m, gets float average and adds 0.5 if fractional part non-zero for rounding, then to binary.","def rounded_avg(n, m):
    if n > m: return -1
    avg = (n + m) / 2
    return bin(int(avg + (0.5 if avg % 1 else 0)))",not useful
"This function returns -1 if n > m, computes float average and adds 1 if fractional >=0.5, converting the result to int then binary.","def rounded_avg(n, m):
    if n > m: return -1
    avg = (n + m) / 2
    return bin(int(avg) + (1 if avg - int(avg) >= 0.5 else 0))",not useful
"This function returns -1 if n > m, calculates float average and adds 1 if fractional >0.499999999999 for rounding, then to binary.","def rounded_avg(n, m):
    if n > m: return -1
    avg = (n + m) / 2
    return bin(int(avg) + (avg % 1 > 0.499999999999))",not useful
"This function filters numbers from x where all digits are odd (not even), using all with modulo check, and sorts the result.","def unique_digits(x):
    return sorted(i for i in x if all(int(d) % 2 != 0 for d in str(i)))",useful
"Using filter with lambda, this function selects numbers from x with all odd digits via modulo on each digit, then sorts them.","def unique_digits(x):
    return sorted(filter(lambda i: all(int(d) % 2 != 0 for d in str(i)), x))",useful
"This function filters numbers from x whose digit string set is disjoint from even digits '02468', then sorts the list.","def unique_digits(x):
    return sorted([i for i in x if set(str(i)).isdisjoint('02468')])",useful
"This function selects numbers from x without any even digits (0,2,4,6,8) using any with in check, and sorts the result.","def unique_digits(x):
    return sorted([i for i in x if not any(int(d) in [0, 2, 4, 6, 8] for d in str(i))])",useful
"This function filters x for numbers lacking even digits using any with map and in check on digit list, then sorts.","def unique_digits(x):
    return sorted([i for i in x if not any(map(lambda d: int(d) in [0, 2, 4, 6, 8], str(i)))])",useful
"This function uses set intersection to check if str(i) has no even digits '02468', filters x accordingly, and sorts.","def unique_digits(x):
    return sorted([i for i in x if not set('02468') & set(str(i))])",useful
"This function filters numbers from x with no characters from '02468' in their string representation using any, then sorts.","def unique_digits(x):
    return sorted([i for i in x if not any(c in '02468' for c in str(i))])",useful
"Using regex search for even digits [02468], this function filters out matching numbers from x and sorts the remaining.","def unique_digits(x):
    return sorted([i for i in x if not re.search('[02468]', str(i))])",useful
"This function checks for no even digit characters in str(i) using any and map(int, str(i)) with in '02468', filters x, and sorts.","def unique_digits(x):
    return sorted([i for i in x if not any(c in '02468' for c in map(int, str(i)))])",not useful
"This function filters numbers from x that contain no even digit characters '02468' using any check, then sorts the list.","def unique_digits(x):
    return sorted([i for i in x if not any(c in '02468' for c in str(i))])",useful
"This function filters numbers from the input array that are between 1 and 9, sorts them in descending order, and maps each to its English name using a predefined list.","def by_length(arr):
    num_names = [""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    return [num_names[i-1] for i in sorted(filter(lambda x: 1 <= x <= 9, arr), reverse=True)]",useful
"This function filters numbers from the input array that are between 1 and 9, sorts them in descending order using a generator expression, and maps each to its English name.","def by_length(arr):
    num_names = [""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    return [num_names[i-1] for i in sorted((x for x in arr if 1 <= x <= 9), reverse=True)]",useful
"This function filters numbers from the input array that are between 1 and 9 into a list, sorts it in descending order, and maps each to its English name.","def by_length(arr):
    num_names = [""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    valid_nums = [i for i in arr if 1 <= i <= 9]
    valid_nums.sort(reverse=True)
    return [num_names[i-1] for i in valid_nums]",useful
"This function creates a list of numbers from the input array that are between 1 and 9, sorts it in descending order, and maps each to its English name.","def by_length(arr):
    num_names = [""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    return [num_names[i-1] for i in sorted([x for x in arr if 1 <= x <= 9], reverse=True)]",useful
"This function sorts the entire input array ascending, filters numbers between 1 and 9, reverses the result, and maps each to its English name; note that this may include invalid numbers if not filtered properly.","def by_length(arr):
    num_names = [""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    return [num_names[i-1] for i in sorted(arr) if 1 <= i <= 9][::-1]",not useful
"This function filters numbers from the input array that are between 1 and 9, sorts them ascending, reverses the list, and maps each to its English name.","def by_length(arr):
    num_names = [""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    valid_nums = [i for i in arr if 1 <= i <= 9]
    valid_nums.sort()
    return [num_names[i-1] for i in valid_nums[::-1]]",useful
"This function sorts the entire input array in descending order, filters numbers between 1 and 9 during list comprehension, and maps each to its English name.","def by_length(arr):
    num_names = [""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    return [num_names[i-1] for i in sorted(arr, reverse=True) if 1 <= i <= 9]",useful
"This function filters numbers from the input array that are between 1 and 9, sorts them ascending, reverses using reversed(), and maps each to its English name.","def by_length(arr):
    num_names = [""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    valid_nums = [i for i in arr if 1 <= i <= 9]
    valid_nums.sort()
    return [num_names[i-1] for i in reversed(valid_nums)]",useful
"This function sorts the entire input array in descending order, filters numbers between 1 and 9 during list comprehension, and maps each to its English name.","def by_length(arr):
    num_names = [""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    return [num_names[i-1] for i in sorted(arr, reverse=True) if 1 <= i <= 9]",useful
"This function filters numbers from the input array that are between 1 and 9 into a list, sorts it in descending order, and maps each to its English name.","def by_length(arr):
    num_names = [""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    valid_nums = [i for i in arr if 1 <= i <= 9]
    valid_nums.sort(reverse=True)
    return [num_names[i-1] for i in valid_nums]",useful
This function generates a list from 1 to n where odd indices use the number itself and even indices compute the sum of the first i natural numbers using sum(range()).,"def f(n):
    return [i if i % 2 else sum(range(1, i+1)) for i in range(1, n+1)]",not useful
This function generates a list from 1 to n where even indices use math.factorial(i) and odd indices compute the sum of the first i natural numbers; note that it incorrectly swaps even/odd logic based on the code.,"def f(n):
    return [sum(range(i+1)) if i % 2 else math.factorial(i) for i in range(1, n+1)]",not useful
This function generates a list from 1 to n where odd indices use the triangular number formula i*(i+1)//2 and even indices use math.factorial(i).,"def f(n):
    return [i*(i+1)//2 if i % 2 else math.factorial(i) for i in range(1, n+1)]",useful
"This function generates a list from 1 to n where even indices compute factorial using reduce on range(1, i+1) and odd indices use sum(range(1, i+1)).","def f(n):
    return [reduce(lambda x, y: x*y, range(1, i+1)) if i % 2 == 0 else sum(range(1, i+1)) for i in range(1, n+1)]",useful
"This function precomputes factorials up to n using dynamic programming, then generates a list using factorial for even i and sum(range(1, i+1)) for odd i.","def f(n):
    fact = [1] * (n+1)
    for i in range(1, n+1):
        fact[i] = i * fact[i-1]
    return [fact[i] if i % 2 == 0 else sum(range(1, i+1)) for i in range(1, n+1)]",useful
"This function precomputes even factorials up to n by multiplying every second value, then generates a list using those for even i and sum(range(1, i+1)) for odd i.","def f(n):
    fact = [1] * (n+1)
    for i in range(2, n+1, 2):
        fact[i] = i * fact[i-2]
    return [fact[i] if i % 2 == 0 else sum(range(1, i+1)) for i in range(1, n+1)]",not useful
"This function precomputes even factorials up to n by multiplying every second value, then generates a list using those for even i and the triangular formula for odd i.","def f(n):
    fact = [1] * (n+1)
    for i in range(2, n+1, 2):
        fact[i] = i * fact[i-2]
    return [fact[i] if i % 2 == 0 else i*(i+1)//2 for i in range(1, n+1)]",not useful
"This function precomputes even factorials up to n by multiplying every second value, then generates a list using those for even i and sum(range(i+1)) for odd i, which is equivalent to sum(1 to i).","def f(n):
    fact = [1] * (n+1)
    for i in range(2, n+1, 2):
        fact[i] = i * fact[i-2]
    return [fact[i] if i % 2 == 0 else sum(range(i+1)) for i in range(1, n+1)]",not useful
"This function precomputes even factorials up to n by multiplying every second value, then generates a list using those for even i and sum(range(1, i+1)) for odd i.","def f(n):
    fact = [1] * (n+1)
    for i in range(2, n+1, 2):
        fact[i] = i * fact[i-2]
    return [fact[i] if i % 2 == 0 else sum(range(1, i+1)) for i in range(1, n+1)]",not useful
"This function precomputes even factorials up to n by multiplying every second value, then generates a list using those for even i and the triangular formula for odd i.","def f(n):
    fact = [1] * (n+1)
    for i in range(2, n+1, 2):
        fact[i] = i * fact[i-2]
    return [fact[i] if i % 2 == 0 else i*(i+1)//2 for i in range(1, n+1)]",not useful
"This function iterates from 1 to n-1, checks if each number is a palindrome by comparing its string to its reverse, and counts even and odd palindromes separately.","def even_odd_palindrome(n):
    e, o = 0, 0
    for i in range(1, n):
        if str(i) == str(i)[::-1]:
            e += 1 if i % 2 == 0 else 0
            o += 1 if i % 2 != 0 else 0
    return (e, o)",useful
This function uses generator expressions to sum counts of even and odd palindromes separately by checking string reversal for numbers in even and odd ranges up to n-1.,"def even_odd_palindrome(n):
    return (sum(1 for i in range(2, n, 2) if str(i) == str(i)[::-1]), sum(1 for i in range(1, n, 2) if str(i) == str(i)[::-1]))",useful
"This function iterates from 1 to n-1, converts each to string, checks palindrome property, and increments even or odd count based on parity.","def even_odd_palindrome(n):
    e, o = 0, 0
    for i in range(1, n):
        s = str(i)
        if s == s[::-1]:
            if i % 2 == 0:
                e += 1
            else:
                o += 1
    return (e, o)",useful
"This function iterates from 1 to n-1, checks if each is a palindrome, and uses boolean expressions to increment even (i % 2 == 0) or odd (i % 2 != 0) counts.","def even_odd_palindrome(n):
    e, o = 0, 0
    for i in range(1, n):
        if str(i) == str(i)[::-1]:
            e += i % 2 == 0
            o += i % 2 != 0
    return (e, o)",useful
"This function iterates from 1 to n-1, checks palindrome by string reversal, and increments odd count if i % 2 (truthy for odd) else even count.","def even_odd_palindrome(n):
    e, o = 0, 0
    for i in range(1, n):
        s = str(i)
        if s == s[::-1]:
            if i % 2:
                o += 1
            else:
                e += 1
    return (e, o)",useful
"This function iterates from 1 to n-1, checks palindrome, and uses boolean i % 2 == 0 for even count and i % 2 (truthy for odd) for odd count.","def even_odd_palindrome(n):
    e, o = 0, 0
    for i in range(1, n):
        if str(i) == str(i)[::-1]:
            e += i % 2 == 0
            o += i % 2
    return (e, o)",useful
"This function iterates from 1 to n-1, converts to string for palindrome check, and increments odd if i % 2 else even.","def even_odd_palindrome(n):
    e, o = 0, 0
    for i in range(1, n):
        s = str(i)
        if s == s[::-1]:
            if i % 2:
                o += 1
            else:
                e += 1
    return (e, o)",useful
"This function iterates from 1 to n-1, checks palindrome by string reversal, and uses booleans i % 2 == 0 for even and i % 2 for odd.","def even_odd_palindrome(n):
    e, o = 0, 0
    for i in range(1, n):
        if str(i) == str(i)[::-1]:
            e += i % 2 == 0
            o += i % 2
    return (e, o)",useful
"This function iterates from 1 to n-1, converts to string for palindrome check, and increments odd if i % 2 else even.","def even_odd_palindrome(n):
    e, o = 0, 0
    for i in range(1, n):
        s = str(i)
        if s == s[::-1]:
            if i % 2:
                o += 1
            else:
                e += 1
    return (e, o)",useful
"This function iterates from 1 to n-1, checks palindrome by string reversal, and uses booleans i % 2 == 0 for even and i % 2 for odd.","def even_odd_palindrome(n):
    e, o = 0, 0
    for i in range(1, n):
        if str(i) == str(i)[::-1]:
            e += i % 2 == 0
            o += i % 2
    return (e, o)",useful
"This function counts numbers in the array where the sum of absolute digits is greater than 0, effectively counting non-zero numbers using a generator.","def count_nums(arr):
    return sum(sum(int(d) for d in str(abs(n))) > 0 for n in arr)",useful
"This function counts numbers in the array where any absolute digit is non-zero, equivalent to counting non-zero numbers using any() in a generator.","def count_nums(arr):
    return sum(any(int(d) for d in str(abs(n))) for n in arr)",useful
"This function creates a list of numbers where the sum of absolute digits > 0 and returns its length, counting non-zero numbers.","def count_nums(arr):
    return len([n for n in arr if sum(map(int, str(abs(n)))) > 0])",useful
"This function creates a list of numbers where any absolute digit is non-zero and returns its length, counting non-zero numbers.","def count_nums(arr):
    return len([n for n in arr if any(map(int, str(abs(n))))])",useful
"This function uses a generator to sum 1 for each number where the sum of absolute digits > 0, counting non-zero numbers.","def count_nums(arr):
    return sum(1 for n in arr if sum(int(d) for d in str(abs(n))) > 0)",useful
"This function uses a generator to sum 1 for each number where any absolute digit is non-zero, counting non-zero numbers.","def count_nums(arr):
    return sum(1 for n in arr if any(int(d) for d in str(abs(n))))",useful
"This function filters the array using lambda for numbers with sum of absolute digits > 0, converts to list, and returns length to count non-zero numbers.","def count_nums(arr):
    return len(list(filter(lambda n: sum(int(d) for d in str(abs(n))) > 0, arr)))",useful
"This function filters the array using lambda for numbers with any absolute digit non-zero, converts to list, and returns length to count non-zero numbers.","def count_nums(arr):
    return len(list(filter(lambda n: any(int(d) for d in str(abs(n))), arr)))",useful
This function creates a list of numbers where sum of absolute values of digits (redundant abs) > 0 and returns length; note that abs on positive digits is unnecessary but counts non-zero numbers.,"def count_nums(arr):
    return len([n for n in arr if sum(map(abs, map(int, str(n)))) > 0])",not useful
This function creates a list of numbers where any absolute value of digit (redundant) is truthy and returns length; counts non-zero numbers but abs on digits unnecessary.,"def count_nums(arr):
    return len([n for n in arr if any(map(abs, map(int, str(n))))])",not useful
"This function finds the index of the minimum value, rotates the array to start from that index, and checks if the rotated array is non-decreasing.","def move_one_ball(arr):
    n = len(arr)
    if n <= 1:
        return True
    min_idx = arr.index(min(arr))
    arr = arr[min_idx:] + arr[:min_idx]
    return all(arr[i] <= arr[i + 1] for i in range(n - 1))",useful
This function finds the minimum value's index and checks if the circular array starting from that index is non-decreasing using modular arithmetic.,"def move_one_ball(arr):
    n = len(arr)
    if n <= 1:
        return True
    min_val = min(arr)
    min_idx = arr.index(min_val)
    return all(arr[(i + min_idx) % n] <= arr[(i + min_idx + 1) % n] for i in range(n))",not useful
"This function manually finds the minimum index by iteration, then checks if the circular array from that index is non-decreasing using mod n.","def move_one_ball(arr):
    n = len(arr)
    if n <= 1:
        return True
    min_idx = 0
    for i in range(1, n):
        if arr[i] < arr[min_idx]:
            min_idx = i
    return all(arr[(i + min_idx) % n] <= arr[(i + min_idx + 1) % n] for i in range(n))",not useful
"This function manually finds the minimum index by iterating and tracking min_val, then checks circular non-decreasing from that index using mod n.","def move_one_ball(arr):
    n = len(arr)
    if n <= 1:
        return True
    min_val = float('inf')
    min_idx = 0
    for i in range(n):
        if arr[i] < min_val:
            min_val = arr[i]
            min_idx = i
    return all(arr[(i + min_idx) % n] <= arr[(i + min_idx + 1) % n] for i in range(n))",not useful
"This function finds the min index, rotates the array to start from min, and checks if it equals its sorted version.","def move_one_ball(arr):
    n = len(arr)
    if n <= 1:
        return True
    min_idx = arr.index(min(arr))
    return sorted(arr[min_idx:] + arr[:min_idx]) == arr",not useful
"This function finds the min index, rotates the array, sorts the original, and checks if they match.","def move_one_ball(arr):
    n = len(arr)
    if n <= 1:
        return True
    min_val = min(arr)
    min_idx = arr.index(min_val)
    sorted_arr = sorted(arr)
    return sorted_arr == arr[min_idx:] + arr[:min_idx]",useful
"This function finds the min index, rotates the array, and checks if it equals the sorted original array.","def move_one_ball(arr):
    n = len(arr)
    if n <= 1:
        return True
    min_idx = arr.index(min(arr))
    return arr[min_idx:] + arr[:min_idx] == sorted(arr)",useful
"This function finds the min index, rotates the array, sorts the rotated version, and checks if it matches the rotation (which would always be true if no duplicates, but intent is to check sortability).","def move_one_ball(arr):
    n = len(arr)
    if n <= 1:
        return True
    min_val = min(arr)
    min_idx = arr.index(min_val)
    return arr[min_idx:] + arr[:min_idx] == sorted(arr[min_idx:] + arr[:min_idx])",not useful
"This function finds the min index but incorrectly checks the original array for circular non-decreasing without rotation, which may not work as intended.","def move_one_ball(arr):
    n = len(arr)
    if n <= 1:
        return True
    min_idx = arr.index(min(arr))
    return all(arr[i] <= arr[(i + 1) % n] for i in range(n))",not useful
"This function finds the min index but checks non-decreasing only from min_idx to end and wrap incorrectly, potentially missing full circular check.","def move_one_ball(arr):
    n = len(arr)
    if n <= 1:
        return True
    min_val = min(arr)
    min_idx = arr.index(min_val)
    return all(arr[i] <= arr[(i + 1) % n] for i in range(min_idx, n + min_idx))",not useful
"This function checks if every element in lst1 is even or if lst2 contains at least one even number, returning True if all elements in lst1 satisfy this condition.","def exchange(lst1, lst2):
    return all(x % 2 == 0 or any(y % 2 == 0 for y in lst2) for x in lst1)",not useful
"This function counts the odd elements in lst1 and even elements in lst2, returning True if the number of odds in lst1 is less than or equal to the number of evens in lst2.","def exchange(lst1, lst2):
    evens = [x for x in lst2 if x % 2 == 0]
    return len([x for x in lst1 if x % 2 != 0]) <= len(evens)",useful
"This function filters and counts odd numbers in lst1 and even numbers in lst2, then returns True if the count of odds is less than or equal to the count of evens.","def exchange(lst1, lst2):
    odds = [x for x in lst1 if x % 2 != 0]
    evens = [x for x in lst2 if x % 2 == 0]
    return len(odds) <= len(evens)",useful
"This function uses sum to count odd elements in lst1 (via x % 2) and even elements in lst2 (via x % 2 == 0), returning True if the odd count in lst1 <= even count in lst2.","def exchange(lst1, lst2):
    return sum(x % 2 for x in lst1) <= sum(x % 2 == 0 for x in lst2)",useful
"This function creates lists of odd elements from lst1 and even elements from lst2, then compares their lengths to return True if odds in lst1 <= evens in lst2.","def exchange(lst1, lst2):
    lst1_odds = [x for x in lst1 if x % 2 != 0]
    lst2_evens = [x for x in lst2 if x % 2 == 0]
    return len(lst1_odds) <= len(lst2_evens)",useful
"This function zips lst1 with its odd elements and checks if each corresponding odd element appears in lst2, but the logic is flawed as it may not correctly handle the exchange condition.","def exchange(lst1, lst2):
    return all(x % 2 == 0 or lst2.count(y) > 0 for x, y in zip(lst1, filter(lambda x: x % 2 != 0, lst1)))",not useful
"This function filters odd elements in lst1 and even elements in lst2 into lists, returning True if the length of odds <= length of evens.","def exchange(lst1, lst2):
    lst1_odds = [x for x in lst1 if x % 2 != 0]
    lst2_evens = [x for x in lst2 if x % 2 == 0]
    return len(lst1_odds) <= len(lst2_evens)",useful
"This function checks if all odd elements in lst1 are in lst2 and all odd elements in lst2 are in lst1, which does not correctly implement the exchange logic.","def exchange(lst1, lst2):
    return all(x % 2 == 0 or x in lst2 for x in lst1) and all(x % 2 == 0 or x in lst1 for x in lst2)",not useful
"This function uses generator expressions with sum(1 for ...) to count odds in lst1 and evens in lst2, returning True if odds <= evens.","def exchange(lst1, lst2):
    return sum(1 for x in lst1 if x % 2 != 0) <= sum(1 for x in lst2 if x % 2 == 0)",useful
"This function checks if every element in lst1 is even or present in lst2 (using a set for efficiency), but this only partially addresses the exchange condition.","def exchange(lst1, lst2):
    return all(x % 2 == 0 or x in set(lst2) for x in lst1)",not useful
"This function counts word frequencies in the input string split by spaces using a dictionary, then returns a dictionary of words with the maximum frequency.","def histogram(test):
    counts = {}
    for letter in test.split():
        counts[letter] = counts.get(letter, 0) + 1
    max_count = max(counts.values(), default=0)
    return {k: v for k, v in counts.items() if v == max_count}",useful
"This function uses Counter from collections to count word frequencies in the split string, then filters and returns words with the maximum count.","from collections import Counter
def histogram(test):
    counts = Counter(test.split())
    max_count = max(counts.values(), default=0)
    return {k: v for k, v in counts.items() if v == max_count}",useful
"This function builds a dictionary of word counts while tracking the maximum count and corresponding words, returning a dictionary for words with that max count.","def histogram(test):
    counts = {}
    max_count = 0
    max_letters = []
    for letter in test.split():
        counts[letter] = counts.get(letter, 0) + 1
        if counts[letter] > max_count:
            max_count = counts[letter]
            max_letters = [letter]
        elif counts[letter] == max_count:
            max_letters.append(letter)
    return {letter: max_count for letter in max_letters}",useful
"This function counts word frequencies, finds the max count, and returns a sorted dictionary of words with that max count in descending order of frequency.","def histogram(test):
    counts = {}
    for letter in test.split():
        counts[letter] = counts.get(letter, 0) + 1
    max_count = max(counts.values(), default=0)
    return {k: v for k, v in sorted(counts.items(), key=lambda item: item[1], reverse=True) if v == max_count}",useful
"This function counts word frequencies, finds the max count, sorts items by frequency in ascending order, reverses, and filters for max count words.","def histogram(test):
    counts = {}
    for letter in test.split():
        counts[letter] = counts.get(letter, 0) + 1
    max_count = max(counts.values(), default=0)
    return {k: v for k, v in reversed(sorted(counts.items(), key=lambda item: item[1])) if v == max_count}",useful
"This function counts word frequencies, finds the max count, and uses filter on dictionary items to return only those with the max frequency.","def histogram(test):
    counts = {}
    for letter in test.split():
        counts[letter] = counts.get(letter, 0) + 1
    max_count = max(counts.values(), default=0)
    return {k: v for k, v in filter(lambda item: item[1] == max_count, counts.items())}",useful
"This function counts word frequencies and finds the max count, but the zip and if condition in the return statement is incorrect as it references v outside the loop scope.","def histogram(test):
    counts = {}
    for letter in test.split():
        counts[letter] = counts.get(letter, 0) + 1
    max_count = max(counts.values(), default=0)
    return {k: v for k, v in zip(counts.keys(), counts.values()) if v == max_count}",not useful
"This function counts word frequencies and uses map to filter items with max count, but the logic with None handling and if k is not None is flawed and inefficient.","def histogram(test):
    counts = {}
    for letter in test.split():
        counts[letter] = counts.get(letter, 0) + 1
    max_count = max(counts.values(), default=0)
    return {k: v for k, v in map(lambda item: (item[0], item[1]) if item[1] == max_count else (None, None), counts.items()) if k is not None}",not useful
"This function counts word frequencies and finds the max count, but the zip and if v == max_count references v incorrectly outside the intended scope.","def histogram(test):
    counts = {}
    for letter in test.split():
        counts[letter] = counts.get(letter, 0) + 1
    max_count = max(counts.values(), default=0)
    return {k: v for k, v in zip(counts.keys(), counts.values()) if v == max_count}",not useful
"This function counts word frequencies, sorts items by frequency in ascending order, reverses to descending, and filters for max count words.","def histogram(test):
    counts = {}
    for letter in test.split():
        counts[letter] = counts.get(letter, 0) + 1
    max_count = max(counts.values(), default=0)
    return {k: v for k, v in filter(lambda item: item[1] == max_count, reversed(sorted(counts.items(), key=lambda item: item[1])))}",useful
"This function removes characters from s that are in c using a generator, joins to form new string, and returns it with a boolean indicating if it's a palindrome.","def reverse_delete(s, c):
    s = ''.join(ch for ch in s if ch not in c)
    return (s, s == s[::-1])",useful
"This function creates a list of characters from s excluding those in c, joins to string, and checks if the list equals its reverse to determine palindrome status.","def reverse_delete(s, c):
    s = [ch for ch in s if ch not in c]
    return (''.join(s), s == s[::-1])",useful
"This function uses filter to exclude characters in c from s as a list, joins to string, and checks if the list equals its reverse for palindrome.","def reverse_delete(s, c):
    s = list(filter(lambda ch: ch not in c, s))
    return (''.join(s), s == s[::-1])",useful
"This function converts c to a set for faster lookup, removes matching characters from s, and returns the new string with palindrome check using slicing.","def reverse_delete(s, c):
    s = ''.join(ch for ch in s if ch not in set(c))
    return (s, s == s[::-1])",useful
"This function sets c for O(1) lookups, filters characters not in c from s, joins to string, and returns it with a palindrome check via slicing.","def reverse_delete(s, c):
    c = set(c)
    s = ''.join(ch for ch in s if ch not in c)
    return (s, s == s[::-1])",useful
"This function removes characters in c from s, then checks palindrome by comparing s to s[::1] (which is s itself) against reverse, but s[::1] is redundant.","def reverse_delete(s, c):
    s = ''.join(ch for ch in s if ch not in c)
    return (s, s[::1] == s[::-1])",useful
"This function filters out characters in c from s, then manually checks palindrome by comparing characters from start and end indices.","def reverse_delete(s, c):
    s = ''.join(ch for ch in s if ch not in c)
    return (s, all(s[i] == s[-i-1] for i in range(len(s)//2)))",useful
"This function removes characters in c from s, then checks if the string equals the joined reversed string to determine palindrome.","def reverse_delete(s, c):
    s = ''.join(ch for ch in s if ch not in c)
    return (s, s == ''.join(reversed(s)))",useful
"This function filters out characters in c from s, then uses negative indexing (~i) to check if characters match from both ends for palindrome.","def reverse_delete(s, c):
    s = ''.join(ch for ch in s if ch not in c)
    return (s, all(s[i] == s[~i] for i in range(len(s)//2)))",useful
"This function removes characters in c from s, then manually checks palindrome by comparing characters using len(s)-i-1 indexing.","def reverse_delete(s, c):
    s = ''.join(ch for ch in s if ch not in c)
    return (s, all(s[i] == s[len(s)-i-1] for i in range(len(s)//2)))",useful
"This function counts odd digits in each string of lst using sum(int(c) % 2), then formats a descriptive string for each with the count inserted.","def odd_count(lst):
    return [f""the number of odd elements {sum(int(c) % 2 for c in s)}n the str{sum(int(c) % 2 for c in s)}ng {i+1} of the {len(lst)}nput."" for i, s in enumerate(lst)]",useful
"This function uses format with sum(int(c) % 2) for odd counts in each string, inserting the count twice and position/length into the template.","def odd_count(lst):
    return ['the number of odd elements {}n the str{}ng {} of the {}nput.'.format(sum(int(c) % 2 for c in s), sum(int(c) % 2 for c in s), i+1, len(lst)) for i, s in enumerate(lst)]",useful
"This function computes odd digit counts, then manually joins string parts including the count, position, and list length for each entry.","def odd_count(lst):
    return [''.join(['the number of odd elements ', str(sum(int(c) % 2 for c in s)), 'n the str', str(sum(int(c) % 2 for c in s)), 'ng ', str(i+1), ' of the ', str(len(lst)), 'nput.']) for i, s in enumerate(lst)]",useful
"This function uses map and lambda to sum odd digits (int(x) % 2) in each string, formatting the output with f-string inserting the count.","def odd_count(lst):
    return [f""the number of odd elements {sum(map(lambda x: int(x) % 2, s))}n the str{sum(map(lambda x: int(x) % 2, s))}ng {i+1} of the {len(lst)}nput."" for i, s in enumerate(lst)]",useful
"This function counts odd digits, then uses format with unpacked list duplicating the count and adding position and length for the template.","def odd_count(lst):
    return ['the number of odd elements {}n the str{}ng {} of the {}nput.'.format(*[sum(int(c) % 2 for c in s)]*2 + [i+1, len(lst)]) for i, s in enumerate(lst)]",useful
"This function counts odd digits by checking if each char is in '13579', then uses f-string to insert the count into the descriptive template.","def odd_count(lst):
    return [f""the number of odd elements {sum(c in '13579' for c in s)}n the str{sum(c in '13579' for c in s)}ng {i+1} of the {len(lst)}nput."" for i, s in enumerate(lst)]",useful
"This function counts odd digits using membership in '13579', then formats with unpacked duplicated count, position, and length.","def odd_count(lst):
    return ['the number of odd elements {}n the str{}ng {} of the {}nput.'.format(*[sum(c in '13579' for c in s)]*2 + [i+1, len(lst)]) for i, s in enumerate(lst)]",useful
"This function attempts to count odd digits with sum(1 for c if int(c) % 2), but the if condition lacks ==1, making it always true and incorrect.","def odd_count(lst):
    return [f""the number of odd elements {sum(1 for c in s if int(c) % 2)}n the str{sum(1 for c in s if int(c) % 2)}ng {i+1} of the {len(lst)}nput."" for i, s in enumerate(lst)]",not useful
"This function uses sum(1 for c if int(c) % 2) which is flawed as it counts all digits, then formats with duplicated count and position/length.","def odd_count(lst):
    return ['the number of odd elements {}n the str{}ng {} of the {}nput.'.format(*[sum(1 for c in s if int(c) % 2)]*2 + [i+1, len(lst)]) for i, s in enumerate(lst)]",not useful
"This function counts odd digits via membership in '13579' for each string, formatting descriptive output with f-string insertions.","def odd_count(lst):
    return [f""the number of odd elements {sum(c in '13579' for c in s)}n the str{sum(c in '13579' for c in s)}ng {i+1} of the {len(lst)}nput."" for i, s in enumerate(lst)]",useful
This function uses a modified Kadane's algorithm to track the minimum subarray sum by resetting the current sum to the min of current num or sum + num.,"def minSubArraySum(nums):
    min_sum = float('inf')
    curr_sum = 0
    for num in nums:
        curr_sum = min(num, curr_sum + num)
        min_sum = min(min_sum, curr_sum)
    return min_sum",useful
"This function returns the minimum of the smallest single element or the total sum minus the largest element, but this only works for specific cases and not general min subarray sum.","def minSubArraySum(nums):
    return min(min(nums), sum(nums) - max(nums))",not useful
"This function tries to compute min of smallest element or total minus max suffix sum, but the max(nums[i:] for i in range...) is incorrect syntax.","def minSubArraySum(nums):
    return min(min(nums), sum(nums) - max(nums[i:] for i in range(len(nums))))",not useful
"This function computes min of smallest element or total sum minus the maximum subarray sum over all possible contiguous slices, which correctly finds the min subarray sum.","def minSubArraySum(nums):
    return min(min(nums), sum(nums) - max(sum(nums[i:j]) for i in range(len(nums)) for j in range(i+1, len(nums)+1)))",not useful
"This function uses reduce for summing slices and computes min of smallest or total minus max subarray sum, but requires from functools import reduce.","def minSubArraySum(nums):
    return min(min(nums), sum(nums) - max(reduce(lambda x, y: x + y, nums[i:j]) for i in range(len(nums)) for j in range(i+1, len(nums)+1)))",not useful
"This function uses map(sum, ...) over all contiguous slices to find max subarray sum, then min of smallest or total minus that max.","def minSubArraySum(nums):
    return min(min(nums), sum(nums) - max(map(sum, (nums[i:j] for i in range(len(nums)) for j in range(i+1, len(nums)+1)))))",not useful
"This function generates all contiguous subarray sums to find the maximum, then returns min of the smallest element or total sum minus that maximum.","def minSubArraySum(nums):
    return min(min(nums), sum(nums) - max(sum(nums[i:j]) for i in range(len(nums)) for j in range(i+1, len(nums)+1)))",not useful
"This function iterates j from i+1 but with reversed loop order, computing all subarray sums to find max, then min of min element or total - max.","def minSubArraySum(nums):
    return min(min(nums), sum(nums) - max(sum(nums[i:j]) for j in range(i+1, len(nums)+1) for i in range(len(nums))))",not useful
"This function uses reverse range for j from len(nums) down to i+1, summing subarrays to find max sum, then min of min or total - max.","def minSubArraySum(nums):
    return min(min(nums), sum(nums) - max(sum(nums[i:j]) for i in range(len(nums)) for j in range(len(nums), i, -1)))",not useful
"This function nests reverse range for j and i, computing subarray sums to find the max, then returns min of smallest element or total minus max.","def minSubArraySum(nums):
    return min(min(nums), sum(nums) - max(sum(nums[i:j]) for j in range(len(nums), i, -1) for i in range(len(nums))))",not useful
This function calculates the total number of full containers needed across all rows in the grid by summing the ceiling of each row's total divided by capacity using integer division.,"def max_fill(grid, capacity):
    return sum((sum(row) + capacity - 1) // capacity for row in grid)",useful
"This function computes the total containers required by summing the ceiling of each row's sum divided by capacity, using the math.ceil function for accurate division.","def max_fill(grid, capacity):
    return sum(math.ceil(sum(row) / capacity) for row in grid)",useful
"This function sums the quotient from divmod for each row's sum divided by capacity, but redundantly adds the remainder check, effectively computing the ceiling incorrectly in some cases.","def max_fill(grid, capacity):
    return sum(divmod(sum(row), capacity)[0] + divmod(sum(row), capacity)[1] for row in grid)",not useful
"This function calculates the total containers by summing the ceiling of each row's sum divided by capacity, casting capacity to float to ensure floating-point division.","def max_fill(grid, capacity):
    return sum(math.ceil(sum(row) / float(capacity)) for row in grid)",useful
"This function computes the ceiling of each row's sum divided by capacity using the formula (sum - 1) // capacity + 1, then sums these values across all rows.","def max_fill(grid, capacity):
    return sum((sum(row) - 1) // capacity + 1 for row in grid)",useful
This function computes the total containers required by summing the ceiling of each row's sum divided by capacity using math.ceil.,"def max_fill(grid, capacity):
    return sum(math.ceil(sum(row) / capacity) for row in grid)",useful
"This function calculates the ceiling for each row using (sum - 1) // capacity + (sum > 0), which handles zero sums correctly, and sums these across rows.","def max_fill(grid, capacity):
    return sum((sum(row) - 1) // capacity + (sum(row) > 0) for row in grid)",not useful
"This function sums the ceiling of each row's sum divided by capacity, using float(capacity) to perform floating-point division before ceiling.","def max_fill(grid, capacity):
    return sum(math.ceil(sum(row) / float(capacity)) for row in grid)",useful
This function computes the total number of containers by summing math.ceil of each row's total divided by capacity.,"def max_fill(grid, capacity):
    return sum(math.ceil(sum(row) / capacity) for row in grid)",useful
"This function uses the ceiling formula (sum - 1) // capacity + (sum > 0) for each row to handle divisions accurately, then sums the results.","def max_fill(grid, capacity):
    return sum((sum(row) - 1) // capacity + (sum(row) > 0) for row in grid)",not useful
"This function sorts the array first by the number of '1's in each number's binary representation, then by the number itself in ascending order.","def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))",useful
"This function sorts the array primarily by the popcount (number of 1 bits) in binary, with ties broken by the numerical value.","def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))",useful
"This function uses sorted with a key that prioritizes the binary 1-count, followed by the element value for stable sorting.","def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))",useful
"This function sorts the input array by the hamming weight (binary 1s count) ascending, then by value ascending.","def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))",useful
"This function returns a sorted version of the array, keyed on binary digit sum and then the integer value.","def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))",useful
"This function sorts the array using a lambda key that counts binary 1s first, then sorts by the number itself.","def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))",useful
"This function performs a multi-key sort: first on the bit count in binary, second on the value.","def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))",useful
"This function sorts the array by increasing number of set bits in binary representation, with numerical order as secondary key.","def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))",useful
This function uses Python's sorted with a key tuple for binary popcount and value comparison.,"def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))",useful
"This function sorts the array stably by binary 1s count ascending, then by ascending numerical order.","def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))",useful
This function splits the string into words and selects those with exactly n consonants by counting non-vowel characters case-insensitively.,"def select_words(s, n):
    return [word for word in s.split() if sum(c.lower() not in 'aeiou' for c in word) == n]",useful
"This function uses a set of vowels to filter words from the split string, selecting those where the length of non-vowel characters equals n.","def select_words(s, n):
    vowels = set('aeiou')
    return [word for word in s.split() if len([c for c in word if c.lower() not in vowels]) == n]",useful
"This function splits the string and returns words with exactly n consonants, using a generator to sum non-vowel counts case-insensitively.","def select_words(s, n):
    vowels = 'aeiou'
    return [word for word in s.split() if sum(1 for c in word if c.lower() not in vowels) == n]",useful
"This function selects words by computing the length of the list of non-vowel characters in each word, checking if it equals n.","def select_words(s, n):
    vowels = 'aeiou'
    return [word for word in s.split() if len([c for c in word if c.lower() not in vowels]) == n]",useful
"This function filters words from the split string by summing boolean checks for non-vowels, converting the word to lowercase for consistency.","def select_words(s, n):
    return [word for word in s.split() if sum(c.lower() not in 'aeiou' for c in word.lower()) == n]",useful
This function uses a vowel set and sums non-vowel occurrences in lowercase word versions to select those with exactly n consonants.,"def select_words(s, n):
    vowels = set('aeiou')
    return [word for word in s.split() if sum(c not in vowels for c in word.lower()) == n]",useful
"This function splits the string and counts consonants per word using sum of non-vowel checks, case-insensitive, to match n.","def select_words(s, n):
    vowels = 'aeiou'
    return [word for word in s.split() if sum(c.lower() not in vowels for c in word) == n]",useful
This function employs a generator expression with a vowel string to count and select words having exactly n non-vowel characters.,"def select_words(s, n):
    vowels = set('aeiou')
    return [word for word in s.split() if sum(1 for c in word if c.lower() not in vowels) == n]",useful
"This function lowers the entire word before counting non-vowels with sum, selecting words where this count equals n.","def select_words(s, n):
    vowels = 'aeiou'
    return [word for word in s.split() if sum(c.lower() not in vowels for c in word.lower()) == n]",useful
"This function splits the string and uses list comprehension to count non-vowels in lowercase, returning words with length n.","def select_words(s, n):
    vowels = set('aeiou')
    return [word for word in s.split() if len([c for c in word.lower() if c not in vowels]) == n]",not useful
"This function iterates backwards from the second-to-last character, finding the rightmost vowel not adjacent to other vowels and returns it, or empty string if none.","def get_closest_vowel(word):
    vowels = set('aeiouAEIOU')
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:
            return word[i]
    return ''",useful
This function reverses the inner part of the word and checks each character for being a vowel with non-vowel neighbors using index lookups.,"def get_closest_vowel(word):
    vowels = 'aeiouAEIOU'
    for char in reversed(word[1:-1]):
        if char in vowels and word[word.index(char) - 1] not in vowels and word[word.index(char) + 1] not in vowels:
            return char
    return ''",not useful
"This function scans the word from near the end backwards, returning the first (rightmost) isolated vowel encountered, or empty if none.","def get_closest_vowel(word):
    vowels = 'aeiouAEIOU'
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:
            return word[i]
    return ''",useful
This function uses a set for fast vowel lookup and iterates reversely to find an isolated vowel in the word's interior.,"def get_closest_vowel(word):
    vowels = set('aeiouAEIOU')
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:
            return word[i]
    return ''",useful
"This function checks characters from the end towards the beginning, identifying the closest vowel bounded by consonants on both sides.","def get_closest_vowel(word):
    vowels = 'aeiouAEIOU'
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:
            return word[i]
    return ''",useful
This function employs a set of vowels and reverse iteration to locate the rightmost non-adjacent vowel in the word.,"def get_closest_vowel(word):
    vowels = set('aeiouAEIOU')
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:
            return word[i]
    return ''",useful
This function searches backwards in the word for a vowel that has consonants immediately before and after it.,"def get_closest_vowel(word):
    vowels = 'aeiouAEIOU'
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:
            return word[i]
    return ''",useful
This function uses efficient set membership for vowels while checking adjacency conditions in reverse order.,"def get_closest_vowel(word):
    vowels = set('aeiouAEIOU')
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:
            return word[i]
    return ''",useful
"This function iterates from len(word)-2 down to 1, returning the closest isolated vowel from the end.","def get_closest_vowel(word):
    vowels = 'aeiouAEIOU'
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:
            return word[i]
    return ''",useful
"This function finds the rightmost vowel in the word that is not next to another vowel, using reverse indexing.","def get_closest_vowel(word):
    vowels = set('aeiouAEIOU')
    for i in range(len(word) - 2, 0, -1):
        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:
            return word[i]
    return ''",useful
"This function checks if the total parentheses balance across both strings and each has at most one mismatch, returning 'Yes' if conditions met.","def match_parens(lst):
    a, b = lst
    return 'Yes' if (a.count('(') + b.count('(') == a.count(')') + b.count(')')) and (abs(a.count('(') - a.count(')')) <= 1) and (abs(b.count('(') - b.count(')')) <= 1) else 'No'",useful
"This function sorts the strings by open paren count, then verifies if the first's excess opens can be covered by the second's excess closes.","def match_parens(lst):
    a, b = sorted(lst, key=lambda x: (x.count('('), x.count(')')))
    diff = a.count('(') - a.count(')')
    return 'Yes' if diff >= 0 and diff <= b.count(')') - b.count('(') else 'No'",not useful
"This function computes the difference in one string and attempts to balance it by removing from the second, then checks overall balance.","def match_parens(lst):
    a, b = lst
    diff = abs(a.count('(') - a.count(')'))
    if diff > len(b):
        return 'No'
    b = b.replace('(' * diff, '', 1)
    b = b.replace(')' * diff, '', 1)
    return 'Yes' if a.count('(') + b.count('(') == a.count(')') + b.count(')') else 'No'",not useful
"This function swaps strings if needed to make diff positive, then checks if the excess can be absorbed by the other string's counts.","def match_parens(lst):
    a, b = lst
    diff = a.count('(') - a.count(')')
    if diff < 0:
        a, b = b, a
        diff = -diff
    return 'Yes' if diff <= b.count('(') and diff <= b.count(')') else 'No'",not useful
This function computes the net difference for each string and checks if their sum's absolute value is 0 or 1 for near-balance.,"def match_parens(lst):
    a, b = lst
    a_diff = a.count('(') - a.count(')')
    b_diff = b.count('(') - b.count(')')
    return 'Yes' if abs(a_diff + b_diff) in (0, 1) else 'No'",not useful
This function evaluates the differences and checks for cases where both are positive or negative with total mismatch at most 1.,"def match_parens(lst):
    a, b = lst
    a_diff = a.count('(') - a.count(')')
    b_diff = b.count('(') - b.count(')')
    return 'Yes' if (a_diff >= 0 and b_diff >= 0 and a_diff + b_diff <= 1) or (a_diff <= 0 and b_diff <= 0 and a_diff + b_diff >= -1) else 'No'",not useful
This function checks if the differences allow one string's excess to be covered by the other's within the same direction.,"def match_parens(lst):
    a, b = lst
    a_diff = a.count('(') - a.count(')')
    b_diff = b.count('(') - b.count(')')
    return 'Yes' if (a_diff >= 0 and b_diff >= 0 and a_diff <= b_diff) or (a_diff <= 0 and b_diff <= 0 and -a_diff <= -b_diff) else 'No'",not useful
This function extends the check to allow a difference of 1 in the covering capacity for same-sign differences.,"def match_parens(lst):
    a, b = lst
    a_diff = a.count('(') - a.count(')')
    b_diff = b.count('(') - b.count(')')
    return 'Yes' if (a_diff >= 0 and b_diff >= 0 and a_diff <= b_diff + 1) or (a_diff <= 0 and b_diff <= 0 and -a_diff <= -b_diff + 1) else 'No'",not useful
This function verifies balance conditions including total mismatch limits and individual covering with allowance for 1.,"def match_parens(lst):
    a, b = lst
    a_diff = a.count('(') - a.count(')')
    b_diff = b.count('(') - b.count(')')
    return 'Yes' if (a_diff >= 0 and b_diff >= 0 and a_diff <= b_diff + 1 and a_diff + b_diff <= 1) or (a_diff <= 0 and b_diff <= 0 and -a_diff <= -b_diff + 1 and a_diff + b_diff >= -1) else 'No'",not useful
"This function handles same-sign and opposite-sign cases, checking coverage and total mismatch constraints for possible matching.","def match_parens(lst):
    a, b = lst
    a_diff = a.count('(') - a.count(')')
    b_diff = b.count('(') - b.count(')')
    return 'Yes' if (a_diff >= 0 and b_diff >= 0 and a_diff <= b_diff + 1 and a_diff + b_diff <= 1) or (a_diff <= 0 and b_diff <= 0 and -a_diff <= -b_diff + 1 and a_diff + b_diff >= -1) or (a_diff < 0 and b_diff > 0 and -a_diff <= b_diff and -a_diff + b_diff <= 1) else 'No'",not useful
This function uses the heapq.nlargest method to efficiently return the k largest elements from the input array without modifying it.,"import heapq
def maximum(arr, k):
    return heapq.nlargest(k, arr)",useful
"This function sorts the array in descending order and returns the first k elements, which are the k largest values.","def maximum(arr, k):
    return sorted(arr, reverse=True)[:k]",useful
"This function sorts the input array in place in descending order and returns the first k elements as the k largest values, modifying the original array.","def maximum(arr, k):
    arr.sort(reverse=True)
    return arr[:k]",useful
This function implements a randomized quickselect algorithm by partitioning the array around a random pivot and recursively selecting the k largest elements.,"import random
def maximum(arr, k):
    if k == len(arr):
        return arr
    pivot = random.choice(arr)
    left = [x for x in arr if x > pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x < pivot]
    if k < len(left):
        return maximum(left, k)
    elif k < len(left) + len(middle):
        return left + middle[:k - len(left)]
    else:
        return left + middle + maximum(right, k - len(left) - len(middle))",useful
"This function sorts the array and attempts to return the k largest elements that appear at least k times, though it inefficiently calls count for each element.","def maximum(arr, k):
    return [x for x in sorted(arr) if arr.count(x) >= k][-k:]",not useful
"This function sorts unique elements by frequency in descending order, takes the top k, and duplicates the resulting list k times, which does not correctly yield the k largest elements.","def maximum(arr, k):
    return [x for x in sorted(set(arr), key=arr.count, reverse=True)[:k]] * k",not useful
"This function creates repeated lists for each unique element based on its frequency, sorts them in descending order, flattens the list, and returns the first k elements to get the k largest considering duplicates.","def maximum(arr, k):
    return [item for sublist in sorted([[x] * arr.count(x) for x in set(arr)], reverse=True) for item in sublist][:k]",useful
"This function uses Counter.most_common to get the k most frequent elements and duplicates the list of those elements k times, resulting in a list of length k squared that does not represent the k largest.","def maximum(arr, k):
    from collections import Counter
    counter = Counter(arr)
    return [item for item, _ in counter.most_common(k)] * k",not useful
This function sorts the array in ascending order and uses a deque with maxlen=k to efficiently retain and return the k largest elements at the end.,"def maximum(arr, k):
    from collections import deque
    arr.sort()
    q = deque(arr, maxlen=k)
    return list(q)",useful
This function employs NumPy's partition method to rearrange the array so the k largest elements are at the end and returns them.,"def maximum(arr, k):
    import numpy as np
    return np.partition(arr, -k)[-k:]",useful
This function sums the elements at even indices (0-based) in the list that are odd numbers using a generator expression with step slicing.,"def solution(lst):
    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)",useful
This function uses enumerate to iterate over the list and sums the values at even indices that are odd.,"def solution(lst):
    return sum(v for i, v in enumerate(lst) if i % 2 == 0 and v % 2 != 0)",useful
This function calculates the sum of elements at even indices and subtracts the sum of even values among them to get the sum of odd values at even indices.,"def solution(lst):
    return sum(lst[::2]) - sum(x for x in lst[::2] if x % 2 == 0)",useful
This function filters the elements at even indices for odd numbers using a lambda and sums them.,"def solution(lst):
    return sum(filter(lambda x: x % 2 != 0, lst[::2]))",useful
"This function iterates over all indices and sums elements at even indices that are odd, which is less efficient than using slicing.","def solution(lst):
    return sum(lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 != 0)",useful
"This function sums elements at even indices that are odd, using bitwise AND to check for oddness.","def solution(lst):
    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] & 1)",useful
This function uses enumerate and bitwise operations to sum odd values at even indices efficiently.,"def solution(lst):
    return sum(v for i, v in enumerate(lst) if not i % 2 and v & 1)",useful
"This function sums elements at even indices where the modulo 2 result is truthy, effectively selecting odd numbers.","def solution(lst):
    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2)",useful
This function uses enumerate and treats the modulo 2 result as boolean to sum odd values at even indices.,"def solution(lst):
    return sum(v for i, v in enumerate(lst) if i % 2 == 0 and v % 2)",useful
This function sums elements at even indices that are explicitly odd using modulo 2 equals 1.,"def solution(lst):
    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 == 1)",useful
This function sums the first k elements of the array that are between 10 and 99 inclusive.,"def add_elements(arr, k):
    return sum(x for x in arr[:k] if 10 <= x < 100)",useful
This function uses filter with a lambda to select and sum the first k elements between 10 and 99.,"def add_elements(arr, k):
    return sum(filter(lambda x: 10 <= x < 100, arr[:k]))",useful
"This function maps each of the first k elements to itself if between 10 and 99, else 0, and sums the results.","def add_elements(arr, k):
    return sum(map(lambda x: x if 10 <= x < 100 else 0, arr[:k]))",useful
This function uses enumerate to sum elements within the first k positions that are between 10 and 99.,"def add_elements(arr, k):
    return sum(x for i, x in enumerate(arr) if i < k and 10 <= x < 100)",useful
"This function sums the first k elements whose string length is at most 2, which includes single-digit numbers for positive integers.","def add_elements(arr, k):
    return sum(x for x in arr[:k] if len(str(x)) <= 2)",not useful
This function sums the first k elements that are between 10 and 99 inclusive using chained comparisons.,"def add_elements(arr, k):
    return sum(x for x in arr[:k] if x >= 10 and x <= 99)",useful
"This function sums the first k elements where integer division by 100 is 0, including numbers less than 10 for positive values.","def add_elements(arr, k):
    return sum(x for x in arr[:k] if x // 100 == 0)",not useful
"This function sums the first k elements between -99 and 99, including negatives and single-digit numbers.","def add_elements(arr, k):
    return sum(x for x in arr[:k] if -99 <= x <= 99)",not useful
"This function sums the first k elements by negating the condition for being outside 10 to 99, effectively selecting 10 <= x <= 99.","def add_elements(arr, k):
    return sum(x for x in arr[:k] if not (x < 10 or x > 99))",useful
"This function sums the first k elements where division by 10 is positive and by 100 is zero, targeting two-digit positive integers.","def add_elements(arr, k):
    return sum(x for x in arr[:k] if x // 10 > 0 and x // 100 == 0)",useful
"This function generates the Collatz sequence from n, collects odd numbers in a set excluding evens, adds 1, and returns them sorted.","def get_odd_collatz(n):
    seq = set()
    while n != 1:
        if n % 2:
            seq.add(n)
        n = n * 3 + 1 if n % 2 else n // 2
    seq.add(1)
    return sorted(seq)",useful
"This function starts with n in a set, generates the Collatz sequence, adds odd numbers encountered after the start, and returns the sorted unique odds including n if odd.","def get_odd_collatz(n):
    seq = {n}
    while n > 1:
        n = n * 3 + 1 if n % 2 else n // 2
        if n % 2:
            seq.add(n)
    return sorted(list(seq))",not useful
"This function builds a list starting with n, appends odd numbers from the Collatz sequence updates, converts to set for uniqueness, and sorts it.","def get_odd_collatz(n):
    seq = [n]
    while n != 1:
        n = n * 3 + 1 if n % 2 else n // 2
        if n % 2:
            seq.append(n)
    return sorted(set(seq))",not useful
"This function initializes a set with n, generates the Collatz sequence, adds odd numbers after updates, and returns the sorted list.","def get_odd_collatz(n):
    seq = {n}
    while n > 1:
        n = n * 3 + 1 if n % 2 else n // 2
        if n % 2:
            seq.add(n)
    return sorted(list(seq))",not useful
"This function builds a list starting with n, appends odd numbers from Collatz updates only if not already in the list, and returns the sorted list.","def get_odd_collatz(n):
    seq = [n]
    while n != 1:
        n = n * 3 + 1 if n % 2 else n // 2
        if n % 2 and n not in seq:
            seq.append(n)
    return sorted(seq)",not useful
"This function collects all numbers in the Collatz sequence into a set, then filters and sorts only the odd ones.","def get_odd_collatz(n):
    seq = {n}
    while n > 1:
        n = n * 3 + 1 if n % 2 else n // 2
        seq.add(n)
    return sorted([x for x in seq if x % 2])",useful
"This function builds a list of unique numbers from the Collatz sequence, then filters and sorts the odd ones.","def get_odd_collatz(n):
    seq = [n]
    while n != 1:
        n = n * 3 + 1 if n % 2 else n // 2
        if n not in seq:
            seq.append(n)
    return sorted([x for x in seq if x % 2])",useful
"This function collects all Collatz sequence numbers into a set, then uses filter to select and sort the odd ones.","def get_odd_collatz(n):
    seq = {n}
    while n > 1:
        n = n * 3 + 1 if n % 2 else n // 2
        seq.add(n)
    return sorted(list(filter(lambda x: x % 2, seq)))",useful
"This function builds a list of unique Collatz sequence numbers, then filters and sorts the odd ones using lambda.","def get_odd_collatz(n):
    seq = [n]
    while n != 1:
        n = n * 3 + 1 if n % 2 else n // 2
        if n not in seq:
            seq.append(n)
    return sorted(list(filter(lambda x: x % 2, seq)))",useful
"This function collects all numbers in the Collatz sequence into a set and sorts them by their parity (odds first), but does not filter to only odds.","def get_odd_collatz(n):
    seq = {n}
    while n > 1:
        n = n * 3 + 1 if n % 2 else n // 2
        seq.add(n)
    return sorted(seq, key=lambda x: x % 2)",not useful
"This function uses regex to validate the MM-DD-YYYY format, parses the components, and checks month/day ranges with basic leap year rules for February 29.","import re
def valid_date(date):
    if not re.match(r'^\d{2}-\d{2}-\d{4}$', date): return False
    m, d, y = map(int, date.split('-'))
    if m < 1 or m > 12 or d < 1 or d > 31: return False
    if m in [4, 6, 9, 11] and d > 30: return False
    if m == 2 and d > 29: return False
    if m == 2 and d == 29 and y % 4 != 0: return False
    return True",useful
"This function attempts to parse the date string with split and map, returning False on any exception, and validates month/day ranges with simple leap year check.","def valid_date(date):
    try:
        m, d, y = map(int, date.split('-'))
        if m < 1 or m > 12 or d < 1 or d > 31: return False
        if m in [4, 6, 9, 11] and d > 30: return False
        if m == 2 and d > 29: return False
        if m == 2 and d == 29 and y % 4 != 0: return False
        return True
    except:
        return False",not useful
"This function manually checks the length and hyphen positions, parses substrings to integers, and validates date components with basic leap year rules.","def valid_date(date):
    if len(date) != 10 or date[2] != '-' or date[5] != '-': return False
    m, d, y = int(date[:2]), int(date[3:5]), int(date[6:])
    if m < 1 or m > 12 or d < 1 or d > 31: return False
    if m in [4, 6, 9, 11] and d > 30: return False
    if m == 2 and d > 29: return False
    if m == 2 and d == 29 and y % 4 != 0: return False
    return True",not useful
"This function checks for non-empty string, length, and hyphen positions, parses components, and validates date ranges including simple leap year for Feb 29.","def valid_date(date):
    if not date or len(date) != 10 or date[2] != '-' or date[5] != '-': return False
    m, d, y = int(date[:2]), int(date[3:5]), int(date[6:])
    if m < 1 or m > 12 or d < 1 or d > 31: return False
    if m in [4, 6, 9, 11] and d > 30: return False
    if m == 2 and d > 29: return False
    if m == 2 and d == 29 and y % 4 != 0: return False
    return True",not useful
"This function validates the string length, hyphens, and non-emptiness, then parses and checks date components with basic leap year handling.","def valid_date(date):
    if not date or date[2] != '-' or date[5] != '-' or len(date) != 10: return False
    m, d, y = int(date[:2]), int(date[3:5]), int(date[6:])
    if m < 1 or m > 12 or d < 1 or d > 31: return False
    if m in [4, 6, 9, 11] and d > 30: return False
    if m == 2 and d > 29: return False
    if m == 2 and d == 29 and y % 4 != 0: return False
    return True",not useful
"This function checks string validity and hyphens, uses split to parse components, and applies date range validations with simple leap year check.","def valid_date(date):
    if not date or date[2] != '-' or date[5] != '-' or len(date) != 10: return False
    m, d, y = map(int, date.split('-'))
    if m < 1 or m > 12 or d < 1 or d > 31: return False
    if m in [4, 6, 9, 11] and d > 30: return False
    if m == 2 and d > 29: return False
    if m == 2 and d == 29 and y % 4 != 0: return False
    return True",not useful
"This function validates format and combines all date checks into a single if condition for month, day, and leap year rules.","def valid_date(date):
    if not date or date[2] != '-' or date[5] != '-' or len(date) != 10: return False
    m, d, y = map(int, date.split('-'))
    if m < 1 or m > 12 or d < 1 or d > 31 or (m in [4, 6, 9, 11] and d > 30) or (m == 2 and d > 29) or (m == 2 and d == 29 and y % 4 != 0): return False
    return True",not useful
"This function checks format, parses date, validates ranges, and handles February leap year in a nested condition for days up to 29.","def valid_date(date):
    if not date or date[2] != '-' or date[5] != '-' or len(date) != 10: return False
    m, d, y = map(int, date.split('-'))
    if m < 1 or m > 12 or d < 1 or d > 31: return False
    if m in [4, 6, 9, 11] and d > 30: return False
    if m == 2 and (d > 29 or (d == 29 and y % 4 != 0)): return False
    return True",not useful
"This function validates the date string format and combines all month, day, and leap year checks into one comprehensive condition.","def valid_date(date):
    if not date or date[2] != '-' or date[5] != '-' or len(date) != 10: return False
    m, d, y = map(int, date.split('-'))
    if m < 1 or m > 12 or d < 1 or d > 31 or (m in [4, 6, 9, 11] and d > 30) or (m == 2 and (d > 29 or (d == 29 and y % 4 != 0))): return False
    return True",not useful
"This function checks format, parses components, and validates dates with a more accurate leap year calculation considering century rules for February days.","def valid_date(date):
    if not date or date[2] != '-' or date[5] != '-' or len(date) != 10: return False
    m, d, y = map(int, date.split('-'))
    if m < 1 or m > 12 or d < 1 or d > 31 or (m in [4, 6, 9, 11] and d > 30) or (m == 2 and d > 28 + (y % 4 == 0 and y % 100 != 0 or y % 400 == 0)): return False
    return True",not useful
"This function splits the input text by whitespace if spaces are present, by commas if commas are present, otherwise counts lowercase letters at odd positions in the alphabet (e.g., b, d, f) using their ASCII values.","def split_words(txt):
    if ' ' in txt:
        return txt.split()
    elif ',' in txt:
        return txt.split(',')
    else:
        return sum(1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 == 1)",useful
"This function splits the input text by spaces if present, by commas otherwise, and if neither, sums the parity (odd/even) of ASCII values for lowercase letters in the text.","def split_words(txt):
    if ' ' in txt:
        return txt.split(' ')
    elif ',' in txt:
        return txt.split(',')
    else:
        return sum(ord(c) % 2 for c in txt if c.islower())",not useful
"This function splits the input text by spaces if present, by commas otherwise, and if neither, returns the length of lowercase letters whose ASCII values are even.","def split_words(txt):
    if ' ' in txt:
        return txt.split(' ')
    elif ',' in txt:
        return txt.split(',')
    else:
        return len([c for c in txt if c.islower() and ord(c) % 2])",not useful
"This function splits the input text by spaces if present, by commas otherwise, and if neither, counts lowercase letters at odd positions (1-based index) in the string.","def split_words(txt):
    if ' ' in txt:
        return txt.split(' ')
    elif ',' in txt:
        return txt.split(',')
    else:
        return sum(1 for i in range(len(txt)) if i % 2 and txt[i].islower())",not useful
"This function splits the input text by spaces if present, by commas otherwise, and if neither, counts alphabetic lowercase letters at odd positions in the alphabet using ASCII offset from 'a'.","def split_words(txt):
    if ' ' in txt:
        return txt.split(' ')
    elif ',' in txt:
        return txt.split(',')
    else:
        return sum(1 for c in txt if c.isalpha() and c.islower() and (ord(c) - 97) % 2)",not useful
"This function splits the input text by spaces if present, by commas otherwise, and if neither, counts lowercase letters at odd indices (0-based) in the string.","def split_words(txt):
    if ' ' in txt:
        return txt.split(' ')
    elif ',' in txt:
        return txt.split(',')
    else:
        return sum(1 for i in range(len(txt)) if i % 2 == 1 and txt[i].islower())",not useful
"This function splits the input text by spaces if present, by commas otherwise, and if neither, returns the length of lowercase letters at odd positions in the alphabet.","def split_words(txt):
    if ' ' in txt:
        return txt.split(' ')
    elif ',' in txt:
        return txt.split(',')
    else:
        return len([c for c in txt if c.islower() and (ord(c) - ord('a')) % 2])",not useful
"This function splits the input text by spaces if present, by commas otherwise, and if neither, counts lowercase letters at odd positions (1-based) in the string.","def split_words(txt):
    if ' ' in txt:
        return txt.split(' ')
    elif ',' in txt:
        return txt.split(',')
    else:
        return sum(1 for i in range(len(txt)) if i % 2 and txt[i].islower())",not useful
"This function splits the input text by spaces if present, by commas otherwise, and if neither, returns the length of lowercase letters with even ASCII values.","def split_words(txt):
    if ' ' in txt:
        return txt.split(' ')
    elif ',' in txt:
        return txt.split(',')
    else:
        return len([c for c in txt if c.islower() and ord(c) % 2])",not useful
"This function splits the input text by spaces if present, by commas otherwise, and if neither, counts lowercase letters at odd positions (1-based) in the string.","def split_words(txt):
    if ' ' in txt:
        return txt.split(' ')
    elif ',' in txt:
        return txt.split(',')
    else:
        return sum(1 for i in range(len(txt)) if i % 2 and txt[i].islower())",not useful
This function checks if the list is sorted in ascending order with unique elements by comparing it to the sorted version of its unique elements.,"def is_sorted(lst):
    return lst == sorted(set(lst))",useful
This function verifies if the list is strictly increasing and contains no duplicates by checking consecutive pairs and set length.,"def is_sorted(lst):
    return all(x < y for x, y in zip(lst, lst[1:])) and len(lst) == len(set(lst))",useful
This function checks if the list equals its sorted version and has unique elements using set length comparison.,"def is_sorted(lst):
    return lst == sorted(lst) and len(lst) == len(set(lst))",useful
This function confirms the list is strictly increasing via index comparisons and has unique elements by set length.,"def is_sorted(lst):
    return all(lst[i] < lst[i + 1] for i in range(len(lst) - 1)) and len(lst) == len(set(lst))",useful
"This function attempts to check if the list is sorted by comparing it to a sorted version using list indices as keys, but this may not correctly handle sorting.","def is_sorted(lst):
    return lst == sorted(lst, key=lst.index)",not useful
This function checks for strictly increasing order and uniqueness by verifying consecutive elements and counting occurrences of each.,"def is_sorted(lst):
    return all(lst[i] < lst[i + 1] for i in range(len(lst) - 1)) and all(lst.count(i) == 1 for i in lst)",useful
This function verifies if the list equals its sorted version and all elements appear exactly once by counting.,"def is_sorted(lst):
    return lst == sorted(lst) and all(lst.count(i) == 1 for i in lst)",useful
"This function redundantly checks for strictly increasing order, uniqueness via set, and equality to sorted list.","def is_sorted(lst):
    return all(lst[i] < lst[i + 1] for i in range(len(lst) - 1)) and len(lst) == len(set(lst)) and lst == sorted(lst)",useful
"This function over-checks strictly increasing order, uniqueness by counting, and equality to sorted list.","def is_sorted(lst):
    return all(lst[i] < lst[i + 1] for i in range(len(lst) - 1)) and all(lst.count(i) == 1 for i in lst) and lst == sorted(lst)",useful
"This function checks strictly increasing, uniqueness by counting, and equality to a sorted version using indices, which may not work as intended.","def is_sorted(lst):
    return all(lst[i] < lst[i + 1] for i in range(len(lst) - 1)) and all(lst.count(i) == 1 for i in lst) and lst == sorted(lst, key=lst.index)",not useful
"This function computes the overlap of two intervals, checks if the length is at least 2 and prime by testing divisibility up to sqrt, returning 'YES' if prime, else 'NO'.","def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return ""NO""
    length = end - start
    if length < 2:
        return ""NO""
    for i in range(2, int(length**0.5) + 1):
        if length % i == 0:
            return ""NO""
    return ""YES""",useful
"This function finds the interval overlap length, returns 'NO' if less than 2 or if any divisor from 2 to sqrt(length) divides it evenly, else 'YES' for prime.","def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return ""NO""
    length = end - start
    if length < 2:
        return ""NO""
    return ""YES"" if all(length % i for i in range(2, int(length**0.5) + 1)) else ""NO""",useful
"This function calculates overlap length, returns 'NO' if invalid or not prime (has divisors up to sqrt), else 'YES' using any() for efficient primality check.","def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return ""NO""
    length = end - start
    if length < 2:
        return ""NO""
    return ""YES"" if not any(length % i == 0 for i in range(2, int(length**0.5) + 1)) else ""NO""",useful
"This function computes overlap, checks length >=2, and verifies primality by ensuring no divisors from 2 to length-1, but inefficiently uses all() with full range.","def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return ""NO""
    length = end - start
    if length < 2:
        return ""NO""
    return ""YES"" if all(length % i for i in range(2, length)) == True else ""NO""",useful
"This function determines overlap length, returns 'NO' if <2 or not prime, using map and lambda to check for no divisors up to sqrt(length).","def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return ""NO""
    length = end - start
    if length < 2:
        return ""NO""
    return ""YES"" if not any(map(lambda x: length % x == 0, range(2, int(length**0.5) + 1))) else ""NO""",useful
"This function finds overlap, checks if length >=2 and prime by confirming no divisors from 2 to sqrt(length) using all() with !=0 condition.","def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return ""NO""
    length = end - start
    if length < 2:
        return ""NO""
    return ""YES"" if all(length % i != 0 for i in range(2, int(length**0.5) + 1)) else ""NO""",useful
"This function computes overlap length, returns 'NO' if <2 or has any divisor from 2 to length-1, inefficient for large lengths but checks primality.","def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return ""NO""
    length = end - start
    if length < 2:
        return ""NO""
    return ""YES"" if not any(length % i == 0 for i in range(2, length)) else ""NO""",useful
"This function calculates overlap, checks length >=2, and uses all() to verify if length % i !=0 for i up to length-1, but logic is inverted for primality.","def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return ""NO""
    length = end - start
    if length < 2:
        return ""NO""
    return ""YES"" if all(length % i for i in range(2, length)) else ""NO""",not useful
"This function finds overlap length, returns 'NO' if <2 or divisible by any i from 2 to length-1, providing a basic but inefficient primality test.","def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return ""NO""
    length = end - start
    if length < 2:
        return ""NO""
    return ""YES"" if not any(length % i == 0 for i in range(2, length)) else ""NO""",useful
"This function computes overlap length, returns 'YES' if length >1 and all i from 2 to sqrt(length) do not divide it evenly, but condition is slightly off for primality.","def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return ""NO""
    length = end - start
    if length < 2:
        return ""NO""
    return ""YES"" if all(length % i for i in range(2, int(length**0.5) + 1)) and length > 1 else ""NO""",not useful
"This function returns None for empty array; otherwise, computes the sum of absolute values multiplied by the product of signs (-1 for negatives, 1 for positives).","def prod_signs(arr):
    if not arr: return None
    sign = 1
    total = 0
    for num in arr:
        sign *= -1 if num < 0 else 1
        total += abs(num)
    return total * sign",useful
"This function handles empty array as None; sums absolutes and multiplies by (-1) raised to the count of negatives, effectively applying signs to the sum.","def prod_signs(arr):
    if not arr: return None
    sign = 1
    total = sum(abs(num) for num in arr)
    for num in arr:
        if num < 0: sign *= -1
    return total * sign",not useful
This function for non-empty arrays computes the signed sum by tracking product of signs using boolean subtraction and summing absolutes.,"def prod_signs(arr):
    if not arr: return None
    sign = 1
    total = 0
    for num in arr:
        sign *= (num > 0) - (num < 0)
        total += abs(num)
    return total * sign",not useful
"This function returns None if empty; uses map for sum of absolutes and loops to compute sign product for negatives, yielding the signed total.","def prod_signs(arr):
    if not arr: return None
    sign = 1
    total = sum(map(abs, arr))
    for num in arr:
        sign *= -1 if num < 0 else 1
    return total * sign",not useful
This function computes the signed sum for non-empty arrays by multiplying absolutes sum with sign product derived from boolean expressions for each number's sign.,"def prod_signs(arr):
    if not arr: return None
    sign = 1
    total = 0
    for num in arr:
        sign *= (num > 0) - (num < 0)
        total += abs(num)
    return total * sign",not useful
"This function returns None for empty; efficiently computes sum of absolutes and sign as (-1) to the power of negative count, giving the signed sum.","def prod_signs(arr):
    if not arr: return None
    sign = 1
    total = sum(abs(num) for num in arr)
    sign = (-1) ** sum(num < 0 for num in arr)
    return total * sign",not useful
"This function for non-empty arrays sums absolutes while flipping sign for each negative, resulting in the total with original signs applied.","def prod_signs(arr):
    if not arr: return None
    sign = 1
    total = 0
    for num in arr:
        if num < 0: sign *= -1
        total += abs(num)
    return total * sign",not useful
This function handles empty as None; sums absolutes with map and computes sign via exponentiation on negative count for the signed total.,"def prod_signs(arr):
    if not arr: return None
    sign = 1
    total = sum(map(abs, arr))
    sign = (-1) ** sum(num < 0 for num in arr)
    return total * sign",not useful
"This function returns None if empty; loops to sum absolutes and multiply sign by -1 for negatives, producing the signed sum.","def prod_signs(arr):
    if not arr: return None
    sign = 1
    total = 0
    for num in arr:
        sign *= -1 if num < 0 else 1
        total += abs(num)
    return total * sign",not useful
This function for non-empty arrays sums absolutes and applies sign product using boolean subtraction for each element's sign.,"def prod_signs(arr):
    if not arr: return None
    sign = 1
    total = sum(abs(num) for num in arr)
    for num in arr:
        sign *= (num > 0) - (num < 0)
    return total * sign",useful
"This function uses DFS from every grid cell to find a path of exactly k unique cells (no revisits) with the lexicographically smallest sequence of values, but tracks positions instead of values.","def minPath(grid, k):
    n = len(grid)
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def dfs(x, y, k, path):
        if k == 0:
            return path
        min_path = None
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in path:
                path.append((nx, ny))
                new_path = dfs(nx, ny, k - 1, path)
                if min_path is None or new_path < min_path:
                    min_path = new_path
                path.pop()
        return min_path
    min_path = None
    for i in range(n):
        for j in range(n):
            path = [(i, j)]
            new_path = dfs(i, j, k - 1, path)
            if min_path is None or new_path < min_path:
                min_path = new_path
    return [grid[x][y] for x, y in min_path]",not useful
"This function employs DFS with visited set from each starting cell to build paths of length k without revisits, selecting the minimal value sequence.","def minPath(grid, k):
    n = len(grid)
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def dfs(x, y, k, path, visited):
        if k == 0:
            return path
        min_path = None
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:
                visited.add((nx, ny))
                path.append(grid[nx][ny])
                new_path = dfs(nx, ny, k - 1, path, visited)
                if min_path is None or new_path < min_path:
                    min_path = new_path
                visited.remove((nx, ny))
                path.pop()
        return min_path
    min_path = None
    for i in range(n):
        for j in range(n):
            path = [grid[i][j]]
            visited = {(i, j)}
            new_path = dfs(i, j, k - 1, path, visited)
            if min_path is None or new_path < min_path:
                min_path = new_path
    return min_path",not useful
"This function performs DFS from each cell, enforcing strictly decreasing values in paths of length k, and selects the overall minimal path, but initializes with inf which may cause issues.","def minPath(grid, k):
    n = len(grid)
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def dfs(x, y, k, path):
        if k == 0:
            return path
        min_path = [float('inf')] * k
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] < path[-1]:
                new_path = dfs(nx, ny, k - 1, path + [grid[nx][ny]])
                if new_path < min_path:
                    min_path = new_path
        return min_path
    min_path = [float('inf')] * k
    for i in range(n):
        for j in range(n):
            new_path = dfs(i, j, k - 1, [grid[i][j]])
            if new_path < min_path:
                min_path = new_path
    return min_path",not useful
"This function uses DFS starting from every cell to explore adjacent moves with strictly decreasing values for paths of length k, returning the lexicographically smallest path.","def minPath(grid, k):
    n = len(grid)
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def dfs(x, y, k, path):
        if k == 0:
            return path
        min_path = None
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] < path[-1]:
                new_path = dfs(nx, ny, k - 1, path + [grid[nx][ny]])
                if min_path is None or new_path < min_path:
                    min_path = new_path
        return min_path
    min_path = None
    for i in range(n):
        for j in range(n):
            new_path = dfs(i, j, k - 1, [grid[i][j]])
            if min_path is None or new_path < min_path:
                min_path = new_path
    return min_path",not useful
"This function implements backtracking DFS with visited tracking from each starting position to find non-revisiting paths of length k, choosing the minimal value sequence.","def minPath(grid, k):
    n = len(grid)
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def dfs(x, y, k, path, visited):
        if k == 0:
            return path
        min_path = None
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:
                visited.add((nx, ny))
                new_path = dfs(nx, ny, k - 1, path + [grid[nx][ny]], visited)
                visited.remove((nx, ny))
                if min_path is None or new_path < min_path:
                    min_path = new_path
        return min_path
    min_path = None
    for i in range(n):
        for j in range(n):
            new_path = dfs(i, j, k - 1, [grid[i][j]], {(i, j)})
            if min_path is None or new_path < min_path:
                min_path = new_path
    return min_path",useful
"This function DFS from each grid cell, only moving to adjacent cells with smaller values to form decreasing paths of length k, and selects the smallest overall path.","def minPath(grid, k):
    n = len(grid)
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def dfs(x, y, k, path):
        if k == 0:
            return path
        min_path = None
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] < path[-1]:
                new_path = dfs(nx, ny, k - 1, path + [grid[nx][ny]])
                if min_path is None or new_path < min_path:
                    min_path = new_path
        return min_path
    min_path = None
    for i in range(n):
        for j in range(n):
            new_path = dfs(i, j, k - 1, [grid[i][j]])
            if min_path is None or new_path < min_path:
                min_path = new_path
    return min_path",not useful
"This function uses backtracking with visited set in DFS from every start to construct unique-cell paths of length k, returning the lexicographically minimal value list.","def minPath(grid, k):
    n = len(grid)
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def dfs(x, y, k, path, visited):
        if k == 0:
            return path
        min_path = None
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:
                visited.add((nx, ny))
                new_path = dfs(nx, ny, k - 1, path + [grid[nx][ny]], visited)
                visited.remove((nx, ny))
                if min_path is None or new_path < min_path:
                    min_path = new_path
        return min_path
    min_path = None
    for i in range(n):
        for j in range(n):
            new_path = dfs(i, j, k - 1, [grid[i][j]], {(i, j)})
            if min_path is None or new_path < min_path:
                min_path = new_path
    return min_path",useful
"This function explores DFS paths from each cell, restricting moves to adjacent smaller values for strictly decreasing sequences of length k, picking the minimal one.","def minPath(grid, k):
    n = len(grid)
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def dfs(x, y, k, path):
        if k == 0:
            return path
        min_path = None
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] < path[-1]:
                new_path = dfs(nx, ny, k - 1, path + [grid[nx][ny]])
                if min_path is None or new_path < min_path:
                    min_path = new_path
        return min_path
    min_path = None
    for i in range(n):
        for j in range(n):
            new_path = dfs(i, j, k - 1, [grid[i][j]])
            if min_path is None or new_path < min_path:
                min_path = new_path
    return min_path",not useful
"This function applies backtracking DFS with visited positions from each starting cell to build non-overlapping paths of k steps, selecting the smallest value path.","def minPath(grid, k):
    n = len(grid)
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def dfs(x, y, k, path, visited):
        if k == 0:
            return path
        min_path = None
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:
                visited.add((nx, ny))
                new_path = dfs(nx, ny, k - 1, path + [grid[nx][ny]], visited)
                visited.remove((nx, ny))
                if min_path is None or new_path < min_path:
                    min_path = new_path
        return min_path
    min_path = None
    for i in range(n):
        for j in range(n):
            new_path = dfs(i, j, k - 1, [grid[i][j]], {(i, j)})
            if min_path is None or new_path < min_path:
                min_path = new_path
    return min_path",useful
"This function conducts DFS from every grid position, allowing moves only to neighboring cells with lower values to create decreasing paths of length k, and returns the minimal path.","def minPath(grid, k):
    n = len(grid)
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    def dfs(x, y, k, path):
        if k == 0:
            return path
        min_path = None
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] < path[-1]:
                new_path = dfs(nx, ny, k - 1, path + [grid[nx][ny]])
                if min_path is None or new_path < min_path:
                    min_path = new_path
        return min_path
    min_path = None
    for i in range(n):
        for j in range(n):
            new_path = dfs(i, j, k - 1, [grid[i][j]])
            if min_path is None or new_path < min_path:
                min_path = new_path
    return min_path",not useful
"This function computes a sequence up to index n using dynamic programming, where each term t[i] is the sum of the previous two terms plus a conditional value based on whether i is even (adding 1 + i//2) or odd (adding t[i+1], which creates a forward reference).","def tri(n):
    t = [0, 3] + [0] * n
    for i in range(2, n + 1):
        t[i] = t[i - 1] + t[i - 2] + (1 + i // 2 if i % 2 == 0 else t[i + 1])
    return t[:n + 1]",not useful
"This function builds a sequence t where each t[i] starts as the sum of t[i-1] and t[i-2] plus 2 if i is even or t[i+1] if odd, then adds i//2 if even; the forward reference to t[i+1] may cause issues as it's computed in forward order.","def tri(n):
    t = [0, 3] + [0] * n
    for i in range(2, n + 1):
        t[i] = t[i - 1] + t[i - 2] + (2 if i % 2 == 0 else t[i + 1])
        if i % 2 == 0:
            t[i] += i // 2
    return t[:n + 1]",not useful
"This function calculates the sequence t with t[i] as sum of previous two terms plus 1 + i//2 for even i or t[i+1] for odd i, using an if-else structure; the reference to t[i+1] in odd cases is problematic in forward iteration.","def tri(n):
    t = [0, 3] + [0] * n
    for i in range(2, n + 1):
        if i % 2 == 0:
            t[i] = t[i - 1] + t[i - 2] + 1 + i // 2
        else:
            t[i] = t[i - 1] + t[i - 2] + t[i + 1]
    return t[:n + 1]",not useful
"Similar to other tri functions, it computes t[i] as sum of t[i-1] and t[i-2] plus a conditional (1 + i//2 for even i, t[i+1] for odd), then returns a list comprehension of t[0 to n] instead of slicing.","def tri(n):
    t = [0, 3] + [0] * n
    for i in range(2, n + 1):
        t[i] = t[i - 1] + t[i - 2] + (1 + i // 2 if i % 2 == 0 else t[i + 1])
    return [t[i] for i in range(n + 1)]",not useful
"This function generates sequence t where t[i] sums t[i-1], t[i-2], and (2 + i if even else t[i+1]), but the addition of i instead of i//2 for even indices alters the intended computation.","def tri(n):
    t = [0, 3] + [0] * n
    for i in range(2, n + 1):
        t[i] = t[i - 1] + t[i - 2] + (2 + i if i % 2 == 0 else t[i + 1])
    return t[:n + 1]",not useful
"It computes the triangular sequence t with t[i] = t[i-1] + t[i-2] + (1 + i//2 if even else t[i+1]), using a list comprehension to return t[0 to n], similar to other variants but with explicit slicing alternative.","def tri(n):
    t = [0, 3] + [0] * n
    for i in range(2, n + 1):
        t[i] = t[i - 1] + t[i - 2] + (1 + i // 2 if i % 2 == 0 else t[i + 1])
    return [t[i] for i in range(n + 1)]",not useful
"This variant initializes t[i] as t[i-1] + t[i-2] + (2 if even else t[i+1]), then adds i//2 for even i, and uses list comprehension for output; forward reference persists.","def tri(n):
    t = [0, 3] + [0] * n
    for i in range(2, n + 1):
        t[i] = t[i - 1] + t[i - 2] + (2 if i % 2 == 0 else t[i + 1])
        if i % 2 == 0:
            t[i] += i // 2
    return [t[i] for i in range(n + 1)]",not useful
"Using if-else, it sets t[i] to t[i-1] + t[i-2] + 1 + i//2 for even i or + t[i+1] for odd, returning via list comprehension; the odd case forward reference may lead to errors.","def tri(n):
    t = [0, 3] + [0] * n
    for i in range(2, n + 1):
        if i % 2 == 0:
            t[i] = t[i - 1] + t[i - 2] + 1 + i // 2
        else:
            t[i] = t[i - 1] + t[i - 2] + t[i + 1]
    return [t[i] for i in range(n + 1)]",not useful
"This function computes t[i] as sum of previous terms plus (2 + i if even else t[i+1]), incorrectly using i instead of i//2 for even additions, and returns via list comprehension.","def tri(n):
    t = [0, 3] + [0] * n
    for i in range(2, n + 1):
        t[i] = t[i - 1] + t[i - 2] + (2 + i if i % 2 == 0 else t[i + 1])
    return [t[i] for i in range(n + 1)]",not useful
"It builds sequence t with t[i] = t[i-1] + t[i-2] + (1 + i//2 if even else t[i+1]), returning the first n+1 elements via list comprehension; forward dependency in odd indices is unresolved in forward loop.","def tri(n):
    t = [0, 3] + [0] * n
    for i in range(2, n + 1):
        t[i] = t[i - 1] + t[i - 2] + (1 + i // 2 if i % 2 == 0 else t[i + 1])
    return [t[i] for i in range(n + 1)]",not useful
"This function calculates the product of odd digits in n by extracting digits via modulo and integer division, multiplying only odd ones, and returns 0 if no odd digits (product remains 1).","def digits(n):
    product = 1
    while n:
        digit = n % 10
        if digit % 2:
            product *= digit
        n //= 10
    return product if product != 1 else 0",not useful
"Converting n to string, it iterates over each character, converts to int, and multiplies into product if odd, returning 0 if product is still 1 (no odd digits).","def digits(n):
    product = 1
    for digit in str(n):
        digit = int(digit)
        if digit % 2:
            product *= digit
    return product if product != 1 else 0",not useful
"Using reduce and map, it computes the product of odd digits from str(n), then checks if that product !=1 to return it or 0; this is a compact but less readable one-liner.","def digits(n):
    return reduce(lambda x, y: x * y if y % 2 else x, map(int, str(n)), 1) if reduce(lambda x, y: x * y if y % 2 else x, map(int, str(n)), 1) != 1 else 0",not useful
"It maps str(n) to ints and multiplies only odd digits into product, returning 0 if no odd digits were found (product==1).","def digits(n):
    product = 1
    for digit in map(int, str(n)):
        if digit % 2:
            product *= digit
    return product if product != 1 else 0",not useful
"Iterating over str(n), it converts digits to int and multiplies by digit if odd else by 1, effectively skipping evens, and returns 0 if product==1.","def digits(n):
    product = 1
    for digit in str(n):
        digit = int(digit)
        product *= digit if digit % 2 else 1
    return product if product != 1 else 0",not useful
"Similar to others, it products odd digits from str(n), but checks product >1 instead of !=1 for returning 0, which works since product starts at 1.","def digits(n):
    product = 1
    for digit in str(n):
        digit = int(digit)
        if digit % 2:
            product *= digit
    return product if product > 1 else 0",not useful
"Using map to ints from str(n), it multiplies product by digit if odd else by 1, returning 0 if unchanged (no odds).","def digits(n):
    product = 1
    for digit in map(int, str(n)):
        product *= digit if digit % 2 else 1
    return product if product != 1 else 0",not useful
"For each digit in str(n), it multiplies product by digit if odd else leaves it unchanged (product *= product, which is a no-op), returning 0 if product==1.","def digits(n):
    product = 1
    for digit in str(n):
        digit = int(digit)
        product *= digit if digit % 2 else product
    return product if product != 1 else 0",not useful
"It processes digits from str(n), multiplying odd ones and skipping evens by product *= product (no-op), returning 0 if product >1 fails (i.e., ==1).","def digits(n):
    product = 1
    for digit in str(n):
        digit = int(digit)
        product *= digit if digit % 2 else product
    return product if product > 1 else 0",not useful
"Mapping str(n) to ints, it multiplies odd digits and uses product *= product for evens (no change), returning 0 if product >1 is false.","def digits(n):
    product = 1
    for digit in map(int, str(n)):
        product *= digit if digit % 2 else product
    return product if product > 1 else 0",not useful
"This function checks for nested brackets by finding '[]' and ensuring there's a '[' after it and a ']' before the last '[]', but may not fully validate nesting.","def is_nested(string):
    return '[]' in string and '[' in string[string.index('[]')+1:] and ']' in string[:string.rindex('[]')]",useful
"It simply counts occurrences of '[]' and returns True if more than one, assuming multiple pairs indicate nesting, but this is overly simplistic and ignores positions.","def is_nested(string):
    return string.count('[]') > 1",useful
"The function returns True if there are more than one '[' and ']', and the first '[' is before the last ']', which is true for any balanced brackets but doesn't confirm nesting.","def is_nested(string):
    return string.count('[') > 1 and string.count(']') > 1 and string.index('[') < string.rindex(']')",useful
"It checks for at least one '[]' and more than one each of '[' and ']', but this counts pairs without verifying actual nesting structure.","def is_nested(string):
    return string.count('[]') > 0 and string.count('[') > 1 and string.count(']') > 1",useful
"Returning True if there's at least one '[]' and unequal counts of '[' and ']', this incorrectly identifies nesting since balanced nested would have equal counts.","def is_nested(string):
    return string.count('[]') > 0 and string.count('[') != string.count(']')",useful
"It verifies more than one '[' and ']' with first '[' before last ']', similar to others, but uses find/rfind which is equivalent to index/rindex for positions.","def is_nested(string):
    return string.count('[') > 1 and string.count(']') > 1 and string.find('[') < string.rfind(']')",useful
"Checks for '[]' presence and more '[' than ']', which would be false for balanced nesting, making it incorrect for typical nested cases like '[[]]'.","def is_nested(string):
    return string.count('[]') > 0 and string.count('[') > string.count(']')",useful
"Returns True if >1 '[' and ']', and first '[' before the first ']' after that '[', attempting to check for enclosure but may fail for complex cases.","def is_nested(string):
    return string.count('[') > 1 and string.count(']') > 1 and string.index('[') < string.index(']', string.index('[')+1)",useful
"It requires '[]', >1 each of '[' and ']', and first '[' before last ']', combining counts and positions but still not fully parsing nesting.","def is_nested(string):
    return string.count('[]') > 0 and string.count('[') > 1 and string.count(']') > 1 and string.index('[') < string.rindex(']')",useful
"Similar to 132_8, it checks >1 brackets and first '[' before the next ']' after it, using find for positions to detect potential enclosure.","def is_nested(string):
    return string.count('[') > 1 and string.count(']') > 1 and string.find('[') < string.find(']', string.find('[')+1)",useful
This function sums the squares of integers converted from each string in lst using a generator expression.,"def sum_squares(lst):
    return sum(int(i)**2 for i in lst)",useful
"Using map and lambda, it converts lst strings to ints, squares them, and sums the results.","def sum_squares(lst):
    return sum(map(lambda x: int(x)**2, lst))",useful
"It imports math and uses ceil on each element before squaring and summing, which rounds up non-integers but assumes lst contains numbers as strings.","import math
def sum_squares(lst):
    return sum(math.ceil(i)**2 for i in lst)",not useful
"Using numpy, it ceils the lst (assuming numeric strings or numbers), squares, and sums via np functions for efficient array operations.","import numpy as np
def sum_squares(lst):
    return np.sum(np.ceil(lst)**2)",not useful
"This converts lst to ints via list comprehension, squares each, and sums them up.","def sum_squares(lst):
    return sum([int(i)**2 for i in lst])",useful
"It uses pow to square each int from lst in a generator, then sums the results.","def sum_squares(lst):
    return sum(pow(int(i), 2) for i in lst)",useful
"Mapping ints from lst and using map with pow and a list of 2's, it squares each and sums, though the approach is convoluted.","def sum_squares(lst):
    return sum(map(pow, map(int, lst), [2]*len(lst)))",useful
"With reduce, it sums the squares of ints from lst by accumulating y**2 for each mapped int y.","from functools import reduce
def sum_squares(lst):
    return reduce(lambda x, y: x + y**2, map(int, lst))",not useful
"Mapping lst to ints first, then using generator to square and sum them efficiently.","def sum_squares(lst):
    return sum(i**2 for i in map(int, lst))",useful
"It maps lst to rounded floats (assuming numeric strings), squares via multiplication in generator, and sums; round handles decimals but may alter integers.","def sum_squares(lst):
    return sum(i*i for i in map(round, lst))",not useful
"This function returns True if txt is non-empty, its last character is alphabetic, and the second last is a space.","def check_if_last_char_is_a_letter(txt):
    return txt and txt[-1].isalpha() and txt[-2] == ' '",not useful
"It checks if len(txt) >1, last char is alpha, and second last is space, ensuring there's a preceding space for the last letter.","def check_if_last_char_is_a_letter(txt):
    return len(txt) > 1 and txt[-1].isalpha() and txt[-2] == ' '",useful
"Using slicing, it verifies if the last character is alpha and the second last is space, returning False for empty txt.","def check_if_last_char_is_a_letter(txt):
    return txt[-1:].isalpha() and txt[-2:-1] == ' ' if txt else False",useful
"Similar to others, it uses bool(txt) to check non-empty, then confirms last is alpha and second last is space.","def check_if_last_char_is_a_letter(txt):
    return bool(txt) and txt[-1].isalpha() and txt[-2] == ' '",not useful
"It returns True if txt non-empty, last is alpha, and either len==1 or second last is space, allowing single-letter strings.","def check_if_last_char_is_a_letter(txt):
    return txt and txt[-1].isalpha() and (len(txt) == 1 or txt[-2] == ' ')",not useful
"Checking last slice is alpha and (len<2 or second last is space), this handles short strings by not requiring a preceding space if len<2.","def check_if_last_char_is_a_letter(txt):
    return txt[-1:].isalpha() and (len(txt) < 2 or txt[-2] == ' ')",not useful
"This variant ensures txt non-empty, last alpha, and for len>=2, second last is space, accommodating single characters.","def check_if_last_char_is_a_letter(txt):
    return txt and txt[-1].isalpha() and (len(txt) < 2 or txt[-2] == ' ')",not useful
"Identical to 134_7, it checks non-empty txt with last alpha and preceding space if length allows.","def check_if_last_char_is_a_letter(txt):
    return txt and txt[-1].isalpha() and (len(txt) < 2 or txt[-2] == ' ')",not useful
"Same as previous, verifying last character is letter with optional preceding space for short strings.","def check_if_last_char_is_a_letter(txt):
    return txt and txt[-1].isalpha() and (len(txt) < 2 or txt[-2] == ' ')",not useful
"This function confirms the string is non-empty, ends with an alphabetic character, and has a space before it unless the string is a single character.","def check_if_last_char_is_a_letter(txt):
    return txt and txt[-1].isalpha() and (len(txt) < 2 or txt[-2] == ' ')",not useful
"This function iterates backwards from the second-to-last element to find the rightmost index i where arr[i] is less than arr[i-1], indicating a descent, and returns -1 if the array is non-decreasing.","def can_arrange(arr):
    for i in range(len(arr) - 1, 0, -1):
        if arr[i] < arr[i - 1]:
            return i
    return -1",useful
"Using a generator expression with next(), this function finds the rightmost index i (starting from the end) where arr[i] < arr[i-1], returning -1 if no such index exists.","def can_arrange(arr):
    return next((i for i in range(len(arr) - 1, 0, -1) if arr[i] < arr[i - 1]), -1)",useful
"This complex function reverses the array to locate the first descent from the end, then computes the original index using length and reverse indexing, returning -1 if no descent is found.","def can_arrange(arr):
    try:
        return len(arr) - 1 - arr[::-1].index(next(x for x in arr[::-1] if x < arr[len(arr) - 1 - arr[::-1].index(x)]))
    except StopIteration:
        return -1",not useful
"It uses max() with a generator to find the highest index i greater than 0 where arr[i] < arr[i-1], defaulting to -1 if the array has no descents.","def can_arrange(arr):
    return max((i for i, x in enumerate(arr) if i > 0 and x < arr[i - 1]), default=-1)",useful
"The function employs max() on a generator expression to identify the largest index i from 1 to len(arr)-1 where arr[i] < arr[i-1], or -1 if none exists.","def can_arrange(arr):
    return max((i for i in range(1, len(arr)) if arr[i] < arr[i - 1]), default=-1)",useful
"It applies max() to a filtered range of indices from 1 to len(arr)-1 where arr[i] < arr[i-1] using a lambda, returning -1 as default if no such index.","def can_arrange(arr):
    return max(filter(lambda i: arr[i] < arr[i - 1], range(1, len(arr))), default=-1)",useful
"This code finds the maximum index i in range(1, len(arr)) where arr[i-1] > arr[i], equivalent to a descent, with -1 as default if the array is non-decreasing.","def can_arrange(arr):
    return max((i for i in range(1, len(arr)) if arr[i - 1] > arr[i]), default=-1)",useful
"The function returns the maximum index i from 0 to len(arr)-2 where arr[i] > arr[i+1], identifying the left side of the rightmost descent, or -1 if sorted.","def can_arrange(arr):
    return max((i for i in range(len(arr) - 1) if arr[i] > arr[i + 1]), default=-1)",useful
"Using next() on a reversed range from len(arr)-2 to 0, it finds the rightmost i where arr[i] > arr[i+1], returning -1 if no descent exists.","def can_arrange(arr):
    return next((i for i in reversed(range(len(arr) - 1)) if arr[i] > arr[i + 1]), -1)",useful
"This iterates backwards from the end to find the last index i (including 0) where arr[i] < arr[i-1] or i==0, but may not correctly identify the rightmost descent.","def can_arrange(arr):
    return next((i for i in range(len(arr) - 1, -1, -1) if i == 0 or arr[i] < arr[i - 1]), -1)",not useful
"The function initializes variables for largest negative and smallest positive, then loops through the list to update them accordingly, returning None if no negatives or positives exist.","def largest_smallest_integers(lst):
    neg, pos = None, None
    for num in lst:
        if num < 0:
            neg = max(neg, num) if neg is not None else num
        elif num > 0:
            pos = min(pos, num) if pos is not None else num
    return neg, pos",useful
"It creates separate lists for negative and positive numbers using list comprehensions, then returns the max of negatives and min of positives, or None if empty.","def largest_smallest_integers(lst):
    neg = [x for x in lst if x < 0]
    pos = [x for x in lst if x > 0]
    return (max(neg) if neg else None, min(pos) if pos else None)",useful
"Negatives are sorted in descending order and positives in ascending; it returns the first of each sorted list if non-empty, otherwise None.","def largest_smallest_integers(lst):
    neg = sorted([x for x in lst if x < 0], reverse=True)
    pos = sorted([x for x in lst if x > 0])
    return (neg[0] if neg else None, pos[0] if pos else None)",useful
"Using list comprehensions, it filters negatives and positives, then computes max and min respectively, returning None for empty lists.","def largest_smallest_integers(lst):
    neg = [x for x in lst if x < 0]
    pos = [x for x in lst if x > 0]
    return (max(neg) if neg else None, min(pos) if pos else None)",useful
"It uses filter() with lambdas to separate negatives and positives, then applies max and min, but note that filter returns an iterator which may need list conversion for max/min.","def largest_smallest_integers(lst):
    neg = filter(lambda x: x < 0, lst)
    pos = filter(lambda x: x > 0, lst)
    return (max(neg) if neg else None, min(pos) if pos else None)",not useful
"List comprehensions filter negative and positive numbers, followed by max for negatives and min for positives, with None for empty cases.","def largest_smallest_integers(lst):
    neg = [x for x in lst if x < 0]
    pos = [x for x in lst if x > 0]
    return (max(neg) if neg else None, min(pos) if pos else None)",useful
"This separates negatives and positives via list comprehensions and returns their max and min values, or None if no such numbers exist.","def largest_smallest_integers(lst):
    neg = [x for x in lst if x < 0]
    pos = [x for x in lst if x > 0]
    return (max(neg) if neg else None, min(pos) if pos else None)",useful
"It filters the list into negative and positive sublists, then returns the maximum negative and minimum positive, handling empty lists with None.","def largest_smallest_integers(lst):
    neg = [x for x in lst if x < 0]
    pos = [x for x in lst if x > 0]
    return (max(neg) if neg else None, min(pos) if pos else None)",useful
"The code uses list comprehensions to isolate negatives and positives, computing max and min with conditional None returns for absent values.","def largest_smallest_integers(lst):
    neg = [x for x in lst if x < 0]
    pos = [x for x in lst if x > 0]
    return (max(neg) if neg else None, min(pos) if pos else None)",useful
"Negatives and positives are extracted into lists, and the function returns the largest negative and smallest positive, or None if not present.","def largest_smallest_integers(lst):
    neg = [x for x in lst if x < 0]
    pos = [x for x in lst if x > 0]
    return (max(neg) if neg else None, min(pos) if pos else None)",useful
"If either input is a string, it converts both to float by replacing commas with dots; otherwise uses originals, then returns the larger value or None if equal.","def compare_one(a, b):
    a, b = (float(str(a).replace(',', '.')), float(str(b).replace(',', '.'))) if isinstance(a, str) or isinstance(b, str) else (a, b)
    return a if a > b else b if a < b else None",useful
"It maps both inputs to floats, replacing commas with dots in their string representations, and returns the greater one or None if they are equal.","def compare_one(a, b):
    a, b = map(lambda x: float(str(x).replace(',', '.')), (a, b))
    return a if a > b else b if a < b else None",useful
"Converts to float directly if neither is string, else replaces commas with dots before conversion, then returns the larger or None if equal.","def compare_one(a, b):
    a, b = (float(a), float(b)) if not isinstance(a, str) and not isinstance(b, str) else (float(str(a).replace(',', '.')), float(str(b).replace(',', '.')))
    return a if a > b else b if a < b else None",useful
"Checks if both are numeric (int/float), converts directly; otherwise, treats as strings with comma-to-dot replacement, returning the max or None if equal.","def compare_one(a, b):
    a, b = (float(a), float(b)) if isinstance(a, (int, float)) and isinstance(b, (int, float)) else (float(str(a).replace(',', '.')), float(str(b).replace(',', '.')))
    return a if a > b else b if a < b else None",useful
"Uses map with lambda to convert to float directly if numeric, else replace comma in string and convert, then returns larger or None if equal.","def compare_one(a, b):
    a, b = map(lambda x: float(x) if isinstance(x, (int, float)) else float(str(x).replace(',', '.')), (a, b))
    return a if a > b else b if a < b else None",useful
"Attempts direct float conversion assuming inputs are int, float, or str, but sets to None otherwise; returns larger or None if equal, potentially buggy for non-numeric.","def compare_one(a, b):
    a, b = (float(a), float(b)) if type(a) in (int, float, str) and type(b) in (int, float, str) else (None, None)
    return a if a > b else b if a < b else None",not useful
"Maps inputs to float if not string, else replaces comma with dot before conversion, then returns the greater value or None if they match.","def compare_one(a, b):
    a, b = map(lambda x: float(x) if not isinstance(x, str) else float(str(x).replace(',', '.')), (a, b))
    return a if a > b else b if a < b else None",useful
"Converts based on type: direct float for numerics, comma replacement for others; uses max() if unequal, else None.","def compare_one(a, b):
    a, b = (float(a), float(b)) if isinstance(a, (int, float)) and isinstance(b, (int, float)) else (float(str(a).replace(',', '.')), float(str(b).replace(',', '.')))
    return max(a, b) if a != b else None",useful
"Maps to float with comma replacement only if string, otherwise keeps original (assuming numeric), then returns larger or None if equal.","def compare_one(a, b):
    a, b = map(lambda x: float(str(x).replace(',', '.')) if isinstance(x, str) else x, (a, b))
    return a if a > b else b if a < b else None",useful
"Converts directly if not both strings, else replaces commas; however, the condition may not handle mixed types correctly, returning larger or None if equal.","def compare_one(a, b):
    a, b = (float(a), float(b)) if not isinstance(a, str) or not isinstance(b, str) else (float(str(a).replace(',', '.')), float(str(b).replace(',', '.')))
    return a if a > b else b if a < b else None",not useful
"Checks if n is positive, even, at least 8, and (n-8) even (redundant since n even implies this), effectively verifying even n >=8.","def is_equal_to_sum_even(n):
    return n > 0 and n % 2 == 0 and n >= 8 and (n - 8) % 2 == 0",not useful
"Returns True if n is in the range starting from 8 up to but not including 5000, stepping by 2, i.e., even numbers from 8 to 4998.","def is_equal_to_sum_even(n):
    return n in range(8, 5000, 2)",not useful
Verifies if n is even and between 8 and 5000 inclusive.,"def is_equal_to_sum_even(n):
    return 8 <= n <= 5000 and n % 2 == 0",useful
"Uses bitwise AND to check if n is positive and divisible by 8, but this doesn't match even numbers >=8 accurately.","def is_equal_to_sum_even(n):
    return n & 7 == 0 and n > 0",not useful
Creates a set of even numbers from 8 to 4998 and checks if n is in it.,"def is_equal_to_sum_even(n):
    return n in {i for i in range(8, 5000, 2)}",not useful
Generates a list of even numbers from 8 to 4998 and tests membership for n.,"def is_equal_to_sum_even(n):
    return n in [i for i in range(8, 5000, 2)]",not useful
"Uses a set from range(8,5000,2) to check if n is an even number between 8 and 4998.","def is_equal_to_sum_even(n):
    return n in set(range(8, 5000, 2))",not useful
"Checks membership in an explicit set of even numbers from 8 to 5000, but the ellipsis is invalid syntax.","def is_equal_to_sum_even(n):
    return n in {8, 10, 12, ..., 5000}",not useful
"Tests if n is in range(8,5001,2), covering even numbers from 8 to 5000 inclusive.","def is_equal_to_sum_even(n):
    return n in range(8, 5001, 2)",useful
"Checks if n is in a list defined with ellipsis for even numbers from 8 to 5000, but ellipsis requires valid syntax.","def is_equal_to_sum_even(n):
    return n in [8, 10, 12, ..., 5000]",not useful
"Precomputes factorials up to n using dynamic programming, then returns (n!)^n.","def special_factorial(n):
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = i * fact[i - 1]
    return fact[n] ** n",useful
Iteratively computes the product of factorials from 1! to n! by accumulating fact and multiplying into res.,"def special_factorial(n):
    fact = 1
    res = 1
    for i in range(1, n + 1):
        fact *= i
        res *= fact
    return res",useful
"Uses math.factorial to compute n!, then raises it to the power n.","import math
def special_factorial(n):
    return math.factorial(n) ** n",useful
"Generates list of i! for i=1 to n, reduces by multiplication to get product of factorials, then raises to power n.","from functools import reduce
import operator
def special_factorial(n):
    return reduce(operator.mul, [math.factorial(i) for i in range(1, n + 1)]) ** n",not useful
"Uses NumPy to compute product of factorials from 1! to n!, then raises the result to power n.","import numpy as np
def special_factorial(n):
    return np.prod([np.math.factorial(i) for i in range(1, n + 1)]) ** n",not useful
"Reduces a list of math.factorial(i) for i=1 to n by multiplication, then uses pow to raise to n.","def special_factorial(n):
    return pow(reduce(lambda x, y: x * y, [math.factorial(i) for i in range(1, n + 1)]), n)",not useful
"Builds factorial array up to n, then computes (n!)^n using pow.","def special_factorial(n):
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = i * fact[i - 1]
    return pow(fact[n], n)",useful
"Accumulates product of factorials from 1! to n!, taking modulo 10^9+7 at each step to prevent overflow.","def special_factorial(n):
    fact = 1
    res = 1
    for i in range(1, n + 1):
        fact *= i
        res *= fact
        res %= (10 ** 9 + 7)
    return res",useful
"Computes n! via array, then raises to power n modulo 10^9+7 using pow.","def special_factorial(n):
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = i * fact[i - 1]
    return pow(fact[n], n, 10 ** 9 + 7)",useful
"Iteratively builds the product of factorials 1! to n!, applying modulo 10^9+7 to both fact and res accumulators.","def special_factorial(n):
    fact = 1
    res = 1
    mod = 10 ** 9 + 7
    for i in range(1, n + 1):
        fact = (fact * i) % mod
        res = (res * fact) % mod
    return res",useful
Generic comment: Code solution for the given function.,"import re
def fix_spaces(text):
    text = re.sub(' +', '_', text)
    text = re.sub('_+', '-', text)
    return text",not useful
Generic comment: Code solution for the given function.,"def fix_spaces(text):
    return '-'.join('_'.join(word for word in line.split(' ')) for line in text.split('  '))",not useful
Generic comment: Code solution for the given function.,"def fix_spaces(text):
    return ''.join('-' if i > 0 and c == '_' and text[i-1] == '_' else '_' if c == ' ' else c for i, c in enumerate(text))",not useful
Generic comment: Code solution for the given function.,"def fix_spaces(text):
    return ''.join('-' if text[i-1] == '_' and c == '_' else c for i, c in enumerate(text.replace(' ', '_')))",not useful
Generic comment: Code solution for the given function.,"def fix_spaces(text):
    return ''.join(c if c != ' ' else '_' if text[i-1] != ' ' or i == 0 else '-' for i, c in enumerate(text))",not useful
Generic comment: Code solution for the given function.,"def fix_spaces(text):
    return ''.join(c if c != ' ' else '_' if text[i-1] != '_' or text[i-2] == '_' else '-' for i, c in enumerate(text))",not useful
Generic comment: Code solution for the given function.,"def fix_spaces(text):
    return ''.join(c if c != ' ' else '_' if text[i-1] != '_' or text[i-2] == '_' else '-' for i, c in enumerate(text.lstrip(' ')))",not useful
Generic comment: Code solution for the given function.,"def fix_spaces(text):
    return ''.join(c if c != ' ' else '_' if not i or text[i-1] != '_' else '-' for i, c in enumerate(text))",not useful
Generic comment: Code solution for the given function.,"def fix_spaces(text):
    return ''.join(c if c != ' ' else '_' if i == 0 or text[i-1] != '_' else '-' for i, c in enumerate(text))",not useful
Generic comment: Code solution for the given function.,"def fix_spaces(text):
    return ''.join(c if c != ' ' else '_' if i == 0 or text[i-1] != '_' or text[i-2] == '_' else '-' for i, c in enumerate(text))",not useful
Generic comment: Code solution for the given function.,"def file_name_check(file_name):
    return 'Yes' if file_name.replace('.', '').isalnum() and file_name[0].isalpha() and file_name.count('.') == 1 and file_name.count('0123456789') <= 3 and file_name.split('.')[1] in ['txt', 'exe', 'dll'] else 'No'",not useful
Generic comment: Code solution for the given function.,"def file_name_check(file_name):
    import re
    return 'Yes' if re.match('^[a-zA-Z][a-zA-Z0-9]{0,2}\.[txt|exe|dll]$', file_name) else 'No'",not useful
Generic comment: Code solution for the given function.,"def file_name_check(file_name):
    parts = file_name.split('.')
    return 'Yes' if len(parts) == 2 and parts[0].isalpha() and parts[1] in ['txt', 'exe', 'dll'] and sum(c.isdigit() for c in parts[0]) <= 3 else 'No'",not useful
Generic comment: Code solution for the given function.,"def file_name_check(file_name):
    return 'Yes' if file_name[0].isalpha() and file_name.count('.') == 1 and file_name.split('.')[1] in ['txt', 'exe', 'dll'] and sum(c.isdigit() for c in file_name.split('.')[0]) <= 3 else 'No'",not useful
Generic comment: Code solution for the given function.,"def file_name_check(file_name):
    import string
    valid_chars = string.ascii_letters + string.digits + '.'
    return 'Yes' if all(c in valid_chars for c in file_name) and file_name[0].isalpha() and file_name.count('.') == 1 and file_name.split('.')[1] in ['txt', 'exe', 'dll'] and sum(c.isdigit() for c in file_name.split('.')[0]) <= 3 else 'No'",not useful
Generic comment: Code solution for the given function.,"def file_name_check(file_name):
    return 'Yes' if file_name[0].isalpha() and file_name.count('.') == 1 and file_name.split('.')[1] in ['txt', 'exe', 'dll'] and sum(c.isdigit() for c in file_name.split('.')[0]) <= 3 and file_name.replace('.', '').isalnum() else 'No'",not useful
Generic comment: Code solution for the given function.,"def file_name_check(file_name):
    import re
    return 'Yes' if re.match('^[a-zA-Z][a-zA-Z0-9]{0,2}\.(txt|exe|dll)$', file_name) else 'No'",not useful
Generic comment: Code solution for the given function.,"def file_name_check(file_name):
    return 'Yes' if file_name[0].isalpha() and file_name.count('.') == 1 and file_name.split('.')[1] in ['txt', 'exe', 'dll'] and sum(c.isdigit() for c in file_name.split('.')[0]) <= 3 and file_name.replace('.', '').isalnum() and file_name.split('.')[0].isalpha() else 'No'",not useful
Generic comment: Code solution for the given function.,"def file_name_check(file_name):
    import re
    return 'Yes' if re.match('^[a-zA-Z][a-zA-Z0-9]{0,2}\.(txt|exe|dll)$', file_name) and sum(c.isdigit() for c in file_name.split('.')[0]) <= 3 else 'No'",not useful
Generic comment: Code solution for the given function.,"def file_name_check(file_name):
    return 'Yes' if file_name[0].isalpha() and file_name.count('.') == 1 and file_name.split('.')[1] in ['txt', 'exe', 'dll'] and sum(c.isdigit() for c in file_name.split('.')[0]) <= 3 and file_name.replace('.', '').isalnum() and file_name.split('.')[0][0].isalpha() else 'No'",not useful
Generic comment: Code solution for the given function.,"def sum_squares(lst):
    return sum(x**2 if i%3==0 else x**3 if i%4==0 and i%3!=0 else x for i, x in enumerate(lst))",not useful
Generic comment: Code solution for the given function.,"def sum_squares(lst):
    return sum(x**2 if i%3==0 else x**3 if i%4==0 and i%3!=0 else x for i, x in enumerate(lst, 1))",not useful
Generic comment: Code solution for the given function.,"def sum_squares(lst):
    return sum(x**2 if i%3==0 else x**3 if i%4==0 and i%3!=0 else x for i in range(len(lst)) for x in [lst[i]])",not useful
Generic comment: Code solution for the given function.,"def sum_squares(lst):
    return sum(x**2 if i%3==0 else x**3 if i%4==0 and i%3!=0 else x for i in range(len(lst)) for x in (lst[i],))",not useful
Generic comment: Code solution for the given function.,"def sum_squares(lst):
    return sum(map(lambda i: lst[i]**2 if i%3==0 else lst[i]**3 if i%4==0 and i%3!=0 else lst[i], range(len(lst))))",not useful
Generic comment: Code solution for the given function.,"def sum_squares(lst):
    return sum(lst[i]**2 if i%3==0 else lst[i]**3 if i%4==0 and i%3!=0 else lst[i] for i in range(len(lst)))",not useful
Generic comment: Code solution for the given function.,"def sum_squares(lst):
    return sum(lst[i]**2 if i%3==0 else lst[i]**3 if i%4==0 and i%3!=0 else lst[i] for i in range(len(lst)) if i%3==0 or i%4==0)",not useful
Generic comment: Code solution for the given function.,"def sum_squares(lst):
    return sum(lst[i]**2 if i%3==0 else lst[i]**3 if i%4==0 and i%3!=0 else lst[i] for i in range(len(lst)) if i%3==0 or (i%4==0 and i%3!=0))",not useful
Generic comment: Code solution for the given function.,"def sum_squares(lst):
    return sum(lst[i]**2 if i%3==0 else lst[i]**3 if i%4==0 and i%3!=0 else lst[i] for i in range(len(lst)) if i%3==0 or i%4==0 and i%3!=0)",not useful
Generic comment: Code solution for the given function.,"def sum_squares(lst):
    return sum(lst[i]**2 if i%3==0 else lst[i]**3 if i%4==0 and i%3!=0 else lst[i] for i in range(len(lst)) if i%3==0 or (i%4==0 and i%3!=0))",not useful
Generic comment: Code solution for the given function.,"def words_in_sentence(sentence):
    def is_prime(n):
        if n < 2: return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0: return False
        return True
    return ' '.join(word for word in sentence.split() if is_prime(len(word)))",not useful
Generic comment: Code solution for the given function.,"def words_in_sentence(sentence):
    primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
    return ' '.join(word for word in sentence.split() if len(word) in primes)",not useful
Generic comment: Code solution for the given function.,"def words_in_sentence(sentence):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    return ' '.join(word for word in sentence.split() if len(word) in primes)",not useful
Generic comment: Code solution for the given function.,"def words_in_sentence(sentence):
    primes = [False, False] + [True for _ in range(2, 101)]
    for i in range(2, int(101**0.5) + 1):
        if primes[i]:
            for j in range(i*i, 101, i):
                primes[j] = False
    return ' '.join(word for word in sentence.split() if primes[len(word)])",not useful
Generic comment: Code solution for the given function.,"def words_in_sentence(sentence):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    words = sentence.split()
    return ' '.join(word for word in words if len(word) in primes)",not useful
Generic comment: Code solution for the given function.,"def words_in_sentence(sentence):
    primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
    words = sentence.split()
    return ' '.join(word for word in words if len(word) in primes)",not useful
Generic comment: Code solution for the given function.,"def words_in_sentence(sentence):
    def is_prime(n):
        if n < 2: return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0: return False
        return True
    words = sentence.split()
    return ' '.join(word for word in words if is_prime(len(word)))",not useful
Generic comment: Code solution for the given function.,"def words_in_sentence(sentence):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    words = sentence.split()
    return ' '.join(word for word in words if len(word) in primes)",not useful
Generic comment: Code solution for the given function.,"def words_in_sentence(sentence):
    primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
    words = sentence.split()
    return ' '.join(word for word in words if len(word) in primes)",not useful
Generic comment: Code solution for the given function.,"def words_in_sentence(sentence):
    primes = [False, False] + [True for _ in range(2, 101)]
    for i in range(2, int(101**0.5) + 1):
        if primes[i]:
            for j in range(i*i, 101, i):
                primes[j] = False
    words = sentence.split()
    return ' '.join(word for word in words if primes[len(word)])",not useful
Generic comment: Code solution for the given function.,"def simplify(x, n):
    a, b = map(int, x.split('/'))
    c, d = map(int, n.split('/'))
    return (a * c) % (b * d) == 0",not useful
Generic comment: Code solution for the given function.,"import math
def simplify(x, n):
    a, b = map(int, x.split('/'))
    c, d = map(int, n.split('/'))
    return math.gcd(a * c, b * d) > 1",not useful
Generic comment: Code solution for the given function.,"from fractions import Fraction
def simplify(x, n):
    return Fraction(x) * Fraction(n) == int(Fraction(x) * Fraction(n))",not useful
Generic comment: Code solution for the given function.,"def simplify(x, n):
    a, b = map(int, x.split('/'))
    c, d = map(int, n.split('/'))
    return (a * d) % (b * c) == 0",not useful
Generic comment: Code solution for the given function.,"def simplify(x, n):
    a, b = map(int, x.split('/'))
    c, d = map(int, n.split('/'))
    return (a * d) // math.gcd(a * d, b * c) == (b * c) // math.gcd(a * d, b * c)",not useful
Generic comment: Code solution for the given function.,"def simplify(x, n):
    a, b = map(int, x.split('/'))
    c, d = map(int, n.split('/'))
    return (a * c) / math.gcd(a * c, b * d) == (b * d) / math.gcd(a * c, b * d)",not useful
Generic comment: Code solution for the given function.,"def simplify(x, n):
    a, b = map(int, x.split('/'))
    c, d = map(int, n.split('/'))
    return (a * d) % math.gcd(a * d, b * c) == 0",not useful
Generic comment: Code solution for the given function.,"def simplify(x, n):
    a, b = map(int, x.split('/'))
    c, d = map(int, n.split('/'))
    return (a * c) / math.gcd(a, b) / math.gcd(c, d) == int((a * c) / math.gcd(a, b) / math.gcd(c, d))",not useful
Generic comment: Code solution for the given function.,"def simplify(x, n):
    a, b = map(int, x.split('/'))
    c, d = map(int, n.split('/'))
    return (a * d) % math.gcd(b, d) == 0 and (b * c) % math.gcd(b, d) == 0",not useful
Generic comment: Code solution for the given function.,"def simplify(x, n):
    a, b = map(int, x.split('/'))
    c, d = map(int, n.split('/'))
    return (a * d) / math.gcd(a * d, b * c) == int((a * d) / math.gcd(a * d, b * c))",not useful
"This function sorts the list of numbers primarily by the sum of the digits of their absolute values, and secondarily by their original index in the list using a lambda key with a generator expression for digit sum.","def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))",useful
"This function sorts the input list by the sum of digits of absolute values first, then by original position, utilizing map to convert string digits to integers for the sum.","def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))",useful
"It sorts the numbers ascending by digit sum of abs(x) and original index, explicitly setting reverse=False, with map for efficient digit summation.","def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)), reverse=False)",useful
"The code sorts nums based on the sum of digits from str(abs(x)) using a generator, followed by the element's index as a tiebreaker.","def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(int(i) for i in str(abs(x))), nums.index(x)))",useful
"This sorts the list by digit sum and index, with reverse=False specified, employing map to sum the integer digits of the absolute value string.","def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)), reverse=False)",useful
"It performs sorting on digit sums of absolute values and original indices, explicitly non-reversing, via generator for digit conversion.","def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)), reverse=False)",useful
"The function sorts by sum of digits in abs(x) string and index, with reverse=False, using a generator expression for int conversion.","def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(int(i) for i in str(abs(x))), nums.index(x)), reverse=False)",useful
"Sorting is done by digit sum using map on str(abs(x)) and by index, with explicit reverse=False for ascending order.","def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)), reverse=False)",useful
"This code sorts nums ascending by the sum of absolute value digits and original position, specifying reverse=False in sorted.","def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)), reverse=False)",useful
"It sorts the list using map for digit sums of abs(x) as primary key and index as secondary, with reverse=False.","def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)), reverse=False)",useful
This function counts numbers greater than 10 that are odd and have an odd last digit by summing a generator expression.,"def specialFilter(nums):
    return sum(1 for num in nums if num > 10 and num % 2 != 0 and int(str(num)[-1]) % 2 != 0)",not useful
It returns the length of a list comprehension filtering nums >10 with odd last digit and odd first digit using set membership.,"def specialFilter(nums):
    return len([num for num in nums if num > 10 and num % 10 in {1, 3, 5, 7, 9} and int(str(num)[0]) in {1, 3, 5, 7, 9}])",useful
"The code sums a generator that checks for numbers >10, odd, and odd-ending digit using a set for the last digit.","def specialFilter(nums):
    return sum(num > 10 and num % 2 != 0 and int(str(num)[-1]) in {1, 3, 5, 7, 9} for num in nums)",not useful
"This counts elements >10 where the number is odd (via %10 %2 !=0, which is incorrect for full oddness) and first digit odd via modulo.","def specialFilter(nums):
    return sum(num > 10 and num % 10 % 2 != 0 and int(str(num)[0]) % 2 != 0 for num in nums)",not useful
It filters and counts numbers >10 with both first and last characters in odd digits '13579' using list comprehension length.,"def specialFilter(nums):
    return len([num for num in nums if num > 10 and str(num)[0] in '13579' and str(num)[-1] in '13579'])",useful
"The function uses a generator to sum counts of nums >10 where first and last digits are odd, checked via string membership.","def specialFilter(nums):
    return sum(1 for num in nums if num > 10 and str(num)[0] in '13579' and str(num)[-1] in '13579')",useful
"This incorrectly counts odd numbers >10 that don't end with 0, using list length, missing first digit check.","def specialFilter(nums):
    return len([num for num in nums if num > 10 and num % 2 != 0 and num % 10 != 0])",not useful
"It sums a generator for odd nums >10 not ending in 0, but fails to verify first digit oddness properly.","def specialFilter(nums):
    return sum(1 for num in nums if num > 10 and num % 2 != 0 and num % 10 != 0)",not useful
The code counts via list length numbers >10 with odd last digit and odd tens digit (for two-digit numbers).,"def specialFilter(nums):
    return len([num for num in nums if num > 10 and num % 10 in {1, 3, 5, 7, 9} and num // 10 % 10 in {1, 3, 5, 7, 9}])",not useful
This uses a generator to count nums >10 with odd units and tens digits using integer division and modulo.,"def specialFilter(nums):
    return sum(1 for num in nums if num > 10 and num % 10 in {1, 3, 5, 7, 9} and num // 10 % 10 in {1, 3, 5, 7, 9})",not useful
"It counts residues of (i^2 - i +1) %3 for i=1 to n, then computes max triples as C(c[0],3) + C(c[1],2)*c[2] for sum mod3=0.","def get_max_triples(n):
    c = [0, 0, 0]
    for i in range(1, n + 1):
        c[(i * i - i + 1) % 3] += 1
    return c[0] * (c[0] - 1) * (c[0] - 2) // 6 + c[1] * (c[1] - 1) // 2 * c[2]",not useful
"The function tallies mod3 residues using (i^2 -i +1)%3, calculating total triples as sum of C(c[i],3) for all i plus c[0]*c[1]*c[2].","def get_max_triples(n):
    c = [0, 0, 0]
    for i in range(1, n + 1):
        c[(i * i - i + 1) % 3] += 1
    return sum(c[i] * (c[i] - 1) * (c[i] - 2) // 6 for i in range(3)) + c[0] * c[1] * c[2]",not useful
"It computes counts with (i^2 -i)%3, then max triples via combinations of three 0's and two 1's with one 2 mod3.","def get_max_triples(n):
    c = [0, 0, 0]
    for i in range(1, n + 1):
        c[(i * i - i) % 3] += 1
    return c[0] * (c[0] - 1) * (c[0] - 2) // 6 + c[1] * (c[1] - 1) // 2 * c[2]",not useful
"Using (i^2 -i)%3 for residues, it sums all C(c[i],3) and adds products c[0]*c[1]*c[2] for mixed residue triples.","def get_max_triples(n):
    c = [0, 0, 0]
    for i in range(1, n + 1):
        c[(i * i - i) % 3] += 1
    return sum(c[i] * (c[i] - 1) * (c[i] - 2) // 6 for i in range(3)) + c[0] * c[1] * c[2]",not useful
"Counts (i^2 -i +1)%3 residues, but incorrectly uses (n - c[0]-c[1]-c[2]) which is 0, for triple calculation.","def get_max_triples(n):
    c = [0, 0, 0]
    for i in range(1, n + 1):
        c[(i * i - i + 1) % 3] += 1
    return c[0] * (c[0] - 1) * (c[0] - 2) // 6 + c[1] * c[2] * (n - c[0] - c[1] - c[2])",not useful
"With (i^2 -i)%3, it attempts max triples but uses erroneous (n - sum c) term which equals zero.","def get_max_triples(n):
    c = [0, 0, 0]
    for i in range(1, n + 1):
        c[(i * i - i) % 3] += 1
    return c[0] * (c[0] - 1) * (c[0] - 2) // 6 + c[1] * c[2] * (n - c[0] - c[1] - c[2])",not useful
"Residues via (i^2 -i +1)%3, computes C(c[0],3) + C(c[1],2) * (n - c[0] - c[1]), but n - c[0]-c[1] = c[2].","def get_max_triples(n):
    c = [0, 0, 0]
    for i in range(1, n + 1):
        c[(i * i - i + 1) % 3] += 1
    return c[0] * (c[0] - 1) * (c[0] - 2) // 6 + c[1] * (c[1] - 1) // 2 * (n - c[0] - c[1])",not useful
"Uses (i^2 -i)%3 for counts, then C(c[0],3) + C(c[1],2) * (n - c[0] - c[1]) where the latter is c[2].","def get_max_triples(n):
    c = [0, 0, 0]
    for i in range(1, n + 1):
        c[(i * i - i) % 3] += 1
    return c[0] * (c[0] - 1) * (c[0] - 2) // 6 + c[1] * (c[1] - 1) // 2 * (n - c[0] - c[1])",not useful
"Counts (i^2 -i +1)%3, but flawed formula with c[1]*c[2]*(c[1]+c[2]-n) which is negative or incorrect.","def get_max_triples(n):
    c = [0, 0, 0]
    for i in range(1, n + 1):
        c[(i * i - i + 1) % 3] += 1
    return c[0] * (c[0] - 1) * (c[0] - 2) // 6 + c[1] * c[2] * (c[1] + c[2] - n)",not useful
"With (i^2 -i)%3 residues, it uses incorrect c[1]*c[2]*(c[1]+c[2]-n) for the mixed triples part.","def get_max_triples(n):
    c = [0, 0, 0]
    for i in range(1, n + 1):
        c[(i * i - i) % 3] += 1
    return c[0] * (c[0] - 1) * (c[0] - 2) // 6 + c[1] * c[2] * (c[1] + c[2] - n)",not useful
"This function returns a tuple of planets between p1 and p2 in the solar system order, using list slicing, or empty tuple if not found via try-except.","def bf(p1, p2):
    planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
    try:
        return tuple(planets[planets.index(p1)+1:planets.index(p2)])
    except ValueError:
        return ()",useful
"It slices the planets list from after p1 to p2 if both exist, otherwise returns empty tuple, ensuring validity before indexing.","def bf(p1, p2):
    planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
    if p1 in planets and p2 in planets:
        return tuple(planets[planets.index(p1)+1:planets.index(p2)])
    return ()",useful
"Using a dict for planet positions, it generates a tuple of planets with positions strictly between p1 and p2 if both are valid.","def bf(p1, p2):
    planets = {""Mercury"": 0, ""Venus"": 1, ""Earth"": 2, ""Mars"": 3, ""Jupiter"": 4, ""Saturn"": 5, ""Uranus"": 6, ""Neptune"": 7}
    if p1 in planets and p2 in planets:
        return tuple(planet for planet in planets if planets[p1] < planets[planet] < planets[p2])
    return ()",useful
"The code attempts to slice planets between p1 and p2, catching any exception (including ValueError) to return empty tuple.","def bf(p1, p2):
    planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
    try:
        return tuple(planets[planets.index(p1)+1:planets.index(p2)])
    except:
        return ()",not useful
"It checks if p1 and p2 are in the list, then uses a generator to collect planets by index range between them.","def bf(p1, p2):
    planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
    if p1 in planets and p2 in planets:
        return tuple(planets[i] for i in range(planets.index(p1)+1, planets.index(p2)))
    return ()",useful
"With a dict assigning positions 1-8, it filters planets whose distances are between p1 and p2 if both present.","def bf(p1, p2):
    planets = {""Mercury"": 1, ""Venus"": 2, ""Earth"": 3, ""Mars"": 4, ""Jupiter"": 5, ""Saturn"": 6, ""Uranus"": 7, ""Neptune"": 8}
    if p1 in planets and p2 in planets:
        return tuple(planet for planet, distance in planets.items() if planets[p1] < distance < planets[p2])
    return ()",useful
"This generates planets between indices of p1 and p2 using a range and indexing, if both planets exist in the list.","def bf(p1, p2):
    planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
    if p1 in planets and p2 in planets:
        return tuple(planets[planets.index(p1)+i+1] for i in range(planets.index(p2) - planets.index(p1) - 1))
    return ()",useful
"It filters the dict keys for planets between p1 and p2 positions, but checks membership inside the comprehension which may be inefficient.","def bf(p1, p2):
    planets = {""Mercury"": 0, ""Venus"": 1, ""Earth"": 2, ""Mars"": 3, ""Jupiter"": 4, ""Saturn"": 5, ""Uranus"": 6, ""Neptune"": 7}
    return tuple(planet for planet in planets if p1 in planets and p2 in planets and planets[p1] < planets[planet] < planets[p2])",useful
The function uses a list comprehension with index conditions to collect planets strictly between p1 and p2 indices if valid.,"def bf(p1, p2):
    planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
    if p1 in planets and p2 in planets:
        return tuple(planets[i] for i in range(len(planets)) if planets.index(p1) < i < planets.index(p2))
    return ()",useful
"It returns a tuple by filtering planets whose indices are between those of p1 and p2, after validating both inputs.","def bf(p1, p2):
    planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
    if p1 in planets and p2 in planets:
        return tuple(planet for planet in planets if planets.index(p1) < planets.index(planet) < planets.index(p2))
    return ()",useful
"This filters words with even lengths from the list, then sorts them ascending by length only, without secondary lexicographic sort.","def sorted_list_sum(lst):
    return sorted(sorted(word for word in lst if len(word) % 2 == 0), key=len)",not useful
"The code filters even-length words using filter, then sorts by tuple key of (length, word) for length then alphabetical order.","def sorted_list_sum(lst):
    return sorted(filter(lambda x: len(x) % 2 == 0, lst), key=lambda x: (len(x), x))",useful
"It creates a list of even-length words, then sorts in-place by (length, word) key for primary length and secondary lex order.","def sorted_list_sum(lst):
    lst = [word for word in lst if len(word) % 2 == 0]
    lst.sort(key=lambda x: (len(x), x))
    return lst",useful
"Filters words where length %2 ==0 using not len%2, then sorts by (len, word) for even lengths first, then alphabetically.","def sorted_list_sum(lst):
    lst = [word for word in lst if not len(word) % 2]
    return sorted(lst, key=lambda x: (len(x), x))",useful
"Extracts even-length words, sorts by length ascending, then sorts the result lexicographically, achieving length then alpha order due to stability.","def sorted_list_sum(lst):
    lst = [word for word in lst if len(word) % 2 == 0]
    lst.sort(key=len)
    lst.sort()
    return lst",not useful
"Filters even-length words, first sorts lex, then by length; since sort is stable, it groups by length with alpha within, but overall not purely by length first.","def sorted_list_sum(lst):
    lst = [word for word in lst if len(word) % 2 == 0]
    lst.sort()
    lst.sort(key=len)
    return lst",not useful
"This builds a list of even-length words and sorts them in-place using key (length, word) for correct primary and secondary ordering.","def sorted_list_sum(lst):
    lst = [word for word in lst if len(word) % 2 == 0]
    lst.sort(key=lambda x: (len(x), x))
    return lst",useful
"Filters even lengths, sorts by length, then by (length, word); the second sort refines to proper length-alpha but is redundant.","def sorted_list_sum(lst):
    lst = [word for word in lst if len(word) % 2 == 0]
    lst.sort(key=len)
    lst.sort(key=lambda x: (len(x), x))
    return lst",useful
"It filters the list for even-length words and sorts them by length first, then alphabetically via the tuple key.","def sorted_list_sum(lst):
    lst = [word for word in lst if len(word) % 2 == 0]
    lst.sort(key=lambda x: (len(x), x))
    return lst",useful
"Extracts even-length words, performs two sorts: first by length, then by (length, word), ensuring correct ordering though inefficient.","def sorted_list_sum(lst):
    lst = [word for word in lst if len(word) % 2 == 0]
    lst.sort(key=len)
    lst.sort(key=lambda x: (len(x), x))
    return lst",useful
"This function checks if n is prime by verifying that n > 1 and has no divisors from 2 to sqrt(n) using all() on modulo operations, returning x if prime and y otherwise.","def x_or_y(n, x, y):
    return x if all(n % i for i in range(2, int(n**0.5) + 1)) and n > 1 else y",useful
"This function tests primality of n by checking for divisors from 2 to sqrt(n); it returns y if n < 2 or divisible, otherwise x.","def x_or_y(n, x, y):
    if n < 2:
        return y
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return y
    return x",useful
"This function implements an efficient primality test handling small primes 2 and 3 separately, skipping multiples of 2 and 3 using a 6k1 wheel, returning x if prime and y otherwise.","def x_or_y(n, x, y):
    if n < 2:
        return y
    if n == 2 or n == 3:
        return x
    if n % 2 == 0 or n % 3 == 0:
        return y
    i = 5
    w = 2
    while i * i <= n:
        if n % i == 0:
            return y
        i += w
        w = 6 - w
    return x",useful
"This function checks primality by handling n < 2 and even n separately, then testing odd divisors from 3 to sqrt(n), returning x if prime and y otherwise.","def x_or_y(n, x, y):
    if n < 2:
        return y
    if n == 2:
        return x
    if n % 2 == 0:
        return y
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return y
    return x",useful
"This function tests for primality by checking divisibility by 2 and 3 first, then using a 6k1 wheel to check potential divisors from 5 onwards, returning x if prime and y otherwise.","def x_or_y(n, x, y):
    if n < 2:
        return y
    for i in [2, 3]:
        if n == i:
            return x
        if n % i == 0:
            return y
    for i in range(5, int(n**0.5) + 1, 6):
        if n % i == 0 or n % (i + 2) == 0:
            return y
    return x",useful
"This function performs a primality test optimized with a 6k1 wheel after handling small primes and multiples of 2 and 3, returning x if prime and y otherwise.","def x_or_y(n, x, y):
    if n < 2:
        return y
    if n == 2 or n == 3:
        return x
    if n % 2 == 0 or n % 3 == 0:
        return y
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return y
        i += 6
    return x",useful
"This function checks if n is prime by excluding n < 2 and even numbers, then testing odd divisors up to sqrt(n), returning x if prime and y otherwise.","def x_or_y(n, x, y):
    if n < 2:
        return y
    if n == 2:
        return x
    if n % 2 == 0:
        return y
    max_div = int(n**0.5) + 1
    for i in range(3, max_div, 2):
        if n % i == 0:
            return y
    return x",useful
"This function tests primality starting with small cases, then checks divisors in a pattern that increments by 2 and 4 to skip evens, returning x if prime and y otherwise.","def x_or_y(n, x, y):
    if n < 2:
        return y
    if n == 2 or n == 3:
        return x
    if n % 2 == 0 or n % 3 == 0:
        return y
    i = 5
    while i * i <= n:
        if n % i == 0:
            return y
        i += 2
        if n % i == 0:
            return y
        i += 4
    return x",useful
"This function determines primality by handling n < 2 and even n, then checking odd divisors from 3 to sqrt(n), returning x if prime and y otherwise.","def x_or_y(n, x, y):
    if n < 2:
        return y
    if n == 2:
        return x
    if n % 2 == 0:
        return y
    max_div = int(n**0.5) + 1
    for i in range(3, max_div, 2):
        if n % i == 0:
            return y
    return x",useful
"This function implements a basic primality test by skipping evens after checking n < 2 and divisibility by 2, testing odd numbers up to sqrt(n), returning x if prime and y otherwise.","def x_or_y(n, x, y):
    if n < 2:
        return y
    if n == 2:
        return x
    if n % 2 == 0:
        return y
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return y
    return x",useful
"This function sums the squares of positive odd integers in the list, filtering for elements greater than 0, odd, and integers using x == int(x).","def double_the_difference(lst):
    return sum(x**2 for x in lst if x > 0 and x % 2 == 1 and x == int(x))",useful
"This function uses map and lambda to sum squares of positive odd integers in the list, returning 0 for non-matching elements and checking integrality with x == int(x).","def double_the_difference(lst):
    return sum(map(lambda x: x**2 if x > 0 and x % 2 == 1 and x == int(x) else 0, lst))",useful
"This function filters the list for positive odd integers using a lambda, then sums their squares, verifying integers with x == int(x).","def double_the_difference(lst):
    return sum(x**2 for x in filter(lambda x: x > 0 and x % 2 == 1 and x == int(x), lst))",useful
"This function sums squares of positive odd integers, using isinstance for integer check and x % 2 for oddness (truthy for odds).","def double_the_difference(lst):
    return sum(x**2 for x in lst if isinstance(x, int) and x > 0 and x % 2)",useful
"This function sums squares of positive odd integers, checking oddness with x % 2 and integrality with x.is_integer() for floats.","def double_the_difference(lst):
    return sum(x**2 for x in lst if x > 0 and x % 2 and x.is_integer())",not useful
"This function computes the sum of squares for positive odd integers, using x == round(x) to verify they are integers.","def double_the_difference(lst):
    return sum(x**2 for x in lst if x > 0 and x % 2 and x == round(x))",useful
"This function sums squares of positive odd integers, confirming integrality by checking if x - int(x) == 0.","def double_the_difference(lst):
    return sum(x**2 for x in lst if x > 0 and x % 2 and x - int(x) == 0)",useful
"This function sums the squares of positive odd integers, using x % 1 == 0 to check for whole numbers.","def double_the_difference(lst):
    return sum(x**2 for x in lst if x > 0 and x % 2 and x % 1 == 0)",useful
"This function sums squares of positive odd integers, checking integrality with not x % 1 (i.e., whole numbers).","def double_the_difference(lst):
    return sum(x**2 for x in lst if x > 0 and x % 2 and not x % 1)",useful
"This function sums the squares of positive odd integers in the list, using x.is_integer() to ensure they are whole numbers.","def double_the_difference(lst):
    return sum(x**2 for x in lst if x > 0 and x % 2 and x.is_integer())",not useful
This function returns a list of absolute differences between corresponding elements of guess and game using zip and list comprehension.,"def compare(game, guess):
    return [abs(g - s) for g, s in zip(guess, game)]",useful
This function computes absolute differences pairwise between guess and game using map with lambda and zip.,"def compare(game, guess):
    return list(map(lambda g, s: abs(g - s), guess, game))",useful
This function calculates absolute differences by iterating over indices and subtracting guess[i] from game[i].,"def compare(game, guess):
    return [abs(guess[i] - game[i]) for i in range(len(game))]",useful
This function uses enumerate on game to compute absolute differences with corresponding guess elements.,"def compare(game, guess):
    return [abs(guess[i] - score) for i, score in enumerate(game)]",useful
This function employs enumerate on guess to calculate absolute differences from game elements by index.,"def compare(game, guess):
    return [abs(g - game[i]) for i, g in enumerate(guess)]",useful
"This function uses NumPy to subtract arrays of guess and game, then takes absolute values and converts to list.","import numpy as np
def compare(game, guess):
    return np.abs(np.array(guess) - np.array(game)).tolist()",useful
This function computes absolute differences using operator.sub with zip on guess and game.,"from operator import sub
def compare(game, guess):
    return [abs(sub(g, s)) for g, s in zip(guess, game)]",useful
This function calculates absolute differences using a nested list comprehension with range and a single-element list for game[i].,"def compare(game, guess):
    return [abs(guess[i] - score) for i in range(len(game)) for score in [game[i]]]",useful
This function returns absolute differences between paired elements from game and guess using zip (note: zip order is game first).,"def compare(game, guess):
    return [abs(g - s) for s, g in zip(game, guess)]",useful
"This function computes absolute differences using walrus operator for indexing, but only for unequal pairs and pads with zeros if lengths differ.","def compare(game, guess):
    return [abs(g - game[i]) for i in range(len(game)) if (g := guess[i]) != (s := game[i])] + [0] * (len(game) - len(guess))",not useful
"This function selects the strongest extension by maximizing (uppercase count - lowercase count) and ties by earliest index, appending it to class_name.","def Strongest_Extension(class_name, extensions):
    return class_name + '.' + max(extensions, key=lambda x: (sum(c.isupper() for c in x) - sum(c.islower() for c in x), -extensions.index(x)))",useful
"This function computes strengths as uppercase minus lowercase counts for each extension, then appends the one with maximum strength to class_name.","def Strongest_Extension(class_name, extensions):
    strengths = [(sum(c.isupper() for c in ext) - sum(c.islower() for c in ext), ext) for ext in extensions]
    return class_name + '.' + max(strengths)[1]",not useful
"This function calculates strengths using sum and map for case checks on each extension, appending the max strength one to class_name.","def Strongest_Extension(class_name, extensions):
    strengths = [(sum(map(str.isupper, ext)) - sum(map(str.islower, ext)), ext) for ext in extensions]
    return class_name + '.' + max(strengths)[1]",not useful
"This function determines extension strengths by summing (isupper - islower) for each character, then appends the strongest to class_name.","def Strongest_Extension(class_name, extensions):
    strengths = [(sum(c.isupper() - c.islower() for c in ext), ext) for ext in extensions]
    return class_name + '.' + max(strengths)[1]",not useful
"This function evaluates strengths by assigning +1 for uppercase, -1 for lowercase per character, then appends the maximum strength extension.","def Strongest_Extension(class_name, extensions):
    strengths = [(sum(1 if c.isupper() else -1 if c.islower() else 0 for c in ext), ext) for ext in extensions]
    return class_name + '.' + max(strengths)[1]",not useful
"This function computes strengths using ord checks for case (misstated: actually lower for upper, upper for lower?), but aims to append the strongest extension.","def Strongest_Extension(class_name, extensions):
    strengths = [(sum(ord(c) < 97 for c in ext) - sum(ord(c) > 90 for c in ext), ext) for ext in extensions]
    return class_name + '.' + max(strengths)[1]",not useful
"This function calculates strengths with indices for tie-breaking, selecting the extension with max strength by earliest position and appending it.","def Strongest_Extension(class_name, extensions):
    strengths = [(sum(c.isupper() for c in ext) - sum(c.islower() for c in ext), i) for i, ext in enumerate(extensions)]
    return class_name + '.' + extensions[max(strengths)[1]]",not useful
"This function uses enumerate to track indices for tie-breaking on strengths (upper - lower counts), appending the earliest max strength extension.","def Strongest_Extension(class_name, extensions):
    strengths = [(sum(c.isupper() - c.islower() for c in ext), i) for i, ext in enumerate(extensions)]
    return class_name + '.' + extensions[max(strengths)[1]]",not useful
"This function computes per-character case scores (+1 upper, -1 lower) with indices, appending the earliest maximum strength extension.","def Strongest_Extension(class_name, extensions):
    strengths = [(sum(1 if c.isupper() else -1 if c.islower() else 0 for c in ext), i) for i, ext in enumerate(extensions)]
    return class_name + '.' + extensions[max(strengths)[1]]",not useful
"This function uses ord-based case detection with indices for ties, appending the earliest extension with maximum strength score.","def Strongest_Extension(class_name, extensions):
    strengths = [(sum(ord(c) < 97 for c in ext) - sum(ord(c) > 90 for c in ext), i) for i, ext in enumerate(extensions)]
    return class_name + '.' + extensions[max(strengths)[1]]",not useful
This function checks if b is a substring of any rotation of a by generating rotations and using 'in' operator.,"def cycpattern_check(a, b):
    return any(b in a[i:] + a[:i] for i in range(len(b)))",useful
"This function verifies if b matches any contiguous substring of a or a wrap-around substring from rotations, using slicing.","def cycpattern_check(a, b):
    return any(a[i:i + len(b)] == b for i in range(len(a) - len(b) + 1)) or any(a[i:] + a[:len(b) - i] == b for i in range(1, len(b)))",not useful
This function efficiently checks if b is a cyclic substring of a by searching b in a+a and ensuring length condition.,"def cycpattern_check(a, b):
    return (b in a + a) and (len(b) <= len(a))",useful
This function tests for b as a substring in a or in wrap-around positions using slicing for rotations.,"def cycpattern_check(a, b):
    return any(a[i:i + len(b)] == b for i in range(len(a))) or any(a[i:] + a[:len(b) - i] == b for i in range(1, len(b)))",not useful
This function checks contiguous and wrap-around matches of b in a using range up to len(b) for rotations.,"def cycpattern_check(a, b):
    return any(a[i:i + len(b)] == b for i in range(len(a))) or any(a[i:] + a[:len(b) - i] == b for i in range(len(b)))",not useful
"This function attempts to find b in contiguous slices of a or wrap-around concatenations, but range may overextend.","def cycpattern_check(a, b):
    return any(a[i:i + len(b)] == b for i in range(len(a))) or any(a[i:] + a[:len(b) - i] == b for i in range(len(a)))",not useful
This function searches for b in linear substrings of a and wrap-around parts using appropriate range for rotations.,"def cycpattern_check(a, b):
    return any(a[i:i + len(b)] == b for i in range(len(a))) or any(a[i:] + a[:len(b) - i] == b for i in range(len(a) - len(b) + 1))",not useful
"This function checks for b in substrings of a and wrap-around slices, with range adjusted for len(a) - len(b).","def cycpattern_check(a, b):
    return any(a[i:i + len(b)] == b for i in range(len(a))) or any(a[i:] + a[:len(b) - i] == b for i in range(len(a) - len(b)))",not useful
"This function verifies b as cyclic pattern by checking substrings and rotations, using a slightly extended range for wrap-arounds.","def cycpattern_check(a, b):
    return any(a[i:i + len(b)] == b for i in range(len(a))) or any(a[i:] + a[:len(b) - i] == b for i in range(len(a) - len(b) + 2))",not useful
This function tests if b appears in a or its rotations using substring checks and an extended range for wrap-arounds.,"def cycpattern_check(a, b):
    return any(a[i:i + len(b)] == b for i in range(len(a))) or any(a[i:] + a[:len(b) - i] == b for i in range(len(a) - len(b) + 3))",not useful
This function converts the absolute value of the input number to a string and uses generator expressions to count the number of even and odd digits by checking each digit's parity with modulo 2.,"def even_odd_count(num):
    num = str(abs(num))
    return (sum(1 for c in num if int(c) % 2 == 0), sum(1 for c in num if int(c) % 2 != 0))",useful
"It transforms the absolute number into a string, counts even digits by summing membership in the even digits string '02468', and derives the odd count by subtracting from the total length.","def even_odd_count(num):
    num = str(abs(num))
    even = sum(c in '02468' for c in num)
    return (even, len(num) - even)",useful
"The code converts the number to its absolute string form, applies map with a lambda to check even digits via string membership, sums the results for even count, and computes odd as the remainder.","def even_odd_count(num):
    num = str(abs(num))
    even = sum(map(lambda x: x in '02468', num))
    return (even, len(num) - even)",useful
"After converting to absolute string, it uses a list comprehension to collect even digits based on modulo check, takes the length for even count, and subtracts from total length for odd count.","def even_odd_count(num):
    num = str(abs(num))
    even = len([c for c in num if int(c) % 2 == 0])
    return (even, len(num) - even)",useful
"It stringifies the absolute number, filters digits that are even using a lambda with string membership, converts the filter object to a list to get its length for even count, and calculates odd as total minus even.","def even_odd_count(num):
    num = str(abs(num))
    even = len(list(filter(lambda x: x in '02468', num)))
    return (even, len(num) - even)",useful
"The function converts the number to absolute string, uses list comprehension to filter digits in the even string '02468', and returns even count as list length with odd as the difference from total length.","def even_odd_count(num):
    num = str(abs(num))
    even = len([c for c in num if c in '02468'])
    return (even, len(num) - even)",useful
"It processes the absolute string of the number, counts even digits with a generator expression checking membership in '02468', computes odd count separately as total length minus even, and returns the tuple.","def even_odd_count(num):
    num = str(abs(num))
    even = sum(c in '02468' for c in num)
    odd = len(num) - even
    return (even, odd)",useful
"This initializes a list [0, 0] for even and odd counts, iterates through the digits of the absolute string, increments the appropriate index based on the digit's modulo 2 parity, and returns the counts as a tuple.","def even_odd_count(num):
    num = str(abs(num))
    counts = [0, 0]
    for c in num:
        counts[int(c) % 2] += 1
    return tuple(counts)",useful
"After stringifying the absolute number, it uses a list [0, 0] and loops through digits, incrementing the even or odd count based on membership in the even digits string.","def even_odd_count(num):
    num = str(abs(num))
    counts = [0, 0]
    for c in num:
        if c in '02468':
            counts[0] += 1
        else:
            counts[1] += 1
    return tuple(counts)",useful
"The code uses a dictionary {0: 0, 1: 0} to track even and odd counts, iterates over the absolute string's digits, updates the count using modulo 2 as key, and returns the even and odd values.","def even_odd_count(num):
    num = str(abs(num))
    counts = {0: 0, 1: 0}
    for c in num:
        counts[int(c) % 2] += 1
    return (counts[0], counts[1])",useful
"It defines lists of Roman numeral values and corresponding mini symbols in descending order, then iteratively appends symbols and subtracts values while the input is sufficient for each position.","def int_to_mini_roman(n):
    v = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    s = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']
    r = ''
    for i in range(len(v)):
        while n >= v[i]:
            r += s[i]
            n -= v[i]
    return r",useful
"Using a dictionary mapping values to mini Roman symbols, the function iterates over the keys (in insertion order, descending), appending the symbol and subtracting the value repeatedly until the input drops below each key.","def int_to_mini_roman(n):
    d = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'}
    r = ''
    for k in d:
        while n >= k:
            r += d[k]
            n -= k
    return r",useful
"This recursive function attempts to build the Roman string by joining repeated symbols for each value's quotient of the input plus a recursive call on the remainder for every position, though it processes independently per index.","def int_to_mini_roman(n):
    v = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    s = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']
    return ''.join(s[i] * (n // v[i]) + int_to_mini_roman(n % v[i]) for i in range(len(v)))",not useful
"It employs a recursive approach with a dictionary of values to symbols, sorting keys descending, and concatenates repeated symbols for each key's quotient plus recursive remainder handling for each.","def int_to_mini_roman(n):
    d = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'}
    return ''.join(d[k] * (n // k) + int_to_mini_roman(n % k) for k in sorted(d, reverse=True))",not useful
"The function uses lists of values and symbols, starting from the first index, and in a loop subtracts and appends symbols for the current value until insufficient, then advances the index until the input is zero.","def int_to_mini_roman(n):
    v = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    s = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']
    i = 0
    r = ''
    while n > 0:
        while n >= v[i]:
            r += s[i]
            n -= v[i]
        i += 1
    return r",useful
"Starting with the maximum dictionary key, it repeatedly appends the symbol and subtracts while possible, then selects the next smaller key using a generator and continues until the input is depleted.","def int_to_mini_roman(n):
    d = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'}
    i = max(d.keys())
    r = ''
    while n > 0:
        while n >= i:
            r += d[i]
            n -= i
        i = next(k for k in sorted(d.keys(), reverse=True) if k < i)
    return r",useful
"With lists of values and symbols, it processes from largest to smallest using divmod to get the quotient for each value, appends the repeated symbol, updates the input to the remainder, and advances the index.","def int_to_mini_roman(n):
    v = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    s = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']
    i = 0
    r = ''
    while n > 0:
        q, n = divmod(n, v[i])
        r += s[i] * q
        i += 1
    return r",useful
"This uses a dictionary and starts with the max key, applies divmod for quotient and remainder, appends repeated symbols, then finds and sets the next smaller key, repeating until the input is zero.","def int_to_mini_roman(n):
    d = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'}
    i = max(d.keys())
    r = ''
    while n > 0:
        q, n = divmod(n, i)
        r += d[i] * q
        i = next(k for k in sorted(d.keys(), reverse=True) if k < i)
    return r",useful
"The code attempts a recursive construction by joining repeated symbols for each value's quotient and conditionally appending a recursive call on the remainder if the input meets the value, though the structure may produce incorrect results.","def int_to_mini_roman(n):
    v = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    s = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']
    return ''.join(s[i] * (n // v[i]) for i in range(len(v))) + int_to_mini_roman(n % v[i]) if n >= v[i] else ''",not useful
"It tries a recursive method with a dictionary, sorting keys descending, joining repeated symbols for each key's quotient plus a conditional recursive remainder, potentially leading to flawed output due to per-key independence.","def int_to_mini_roman(n):
    d = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'}
    return ''.join(d[k] * (n // k) for k in sorted(d, reverse=True)) + int_to_mini_roman(n % k) if n >= k else ''",not useful
The function sorts the three sides and checks if the Pythagorean theorem holds by verifying whether the sum of the squares of the two smaller sides equals the square of the largest side.,"def right_angle_triangle(a, b, c):
    sides = sorted([a, b, c])
    return sides[0]**2 + sides[1]**2 == sides[2]**2",useful
"It explicitly checks all three possible configurations where one side is the hypotenuse, verifying if the sum of the squares of the other two equals the hypotenuse's square.","def right_angle_triangle(a, b, c):
    return a*a + b*b == c*c or b*b + c*c == a*a or c*c + a*a == b*b",useful
"This returns true if any of the three permutations satisfies the Pythagorean theorem, checking each side as potential hypotenuse against the sum of squares of the others.","def right_angle_triangle(a, b, c):
    return (a**2 + b**2 == c**2) or (b**2 + c**2 == a**2) or (c**2 + a**2 == b**2)",useful
The code evaluates the Pythagorean condition for each possible hypotenuse by comparing the sum of squares of the remaining sides to the candidate hypotenuse's square.,"def right_angle_triangle(a, b, c):
    return a**2 + b**2 == c**2 or a**2 + c**2 == b**2 or b**2 + c**2 == a**2",useful
It generates all permutations of the sides using itertools.permutations and uses any() to check if any combination has the sum of squares of the first two equal to the third's square.,"def right_angle_triangle(a, b, c):
    return any(x**2 + y**2 == z**2 for x, y, z in permutations([a, b, c], 3))",not useful
"After sorting the sides, it incorrectly checks if the square of the sum of the two smaller sides equals the square of the largest, which does not properly test the Pythagorean theorem.","def right_angle_triangle(a, b, c):
    return sum(sorted([a, b, c])[:2])**2 == sorted([a, b, c])[2]**2",not useful
"This attempts to identify the smallest side and check Pythagorean conditions, but the logic is flawed as it misapplies inequalities and assumes incorrect hypotenuse positions.","def right_angle_triangle(a, b, c):
    return (a < b and a < c and a*a + b*b == c*c) or (b < a and b < c and a*a + b*b == c*c) or (c < a and c < b and a*a + b*b == c*c)",not useful
"The function checks the Pythagorean theorem for each side as hypotenuse, confirming if its square equals the sum of the squares of the other two sides.","def right_angle_triangle(a, b, c):
    return (a*a == b*b + c*c) or (b*b == a*a + c*c) or (c*c == a*a + b*b)",useful
"It verifies the right triangle condition by testing if any side's square equals the sum of the squares of the other two, covering all possible hypotenuse cases.","def right_angle_triangle(a, b, c):
    return (a**2 + b**2 == c**2) or (a**2 + c**2 == b**2) or (b**2 + c**2 == a**2)",useful
"This code returns true if the sum of squares of any two sides equals the square of the third, checking all combinations for a right-angled triangle.","def right_angle_triangle(a, b, c):
    return (a*a + b*b == c*c) or (a*a + c*c == b*b) or (b*b + c*c == a*a)",useful
"The function selects the word with the maximum number of unique characters using max with a key tuple of unique count and the word itself, choosing the lexicographically largest in ties.","def find_max(words):
    return max(words, key=lambda x: (len(set(x)), x))",useful
"It finds the word with the most unique characters by minimizing a key of negative unique count and the word string, resulting in the lexicographically smallest among ties.","def find_max(words):
    return min(words, key=lambda x: (-len(set(x)), x))",not useful
"The code sorts the words by descending unique count and ascending lexicographical order, then returns the first element, which has the max uniques and is the smallest in ties.","def find_max(words):
    return sorted(words, key=lambda x: (-len(set(x)), x))[0]",not useful
"It sorts the words by ascending unique count and word string in reverse, taking the first, which gives the maximum uniques and lexicographically largest in case of ties.","def find_max(words):
    return sorted(words, key=lambda x: (len(set(x)), x), reverse=True)[0]",useful
"After sorting the words lexicographically, it applies max based on unique character count, selecting the last (largest lex) among those with maximum uniques.","def find_max(words):
    return max(sorted(words), key=lambda x: len(set(x)))",not useful
"The function sorts words in reverse lexicographical order, then minimizes by negative unique count, yielding the word with max uniques and largest lex among ties due to the sorting.","def find_max(words):
    return min(sorted(words, reverse=True), key=lambda x: -len(set(x)))",not useful
"This minimizes a key of unique count and negative first character ordinal, incorrectly selecting the word with fewest uniques and, among them, the one with largest first character.","def find_max(words):
    return min(words, key=lambda x: (len(set(x)), -ord(x[0])))",not useful
"It maximizes a key of unique count and first character ordinal, selecting the word with most uniques and, in ties, the one with the largest first character.","def find_max(words):
    return max(words, key=lambda x: (len(set(x)), ord(x[0])))",not useful
"The code sorts by unique count and first character ordinal in reverse, taking the first, which picks max uniques and largest first character in ties, not full lexicographical order.","def find_max(words):
    return sorted(words, key=lambda x: (len(set(x)), ord(x[0])), reverse=True)[0]",not useful
"It sorts by descending unique count (via negative) and descending first character ordinal, returning the first, which is max uniques with largest first character among ties.","def find_max(words):
    return sorted(words, key=lambda x: (-len(set(x)), -ord(x[0])))[0]",not useful
"The function computes total eaten as min(current plus need, current plus remaining), then calculates new remaining as max(0, remaining minus (need minus additional eaten)), which may not correctly update remaining in all cases.","def eat(number, need, remaining):
    eaten = min(number + need, number + remaining)
    return [eaten, max(0, remaining - (need - (eaten - number)))]",useful
"It determines total eaten similarly via min, and updates remaining using max(0, remaining minus (need minus total eaten plus current)), aiming to reflect unused supply after satisfying need.","def eat(number, need, remaining):
    total_eaten = min(number + need, number + remaining)
    return [total_eaten, max(0, remaining - (need - total_eaten + number))]",not useful
"After calculating total eaten with min, new remaining is max(0, remaining minus need plus current minus total eaten), which adjusts for the actual consumption but may undercount in some scenarios.","def eat(number, need, remaining):
    total_eaten = min(number + need, number + remaining)
    return [total_eaten, max(0, remaining - need + number - total_eaten)]",useful
"The code sets total eaten to the min of possible increases, then new remaining as max(0, remaining minus need plus total eaten minus current), attempting to deduct the actual additional eaten from supply.","def eat(number, need, remaining):
    total_eaten = min(number + need, number + remaining)
    return [total_eaten, max(0, remaining - need + total_eaten - number)]",not useful
"It computes total eaten via min, and derives new remaining as max(0, remaining plus current minus need minus total eaten), which simplifies to remaining minus actual additional eaten in correct cases.","def eat(number, need, remaining):
    total_eaten = min(number + need, number + remaining)
    return [total_eaten, max(0, remaining + number - need - total_eaten)]",useful
"Similar to previous, total eaten is minimized, and remaining updated as max(0, remaining minus need plus total eaten minus current), effectively subtracting the fulfilled need from supply.","def eat(number, need, remaining):
    total_eaten = min(number + need, number + remaining)
    return [total_eaten, max(0, remaining - need + total_eaten - number)]",not useful
"The function uses the same min for total eaten and the formula max(0, remaining minus need plus total eaten minus current) for new remaining, balancing consumption against available supply.","def eat(number, need, remaining):
    total_eaten = min(number + need, number + remaining)
    return [total_eaten, max(0, remaining - need + total_eaten - number)]",not useful
"After min-based total eaten, it incorrectly computes new remaining as max(0, remaining minus need plus current plus total eaten), which overestimates the leftover supply.","def eat(number, need, remaining):
    total_eaten = min(number + need, number + remaining)
    return [total_eaten, max(0, remaining - need + number + total_eaten)]",useful
"This mirrors the prior, calculating total eaten with min and new remaining as max(0, remaining minus need plus current plus total eaten), leading to inflated remaining values.","def eat(number, need, remaining):
    total_eaten = min(number + need, number + remaining)
    return [total_eaten, max(0, remaining - need + number + total_eaten)]",useful
"The code determines total eaten via min of current plus need or remaining, then sets new remaining using max(0, remaining minus need plus current plus total eaten), which does not properly deduct consumption.","def eat(number, need, remaining):
    total_eaten = min(number + need, number + remaining)
    return [total_eaten, max(0, remaining - need + number + total_eaten)]",useful
"This function starts with the first operand as the result and iteratively applies each operator to the result and the corresponding next operand using a series of if-elif statements for addition, subtraction, multiplication, floor division, and exponentiation.","def do_algebra(operator, operand):
    result = operand[0]
    for i in range(len(operator)):
        if operator[i] == '+':
            result += operand[i+1]
        elif operator[i] == '-':
            result -= operand[i+1]
        elif operator[i] == '*':
            result *= operand[i+1]
        elif operator[i] == '//':
            result //= operand[i+1]
        elif operator[i] == '**':
            result **= operand[i+1]
    return result",useful
"This function defines a dictionary mapping operators to lambda functions for each operation, then uses zip to pair operators with subsequent operands and applies them sequentially to the initial result.","def do_algebra(operator, operand):
    operations = {'+': lambda x, y: x + y, '-': lambda x, y: x - y, '*': lambda x, y: x * y, '//': lambda x, y: x // y, '**': lambda x, y: x ** y}
    result = operand[0]
    for op, num in zip(operator, operand[1:]):
        result = operations[op](result, num)
    return result",useful
"This function imports specific arithmetic functions from the operator module and maps them to operators in a dictionary, then applies each operation sequentially using zip on operators and operands.","def do_algebra(operator, operand):
    from operator import add, sub, mul, floordiv, pow
    operations = {'+': add, '-': sub, '*': mul, '//': floordiv, '**': pow}
    result = operand[0]
    for op, num in zip(operator, operand[1:]):
        result = operations[op](result, num)
    return result",useful
"This function uses an if-elif chain within the loop to apply imported operator functions (add, sub, mul, floordiv, pow) to the result and each subsequent operand based on the operator.","def do_algebra(operator, operand):
    result = operand[0]
    for op, num in zip(operator, operand[1:]):
        if op == '+':
            result = add(result, num)
        elif op == '-':
            result = sub(result, num)
        elif op == '*':
            result = mul(result, num)
        elif op == '//':
            result = floordiv(result, num)
        elif op == '**':
            result = pow(result, num)
    return result",not useful
"This function constructs and evaluates a string expression using eval for each operator and operand pair, starting from the first operand, to compute the sequential result.","def do_algebra(operator, operand):
    result = operand[0]
    for op, num in zip(operator, operand[1:]):
        result = eval(f""{result} {op} {num}"")
    return result",useful
"This function imports the operator module and maps its functions to operators in a dictionary, then applies them sequentially to the initial result using zip on operators and operands.","def do_algebra(operator, operand):
    import operator as op
    operations = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}
    result = operand[0]
    for op, num in zip(operator, operand[1:]):
        result = operations[op](result, num)
    return result",useful
"This function uses a dictionary where each key is an operator and the value is the direct arithmetic expression, evaluating it for the current result and operand in each iteration.","def do_algebra(operator, operand):
    result = operand[0]
    for op, num in zip(operator, operand[1:]):
        result = {
            '+': result + num,
            '-': result - num,
            '*': result * num,
            '//': result // num,
            '**': result ** num
        }[op]
    return result",useful
"This function employs a conditional expression to call the appropriate magic method (__add__, __sub__, etc.) on the result with each operand based on the operator.","def do_algebra(operator, operand):
    result = operand[0]
    for op, num in zip(operator, operand[1:]):
        result = result.__add__(num) if op == '+' else result.__sub__(num) if op == '-' else result.__mul__(num) if op == '*' else result.__floordiv__(num) if op == '//' else result.__pow__(num)
    return result",useful
"This function defines a dictionary of lambda functions for operations inside the loop, looking up and applying the function for each operator to the result and operand.","def do_algebra(operator, operand):
    result = operand[0]
    for op, num in zip(operator, operand[1:]):
        result = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '//': lambda x, y: x // y,
            '**': lambda x, y: x ** y
        }[op](result, num)
    return result",useful
"This function uses a dictionary mapping operators to imported operator functions (add, sub, etc.) and applies the looked-up function to the result and each subsequent operand.","def do_algebra(operator, operand):
    result = operand[0]
    for op, num in zip(operator, operand[1:]):
        result = {
            '+': add,
            '-': sub,
            '*': mul,
            '//': floordiv,
            '**': pow
        }[op](result, num)
    return result",not useful
"This function reverses the string; if it consists entirely of alphabetic characters, it swaps the case of letters while preserving non-letters during the reversal.","def solve(s):
    return ''.join([c.swapcase() if c.isalpha() else c for c in s[::-1]]) if s.isalpha() else s[::-1]",useful
"This function checks if the string is all alphabetic; if so, it reverses the string and swaps case for letters while keeping non-letters unchanged; otherwise, it just reverses.","def solve(s):
    return ''.join(c.swapcase() if c.isalpha() else c for c in reversed(s)) if s.isalpha() else s[::-1]",useful
"This function uses map with a lambda to swap case for alphabetic characters after reversing the string if it's all letters; otherwise, it simply reverses the string.","def solve(s):
    return ''.join(map(lambda c: c.swapcase() if c.isalpha() else c, s[::-1])) if s.isalpha() else s[::-1]",useful
"This function reverses a list where alphabetic characters are swapped in case if the string is all letters; non-letters are preserved, and for other strings, it just reverses.","def solve(s):
    return ''.join(reversed([c.swapcase() if c.isalpha() else c for c in s])) if s.isalpha() else s[::-1]",useful
"This function applies a lambda via map to swap case for letters, reverses the list if the string is all alphabetic; otherwise, it reverses the original string.","def solve(s):
    return ''.join(reversed(list(map(lambda c: c.swapcase() if c.isalpha() else c, s)))) if s.isalpha() else s[::-1]",useful
"This function generates a generator for case-swapped letters, converts to list, reverses it if all alphabetic; else reverses the string directly.","def solve(s):
    return ''.join(reversed(list(c.swapcase() if c.isalpha() else c for c in s))) if s.isalpha() else s[::-1]",useful
"This function first swaps case for alphabetic characters in the string if all letters, then reverses the result; otherwise, just reverses the original.","def solve(s):
    return ''.join(c.swapcase() if c.isalpha() else c for c in s)[::-1] if s.isalpha() else s[::-1]",useful
"This function uses map with a lambda on the reversed string to swap case for letters if all alphabetic; otherwise, reverses the string.","def solve(s):
    return ''.join(map(lambda c: c.swapcase() if c.isalpha() else c, reversed(s))) if s.isalpha() else s[::-1]",useful
"This function creates a list from a generator swapping case for letters, reverses it if the string is all alphabetic; else reverses directly.","def solve(s):
    return ''.join(reversed(list(c.swapcase() if c.isalpha() else c for c in s))) if s.isalpha() else s[::-1]",useful
"This function reverses the string and swaps case for alphabetic characters if the string is entirely letters; otherwise, it simply reverses.","def solve(s):
    return ''.join(c.swapcase() if c.isalpha() else c for c in reversed(s)) if s.isalpha() else s[::-1]",useful
"This function computes the MD5 hash of the input text by encoding it to bytes and returning the hexadecimal digest if text is provided; otherwise, returns None.","import hashlib
def string_to_md5(text):
    return hashlib.md5(text.encode()).hexdigest() if text else None",useful
This function returns the hexadecimal MD5 digest of the encoded text if it exists; uses a boolean check to handle empty input implicitly as falsy.,"import hashlib
def string_to_md5(text):
    return text and hashlib.md5(text.encode()).hexdigest()",not useful
This function imports md5 directly and computes its hexadecimal digest on the encoded text if provided; returns None for empty input.,"from hashlib import md5
def string_to_md5(text):
    return md5(text.encode()).hexdigest() if text else None",useful
"This function uses a direct md5 import and returns the hexadecimal digest if text is truthy, implicitly handling empty input.","from hashlib import md5
def string_to_md5(text):
    return text and md5(text.encode()).hexdigest()",not useful
"This function explicitly checks for non-empty text before computing and returning the MD5 hexadecimal digest of the encoded input; otherwise, None.","import hashlib
def string_to_md5(text):
    return None if not text else hashlib.md5(text.encode()).hexdigest()",useful
"This function imports md5 and returns None if text is empty, else computes the hexadecimal digest of the encoded text.","from hashlib import md5
def string_to_md5(text):
    return None if not text else md5(text.encode()).hexdigest()",useful
This function uses an immediately invoked lambda to compute the MD5 hash of the encoded text if provided; returns None otherwise.,"import hashlib
def string_to_md5(text):
    return (lambda x: hashlib.md5(x.encode()).hexdigest())(text) if text else None",useful
This function employs an IIFE lambda with direct md5 import to generate the hexadecimal digest if text exists; None for empty.,"from hashlib import md5
def string_to_md5(text):
    return (lambda x: md5(x.encode()).hexdigest())(text) if text else None",useful
"This function computes the MD5 digest and uses 'or None' to return None if the result is falsy, though hashes are never empty strings.","import hashlib
def string_to_md5(text):
    return hashlib.md5(text.encode()).hexdigest() or None",not useful
"This function imports md5 directly and computes the digest, using 'or None' for empty input, but hashes won't be falsy.","from hashlib import md5
def string_to_md5(text):
    return md5(text.encode()).hexdigest() or None",not useful
This function generates even integers from the minimum of a and b to the maximum inclusive using a list comprehension with modulo check.,"def generate_integers(a, b):
    return [i for i in range(min(a, b), max(a, b) + 1) if i % 2 == 0]",useful
"This function uses filter with a lambda to select even numbers from the range between min(a,b) and max(a,b) inclusive.","def generate_integers(a, b):
    return list(filter(lambda x: x % 2 == 0, range(min(a, b), max(a, b) + 1)))",useful
"This function generates numbers stepping by 2 from a to b+1 if a < b, or from b to a+1 if a > b, assuming even starts.","def generate_integers(a, b):
    return [i for i in range(a, b + 1, 2)] if a < b else [i for i in range(b, a + 1, 2)]",not useful
"This function creates a range stepping by 2 from a to b if a < b, or from b to a reversing the list if a > b, targeting evens.","def generate_integers(a, b):
    return list(range(a, b + 1, 2)) if a < b else list(range(b, a + 1, 2))[::-1]",not useful
This function attempts to generate evens from a to b by ranging to b-1 step 2 and adding b if even and a < b; empty otherwise.,"def generate_integers(a, b):
    return [i for i in range(a, b - 1, 2)] + [b] if a < b and b % 2 == 0 else []",not useful
"This function adjusts start to next even by adding modulo 2, then steps by 2 up to b+1 if a < b, or reverse direction.","def generate_integers(a, b):
    return [i for i in range(a + (a % 2), b + 1, 2)] if a < b else [i for i in range(b + (b % 2), a + 1, 2)]",useful
"This function ranges step 2 to b minus modulo 2 if a < b, adds b if even; similar reverse for a > b, adding a.","def generate_integers(a, b):
    return [i for i in range(a, b - (b % 2), 2)] + [b] if a < b else [i for i in range(b, a - (a % 2), 2)] + [a]",not useful
"This function adjusts both start and end for evenness using modulo, then generates range step 2 from min to max adjusted.","def generate_integers(a, b):
    return [i for i in range(a + (a % 2), b - (b % 2) + 1, 2)] if a < b else [i for i in range(b + (b % 2), a - (a % 2) + 1, 2)]",not useful
"This function filters evens from a to b+1, then reverses the list if a > b to ensure ascending order.","def generate_integers(a, b):
    return [i for i in range(a, b + 1) if i % 2 == 0][::-1] if a > b else [i for i in range(a, b + 1) if i % 2 == 0]",not useful
This function generates step 2 ranges and appends endpoint if even for ascending or descending cases; empty if conditions not met.,"def generate_integers(a, b):
    return [i for i in range(a, b - 1, 2)] + [b] if a < b and b % 2 == 0 else [i for i in range(b, a - 1, 2)] + [a] if a > b and a % 2 == 0 else []",not useful
